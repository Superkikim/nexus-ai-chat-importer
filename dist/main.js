/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/i18n/locales/en.json
var en_default;
var init_en = __esm({
  "src/i18n/locales/en.json"() {
    en_default = {
      common: {
        buttons: {
          cancel: "Cancel",
          ok: "OK",
          select: "Select",
          browse: "Browse",
          continue: "Continue",
          proceed: "Proceed",
          close: "Got it!",
          create: "Create",
          remove: "Remove",
          run: "Run",
          complete: "Complete",
          view_report: "View Report",
          get_started: "Get Started",
          create_new_folder: "Create New Folder"
        },
        status: {
          new: "New",
          updated: "Updated",
          unchanged: "Unchanged",
          unknown: "Unknown"
        },
        progress: {
          phase_validation: "\u{1F50D} Validation",
          phase_scanning: "\u{1F4CB} Scanning",
          phase_processing: "\u2699\uFE0F Processing",
          phase_writing: "\u{1F4BE} Writing",
          phase_complete: "\u2705 Complete",
          phase_error: "\u274C Error"
        }
      },
      provider_selection: {
        title: "Select Archive Provider",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "OpenAI ChatGPT conversation exports",
            file_formats_0: "conversations.json (legacy) or conversations-XXX.json files"
          },
          claude: {
            name: "Claude",
            description: "Anthropic Claude conversation exports",
            file_formats_0: "conversations.json + users.json",
            file_formats_1: "projects.json (optional)"
          },
          lechat: {
            name: "Le Chat",
            description: "Mistral AI Le Chat conversation exports",
            file_formats_0: "chat-<uuid>.json files"
          }
        },
        buttons: {
          select: "Select",
          cancel: "Cancel"
        }
      },
      file_selection: {
        title: "Import {{provider}} Conversations",
        import_mode: {
          section_title: "Import Mode",
          all_label: "Import All",
          all_description: "Import all conversations (faster)",
          selective_label: "Select Specific",
          selective_description: "Preview and choose conversations"
        },
        file_area: {
          section_title: "Select Files",
          drop_text_default: "Drop ZIP files here or click to browse",
          drop_text_gemini: "Drop ZIP and JSON files here or click to browse",
          drop_subtext_default: "Supports multiple file selection",
          drop_subtext_gemini: "ZIP (Takeout) + optional JSON (index from extension)"
        },
        selected_files: {
          section_title: "Selected Files",
          remove_button: "Remove"
        },
        buttons: {
          cancel: "Cancel",
          continue: "Continue"
        }
      },
      conversation_selection: {
        title: "Select Conversations to Import",
        controls: {
          select_all: "Select All",
          select_none: "Select None",
          search_placeholder: "Search conversations...",
          status_label: "Status:",
          show_label: "Show:"
        },
        status_filter_options: {
          all: "All",
          new: "New",
          updated: "Updated",
          unchanged: "Unchanged"
        },
        table_headers: {
          title: "Title",
          created: "Created",
          updated: "Updated",
          messages: "Messages",
          status: "Status"
        },
        status_badges: {
          new: "New",
          updated: "Updated",
          unchanged: "Unchanged",
          unknown: "Unknown",
          tooltip_new: "This conversation is not in your vault",
          tooltip_updated: "This conversation has newer content than your vault ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "This conversation is the same as in your vault"
        },
        pagination: {
          showing: "Showing {{start}}-{{end}} of {{total}} conversations",
          page_of: "Page {{current}} of {{total}}",
          previous: "Previous",
          next: "Next"
        },
        summary: {
          unique_conversations: "Unique Conversations",
          new: "New",
          updated: "Updated",
          unchanged: "Unchanged",
          selected_of: "{{selected}} of {{total}} selected"
        },
        buttons: {
          cancel: "Cancel",
          import_selected: "Import Selected",
          import_selected_count: "Import {{count}} Selected"
        },
        date_unknown: "Unknown"
      },
      import_progress: {
        title: "Importing {{filename}}",
        initial: {
          title: "Preparing import...",
          detail: "Validating ZIP file structure"
        },
        conversation_counter: "{{current}}/{{total}} conversations",
        conversation_counter_selective: "{{current}}/{{total}} selected conversations",
        selective_mode_indicator: "\u{1F4CB} Selective Import: {{selected}} of {{total}} conversations",
        complete: {
          message: "Import completed successfully",
          detail: "You can close this dialog"
        },
        error: {
          message: "An error occurred during import",
          detail: "Check the console for more details"
        }
      },
      import_completion: {
        title: "Import Completed",
        success_message: "\u2705 Successfully imported conversations",
        stats: {
          zip_files_processed: "ZIP Files Processed",
          unique_conversations: "Unique Conversations",
          duplicates: "Duplicates",
          new: "New",
          updated: "Updated",
          skipped: "Skipped",
          failed: "Failed"
        },
        attachments: {
          label: "Attachments:",
          summary: "{{found}}/{{total}} extracted ({{percentage}}%)",
          missing_failed: "{{missing}} missing, {{failed}} failed"
        },
        report: {
          label: "\u{1F4C4} Detailed report:"
        },
        buttons: {
          view_report: "View Report",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Folder Structure",
          conversation_folder: {
            name: "Conversation folder",
            desc: "Where imported conversations are stored",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Browse folders or create a new one"
          },
          reports_folder: {
            name: "Reports folder",
            desc: "Where import reports are stored",
            placeholder: "Nexus Reports",
            browse_tooltip: "Browse folders or create a new one"
          },
          attachment_folder: {
            name: "Attachment folder",
            desc: "Where attachments are stored (\u26A0\uFE0F Exclude from sync to save space)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Browse folders or create a new one"
          }
        },
        display: {
          section_title: "\u{1F4C5} Date Prefix",
          add_date_prefix: {
            name: "Add date prefix to filenames",
            desc: "Add creation date as a prefix to conversation filenames",
            format_label: "Select date format: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Message Date Format",
          custom_format: {
            name: "Custom message timestamp format",
            desc: "Override the default locale-based timestamp format in message headers. When disabled, timestamps follow Obsidian's language setting. If Obsidian is set to english, the US format (YYYY/DD/MM) is enforced."
          },
          timestamp_format: {
            name: "Timestamp format",
            desc: "Choose the format for message timestamps in conversation notes"
          },
          preview_label: "Preview: "
        },
        attachments: {
          section_title: "Attachment Settings",
          import_attachments: {
            name: "Import attachments",
            desc: "Save attachment files to disk and link them in conversations (uses 'best effort' strategy)"
          },
          handle_missing: {
            name: "Handle missing attachments",
            desc: "When attachments are missing from exports, create informative notes instead of skipping them"
          },
          show_details: {
            name: "Show attachment details in reports",
            desc: "Include detailed attachment processing statistics in import reports"
          },
          info_box: {
            title: "\u{1F4CE} About Attachment Handling",
            best_effort: "Best Effort Strategy: Files found in exports are extracted and linked; missing files get informative notes.",
            platform_diff: "Platform Differences: ChatGPT exports may not include all attachments, especially from older conversations.",
            organization: "Simple Organization: Files organized as attachments/provider/category/ (e.g., attachments/chatgpt/images/).",
            sync_tip: "Sync Tip: Consider excluding the attachment folder from sync to avoid uploading large files.",
            tip: "\u{1F4A1} Tip: Enable 'Show attachment details' to see exactly which files were found, missing, or failed during import."
          }
        },
        migrations: {
          section_title: "Migrations",
          description_manual: "Manual Operations: Optional upgrade operations that can be run when convenient.",
          description_automatic: "Automatic operations (like removing old data) run automatically during upgrade and are not shown here.",
          version_header: "Version {{version}}",
          no_migrations: {
            title: "No manual operations available",
            desc: "All upgrade operations have been completed automatically."
          },
          operation_completed_suffix: " \u2705 Completed",
          buttons: {
            completed: "\u2705 Completed",
            cannot_run: "Cannot Run",
            run: "Run",
            running: "Running..."
          },
          tooltips: {
            completed: "This operation has been completed",
            cannot_run: "Prerequisites not met for this operation",
            run: "Execute {{operation_name}}"
          },
          error_loading: "Error loading migrations:"
        },
        support: {
          section_title: "\u{1F49D} Support & Help",
          resources: {
            name: "\u{1F4DA} Resources",
            desc: "Documentation, release notes, and community links",
            documentation: "\u{1F4D6} Documentation",
            release_notes: "\u{1F4DD} Release Notes",
            issues: "\u{1F41B} Issues",
            forum: "\u{1F4AC} Forum"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "Starting...",
          progress_label: "Progress: {{percentage}}%",
          step_label: "Step {{current}}/{{total}}",
          complete_label: "Complete",
          complete_message: "Completed successfully",
          error_message: "An error occurred"
        },
        multi_operation_modal: {
          progress_label: "Progress: {{completed}}/{{total}} operations",
          progress_with_failures: "Progress: {{completed}}/{{total}} operations ({{failed}} failed)",
          all_completed: "All {{total}} operations completed successfully",
          mark_complete_default: "All operations completed successfully",
          buttons: {
            complete: "Complete",
            close: "Close"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migration Required",
            message: "The following tasks will run automatically to upgrade your data to v1.3.0:",
            tasks: {
              folder_settings: "\u2713 Migrate folder settings to new structure",
              timestamps: "\u2713 Update timestamps to ISO 8601 format",
              aliases: "\u2713 Fix frontmatter aliases",
              reports: "\u2713 Move Reports folder to proper location",
              artifacts: "\u2713 Update artifact metadata"
            },
            estimate: "This will take a few seconds."
          },
          buttons: {
            run_migration: "\u{1F680} Run Migration Tasks"
          }
        },
        complete_modal: {
          title: "\u2705 Upgrade Complete - v{{version}}",
          buttons: {
            got_it: "Got it!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "Got it!"
          }
        }
      },
      folder_migration: {
        title: "Move Existing Files?",
        message_intro: "You are changing the {{folder_type}} folder location:",
        path_from: "From: {{path}}",
        path_to: "To: {{path}}",
        question: "Do you want to move existing files to the new location?",
        link_updates: {
          title: "\u{1F517} Link Updates:",
          attachments_text: "Moving attachments will also update all conversation notes that reference them.",
          conversations_text: "Moving conversations will also update all reports and attachments that reference them.",
          estimated_time_seconds: "Estimated time: ~{{seconds}} seconds",
          estimated_time_minutes: "Estimated time: ~{{minutes}} minute(s)"
        },
        warning: {
          title: "\u26A0\uFE0F Important:",
          text: "If you choose 'No', existing files will remain in the old location and will not be impacted by future updates."
        },
        buttons: {
          cancel: "Cancel",
          keep: "No, keep files in old location",
          move: "Yes, move files",
          move_with_links: "Yes, move files and update links"
        },
        progress: {
          title_moving: "Moving {{folder_type}} and updating links",
          step_moving_title: "Moving files...",
          step_moving_detail: "Moving from {{old_path}} to {{new_path}}",
          step_moving_count: "{{current}} / {{total}} files processed",
          step_moved_title: "Files moved",
          step_moved_detail: "{{moved}} files moved, {{skipped}} skipped. Preparing to update links...",
          step_updating_attachment_links: "Updating attachment links...",
          step_updating_conversation_links: "Updating conversation links...",
          step_updating_report_links: "Updating links in reports...",
          step_updating_artifact_links: "Updating links in artifacts...",
          complete_message: "{{moved}} files moved. {{links}} links updated successfully"
        },
        result_dialog: {
          title: "Folder Migration Result",
          summary_title: "Migration Summary",
          moved: "\u2705 Successfully moved: {{count}} file(s)",
          skipped: "\u26A0\uFE0F Skipped (already exist): {{count}} file(s)",
          errors: "\u274C Errors: {{count}} file(s)",
          explanation: "Files that already existed in the destination were not overwritten to preserve your data.",
          error_details_title: "Error Details:"
        },
        error_target_not_empty: {
          title: "Target Folder Not Empty",
          message: 'The folder "{{path}}" already contains files.\n\nTo change the folder location:\n\u2022 Move existing files manually in Obsidian, OR\n\u2022 Choose an empty folder or create a new one'
        },
        error_migration_failed: {
          title: "Migration Failed",
          message_move: "Failed to move files: {{error}}",
          message_links: "Failed to move files or update links: {{error}}"
        }
      },
      folder_browser: {
        title: "Select Folder",
        vault_root: "Vault Root (/)",
        buttons: {
          create_new_folder: "Create New Folder",
          cancel: "Cancel",
          select: "Select"
        },
        create_folder_dialog: {
          title: "Create New Folder",
          folder_name_label: "Folder name:",
          buttons: {
            cancel: "Cancel",
            create: "Create"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Please select a parent folder first",
          invalid_name: "\u274C Invalid folder name: contains illegal characters",
          already_exists: "\u274C Folder already exists",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Created folder: {{name}}",
          create_failed: "\u274C Failed to create folder: {{error}}",
          select_first: "\u26A0\uFE0F Please select a folder first"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "In version 1.3.0, you can specify a folder for Reports. We will move existing reports to {{folder}}, or you can select your preferred folder below.",
        note: "Note: The folder cannot be inside Conversations or Attachments.",
        report_folder_label: "\u{1F4CA} Report Folder",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Browse",
          proceed: "Proceed"
        },
        error_invalid_folder: {
          title: "Invalid Folder Location",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Thank you for installing Nexus AI Chat Importer!",
        description: "Import and manage your ChatGPT, Claude, and Le Chat conversations directly in your Obsidian vault.",
        resources_title: "Resources",
        resources: {
          documentation: {
            title: "Documentation",
            description: "Learn how to use the plugin"
          },
          release_notes: {
            title: "Release Notes",
            description: "What's new in this version"
          },
          report_issues: {
            title: "Report Issues",
            description: "Found a bug? Let us know"
          },
          community_forum: {
            title: "Community Forum",
            description: "Join the discussion"
          }
        },
        buttons: {
          get_started: "Get Started"
        }
      },
      notices: {
        import_analyzing: "Analyzing conversations from {{count}} file(s)...",
        import_no_new: "No new or updated conversations found. All conversations are already up to date.",
        import_starting: "Importing {{count}} conversations ({{new}} new, {{updated}} updated)...",
        import_starting_selected: "Importing {{count}} selected conversations from {{files}} file(s)...",
        import_completed_fallback: "Import completed. {{created}} created, {{updated}} updated.",
        import_error: "Error during import: {{error}}",
        import_error_analyzing: "Error analyzing conversations: {{error}}",
        import_error_file: "Error processing {{filename}}. Check console for details.",
        import_no_selected: "No conversations selected for import.",
        import_no_zip_gemini: "Please select at least one Gemini Takeout ZIP file (plus optional JSON index from the extension).",
        import_no_zip: "Please select at least one ZIP export file.",
        import_gemini_json_failed: "Failed to read Gemini index JSON. Continuing without index.",
        report_failed: "Failed to create log file. Check console for details.",
        attachment_map_failed: "Failed to build attachment map. Check console for details.",
        ribbon_tooltip: "Nexus AI Chat Importer - Import new file"
      },
      commands: {
        import_conversations: {
          name: "Import AI conversations"
        }
      },
      support_box: {
        header: "Support This Plugin",
        header_highlight: "Support This Plugin",
        default_message_emphasis: "I'm working on Nexus projects full-time while unemployed and dealing with health issues.",
        default_message: "If this plugin makes your life easier, a donation would mean the world to me and help keep them alive.",
        reality_check: "Thank you! Thousands of hours of work have gone into these plugins, and every donation helps me keep improving them while managing ongoing health issues. If this plugin makes your life easier, please consider supporting me.",
        button_alt: "Support my work"
      }
    };
  }
});

// src/i18n/locales/fr.json
var fr_default;
var init_fr = __esm({
  "src/i18n/locales/fr.json"() {
    fr_default = {
      common: {
        buttons: {
          cancel: "Annuler",
          ok: "OK",
          select: "S\xE9lectionner",
          browse: "Parcourir",
          continue: "Continuer",
          proceed: "Proc\xE9der",
          close: "Compris !",
          create: "Cr\xE9er",
          remove: "Supprimer",
          run: "Ex\xE9cuter",
          complete: "Terminer",
          view_report: "Voir le rapport",
          get_started: "Commencer",
          create_new_folder: "Cr\xE9er un nouveau dossier"
        },
        status: {
          new: "Nouveau",
          updated: "Mis \xE0 jour",
          unchanged: "Inchang\xE9",
          unknown: "Inconnu"
        },
        progress: {
          phase_validation: "\u{1F50D} Validation",
          phase_scanning: "\u{1F4CB} Analyse",
          phase_processing: "\u2699\uFE0F Traitement",
          phase_writing: "\u{1F4BE} \xC9criture",
          phase_complete: "\u2705 Termin\xE9",
          phase_error: "\u274C Erreur"
        }
      },
      provider_selection: {
        title: "S\xE9lectionner le fournisseur d'archive",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "Exports de conversations OpenAI ChatGPT"
          },
          claude: {
            name: "Claude",
            description: "Exports de conversations Anthropic Claude"
          },
          lechat: {
            name: "Le Chat",
            description: "Exports de conversations Mistral AI Le Chat"
          }
        },
        buttons: {
          select: "S\xE9lectionner",
          cancel: "Annuler"
        }
      },
      file_selection: {
        title: "Importer les conversations {{provider}}",
        import_mode: {
          section_title: "Mode d'importation",
          all_label: "Tout importer",
          all_description: "Importer toutes les conversations (plus rapide)",
          selective_label: "S\xE9lection sp\xE9cifique",
          selective_description: "Pr\xE9visualiser et choisir les conversations"
        },
        file_area: {
          section_title: "S\xE9lectionner les fichiers",
          drop_text_default: "D\xE9posez des fichiers ZIP ici ou cliquez pour parcourir",
          drop_text_gemini: "D\xE9posez des fichiers ZIP et JSON ici ou cliquez pour parcourir",
          drop_subtext_default: "Prend en charge la s\xE9lection multiple de fichiers",
          drop_subtext_gemini: "ZIP (Takeout) + JSON optionnel (index depuis l'extension)"
        },
        selected_files: {
          section_title: "Fichiers s\xE9lectionn\xE9s",
          remove_button: "Supprimer"
        },
        buttons: {
          cancel: "Annuler",
          continue: "Continuer"
        }
      },
      conversation_selection: {
        title: "S\xE9lectionner les conversations \xE0 importer",
        controls: {
          select_all: "Tout s\xE9lectionner",
          select_none: "Tout d\xE9s\xE9lectionner",
          search_placeholder: "Rechercher des conversations...",
          status_label: "Statut :",
          show_label: "Afficher :"
        },
        status_filter_options: {
          all: "Tous",
          new: "Nouveau",
          updated: "Mis \xE0 jour",
          unchanged: "Inchang\xE9"
        },
        table_headers: {
          title: "Titre",
          created: "Cr\xE9\xE9",
          updated: "Mis \xE0 jour",
          messages: "Messages",
          status: "Statut"
        },
        status_badges: {
          new: "Nouveau",
          updated: "Mis \xE0 jour",
          unchanged: "Inchang\xE9",
          unknown: "Inconnu",
          tooltip_new: "Cette conversation n'est pas dans votre Vault",
          tooltip_updated: "Cette conversation a un contenu plus r\xE9cent que votre Vault ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "Cette conversation est identique \xE0 celle de votre Vault"
        },
        pagination: {
          showing: "Affichage de {{start}}-{{end}} sur {{total}} conversations",
          page_of: "Page {{current}} sur {{total}}",
          previous: "Pr\xE9c\xE9dent",
          next: "Suivant"
        },
        summary: {
          unique_conversations: "Conversations uniques",
          new: "Nouveau",
          updated: "Mis \xE0 jour",
          unchanged: "Inchang\xE9",
          selected_of: "{{selected}} sur {{total}} s\xE9lectionn\xE9es"
        },
        buttons: {
          cancel: "Annuler",
          import_selected: "Importer la s\xE9lection",
          import_selected_count: "Importer {{count}} s\xE9lectionn\xE9es"
        },
        date_unknown: "Inconnu"
      },
      import_progress: {
        title: "Importation de {{filename}}",
        initial: {
          title: "Pr\xE9paration de l'importation...",
          detail: "Validation de la structure du fichier ZIP"
        },
        conversation_counter: "{{current}}/{{total}} conversations",
        conversation_counter_selective: "{{current}}/{{total}} conversations s\xE9lectionn\xE9es",
        selective_mode_indicator: "\u{1F4CB} Importation s\xE9lective : {{selected}} sur {{total}} conversations",
        complete: {
          message: "Importation termin\xE9e avec succ\xE8s",
          detail: "Vous pouvez fermer cette fen\xEAtre"
        },
        error: {
          message: "Une erreur s'est produite lors de l'importation",
          detail: "Consultez la console pour plus de d\xE9tails"
        }
      },
      import_completion: {
        title: "Importation termin\xE9e",
        success_message: "\u2705 Conversations import\xE9es avec succ\xE8s",
        stats: {
          zip_files_processed: "Fichiers ZIP trait\xE9s",
          unique_conversations: "Conversations uniques",
          duplicates: "Doublons",
          new: "Nouveau",
          updated: "Mis \xE0 jour",
          skipped: "Ignor\xE9s",
          failed: "\xC9chou\xE9s"
        },
        attachments: {
          label: "Pi\xE8ces jointes :",
          summary: "{{found}}/{{total}} extraites ({{percentage}}%)",
          missing_failed: "{{missing}} manquantes, {{failed}} \xE9chou\xE9es"
        },
        report: {
          label: "\u{1F4C4} Rapport d\xE9taill\xE9 :"
        },
        buttons: {
          view_report: "Voir le rapport",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Structure des dossiers",
          conversation_folder: {
            name: "Dossier des conversations",
            desc: "O\xF9 les conversations import\xE9es sont stock\xE9es",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Parcourir les dossiers ou en cr\xE9er un nouveau"
          },
          reports_folder: {
            name: "Dossier des rapports",
            desc: "O\xF9 les rapports d'importation sont stock\xE9s",
            placeholder: "Nexus Reports",
            browse_tooltip: "Parcourir les dossiers ou en cr\xE9er un nouveau"
          },
          attachment_folder: {
            name: "Dossier des pi\xE8ces jointes",
            desc: "O\xF9 les pi\xE8ces jointes sont stock\xE9es (\u26A0\uFE0F Exclure de la synchronisation pour \xE9conomiser de l'espace)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Parcourir les dossiers ou en cr\xE9er un nouveau"
          }
        },
        display: {
          section_title: "\u{1F4C5} Pr\xE9fixe de date",
          add_date_prefix: {
            name: "Ajouter un pr\xE9fixe de date aux noms de fichiers",
            desc: "Ajouter la date de cr\xE9ation comme pr\xE9fixe aux noms de fichiers de conversation",
            format_label: "S\xE9lectionner le format de date : "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Format de date des messages",
          custom_format: {
            name: "Format d'horodatage personnalis\xE9 des messages",
            desc: "Remplacer le format d'horodatage par d\xE9faut bas\xE9 sur la locale dans les en-t\xEAtes de messages. Lorsque d\xE9sactiv\xE9, les horodatages suivent le param\xE8tre de langue d'Obsidian. Si Obsidian est en anglais, le format am\xE9ricain (YYYY/DD/MM) est appliqu\xE9."
          },
          timestamp_format: {
            name: "Format d'horodatage",
            desc: "Choisir le format des horodatages de messages dans les notes de conversation"
          },
          preview_label: "Aper\xE7u : "
        },
        attachments: {
          section_title: "Param\xE8tres des pi\xE8ces jointes",
          import_attachments: {
            name: "Importer les pi\xE8ces jointes",
            desc: "Enregistrer les fichiers joints sur le disque et les lier dans les conversations (utilise une strat\xE9gie de \xAB meilleur effort \xBB)"
          },
          handle_missing: {
            name: "G\xE9rer les pi\xE8ces jointes manquantes",
            desc: "Lorsque des pi\xE8ces jointes sont absentes des exports, cr\xE9er des notes informatives plut\xF4t que de les ignorer"
          },
          show_details: {
            name: "Afficher les d\xE9tails des pi\xE8ces jointes dans les rapports",
            desc: "Inclure des statistiques d\xE9taill\xE9es sur le traitement des pi\xE8ces jointes dans les rapports d'importation"
          },
          info_box: {
            title: "\u{1F4CE} \xC0 propos de la gestion des pi\xE8ces jointes",
            best_effort: "Strat\xE9gie de meilleur effort : Les fichiers trouv\xE9s dans les exports sont extraits et li\xE9s ; les fichiers manquants re\xE7oivent des notes informatives.",
            platform_diff: "Diff\xE9rences selon les plateformes : Les exports ChatGPT peuvent ne pas inclure toutes les pi\xE8ces jointes, notamment celles des conversations plus anciennes.",
            organization: "Organisation simple : Les fichiers sont organis\xE9s sous attachments/fournisseur/cat\xE9gorie/ (ex. : attachments/chatgpt/images/).",
            sync_tip: "Conseil de synchronisation : Envisagez d'exclure le dossier des pi\xE8ces jointes de la synchronisation pour \xE9viter d'envoyer de gros fichiers.",
            tip: "\u{1F4A1} Conseil : Activez \xAB Afficher les d\xE9tails des pi\xE8ces jointes \xBB pour voir exactement quels fichiers ont \xE9t\xE9 trouv\xE9s, manquants ou \xE9chou\xE9s lors de l'importation."
          }
        },
        migrations: {
          section_title: "Migrations",
          description_manual: "Op\xE9rations manuelles : Op\xE9rations de mise \xE0 niveau optionnelles pouvant \xEAtre ex\xE9cut\xE9es \xE0 votre convenance.",
          description_automatic: "Les op\xE9rations automatiques (comme la suppression des anciennes donn\xE9es) s'ex\xE9cutent automatiquement lors de la mise \xE0 niveau et ne sont pas affich\xE9es ici.",
          version_header: "Version {{version}}",
          no_migrations: {
            title: "Aucune op\xE9ration manuelle disponible",
            desc: "Toutes les op\xE9rations de mise \xE0 niveau ont \xE9t\xE9 effectu\xE9es automatiquement."
          },
          operation_completed_suffix: " \u2705 Termin\xE9",
          buttons: {
            completed: "\u2705 Termin\xE9",
            cannot_run: "Impossible d'ex\xE9cuter",
            run: "Ex\xE9cuter",
            running: "En cours..."
          },
          tooltips: {
            completed: "Cette op\xE9ration a \xE9t\xE9 effectu\xE9e",
            cannot_run: "Les pr\xE9requis ne sont pas remplis pour cette op\xE9ration",
            run: "Ex\xE9cuter {{operation_name}}"
          },
          error_loading: "Erreur lors du chargement des migrations :"
        },
        support: {
          section_title: "\u{1F49D} Support et aide",
          resources: {
            name: "\u{1F4DA} Ressources",
            desc: "Documentation, notes de version et liens communautaires",
            documentation: "\u{1F4D6} Documentation",
            release_notes: "\u{1F4DD} Notes de version",
            issues: "\u{1F41B} Probl\xE8mes",
            forum: "\u{1F4AC} Forum"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "D\xE9marrage...",
          progress_label: "Progression : {{percentage}}%",
          step_label: "\xC9tape {{current}}/{{total}}",
          complete_label: "Termin\xE9",
          complete_message: "Termin\xE9 avec succ\xE8s",
          error_message: "Une erreur s'est produite"
        },
        multi_operation_modal: {
          progress_label: "Progression : {{completed}}/{{total}} op\xE9rations",
          progress_with_failures: "Progression : {{completed}}/{{total}} op\xE9rations ({{failed}} \xE9chou\xE9es)",
          all_completed: "Les {{total}} op\xE9rations ont \xE9t\xE9 effectu\xE9es avec succ\xE8s",
          mark_complete_default: "Toutes les op\xE9rations ont \xE9t\xE9 effectu\xE9es avec succ\xE8s",
          buttons: {
            complete: "Terminer",
            close: "Fermer"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migration requise",
            message: "Les t\xE2ches suivantes s'ex\xE9cuteront automatiquement pour mettre \xE0 niveau vos donn\xE9es vers la v1.3.0 :",
            tasks: {
              folder_settings: "\u2713 Migrer les param\xE8tres de dossiers vers la nouvelle structure",
              timestamps: "\u2713 Mettre \xE0 jour les horodatages au format ISO 8601",
              aliases: "\u2713 Corriger les alias du frontmatter",
              reports: "\u2713 D\xE9placer le dossier des rapports vers le bon emplacement",
              artifacts: "\u2713 Mettre \xE0 jour les m\xE9tadonn\xE9es des artefacts"
            },
            estimate: "Cela prendra quelques secondes."
          },
          buttons: {
            run_migration: "\u{1F680} Lancer les t\xE2ches de migration"
          }
        },
        complete_modal: {
          title: "\u2705 Mise \xE0 niveau termin\xE9e - v{{version}}",
          buttons: {
            got_it: "Compris !"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "Compris !"
          }
        }
      },
      folder_migration: {
        title: "D\xE9placer les fichiers existants ?",
        message_intro: "Vous modifiez l'emplacement du dossier {{folder_type}} :",
        path_from: "De : {{path}}",
        path_to: "Vers : {{path}}",
        question: "Voulez-vous d\xE9placer les fichiers existants vers le nouvel emplacement ?",
        link_updates: {
          title: "\u{1F517} Mises \xE0 jour des liens :",
          attachments_text: "D\xE9placer les pi\xE8ces jointes mettra \xE9galement \xE0 jour toutes les notes de conversation qui y font r\xE9f\xE9rence.",
          conversations_text: "D\xE9placer les conversations mettra \xE9galement \xE0 jour tous les rapports et pi\xE8ces jointes qui y font r\xE9f\xE9rence.",
          estimated_time_seconds: "Dur\xE9e estim\xE9e : ~{{seconds}} secondes",
          estimated_time_minutes: "Dur\xE9e estim\xE9e : ~{{minutes}} minute(s)"
        },
        warning: {
          title: "\u26A0\uFE0F Important :",
          text: "Si vous choisissez \xAB Non \xBB, les fichiers existants resteront \xE0 l'ancien emplacement et ne seront pas affect\xE9s par les futures mises \xE0 jour."
        },
        buttons: {
          cancel: "Annuler",
          keep: "Non, conserver les fichiers \xE0 l'ancien emplacement",
          move: "Oui, d\xE9placer les fichiers",
          move_with_links: "Oui, d\xE9placer les fichiers et mettre \xE0 jour les liens"
        },
        progress: {
          title_moving: "D\xE9placement de {{folder_type}} et mise \xE0 jour des liens",
          step_moving_title: "D\xE9placement des fichiers...",
          step_moving_detail: "D\xE9placement de {{old_path}} vers {{new_path}}",
          step_moving_count: "{{current}} / {{total}} fichiers trait\xE9s",
          step_moved_title: "Fichiers d\xE9plac\xE9s",
          step_moved_detail: "{{moved}} fichiers d\xE9plac\xE9s, {{skipped}} ignor\xE9s. Pr\xE9paration de la mise \xE0 jour des liens...",
          step_updating_attachment_links: "Mise \xE0 jour des liens des pi\xE8ces jointes...",
          step_updating_conversation_links: "Mise \xE0 jour des liens des conversations...",
          step_updating_report_links: "Mise \xE0 jour des liens dans les rapports...",
          step_updating_artifact_links: "Mise \xE0 jour des liens dans les artefacts...",
          complete_message: "{{moved}} fichiers d\xE9plac\xE9s. {{links}} liens mis \xE0 jour avec succ\xE8s"
        },
        result_dialog: {
          title: "R\xE9sultat de la migration des dossiers",
          summary_title: "R\xE9sum\xE9 de la migration",
          moved: "\u2705 D\xE9plac\xE9s avec succ\xE8s : {{count}} fichier(s)",
          skipped: "\u26A0\uFE0F Ignor\xE9s (existaient d\xE9j\xE0) : {{count}} fichier(s)",
          errors: "\u274C Erreurs : {{count}} fichier(s)",
          explanation: "Les fichiers qui existaient d\xE9j\xE0 dans la destination n'ont pas \xE9t\xE9 \xE9cras\xE9s afin de pr\xE9server vos donn\xE9es.",
          error_details_title: "D\xE9tails des erreurs :"
        },
        error_target_not_empty: {
          title: "Le dossier cible n'est pas vide",
          message: "Le dossier \xAB {{path}} \xBB contient d\xE9j\xE0 des fichiers.\n\nPour changer l'emplacement du dossier :\n\u2022 D\xE9placez les fichiers existants manuellement dans Obsidian, OU\n\u2022 Choisissez un dossier vide ou cr\xE9ez-en un nouveau"
        },
        error_migration_failed: {
          title: "\xC9chec de la migration",
          message_move: "\xC9chec du d\xE9placement des fichiers : {{error}}",
          message_links: "\xC9chec du d\xE9placement des fichiers ou de la mise \xE0 jour des liens : {{error}}"
        }
      },
      folder_browser: {
        title: "S\xE9lectionner un dossier",
        vault_root: "Racine du Vault (/)",
        buttons: {
          create_new_folder: "Cr\xE9er un nouveau dossier",
          cancel: "Annuler",
          select: "S\xE9lectionner"
        },
        create_folder_dialog: {
          title: "Cr\xE9er un nouveau dossier",
          folder_name_label: "Nom du dossier :",
          buttons: {
            cancel: "Annuler",
            create: "Cr\xE9er"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Veuillez d'abord s\xE9lectionner un dossier parent",
          invalid_name: "\u274C Nom de dossier invalide : contient des caract\xE8res ill\xE9gaux",
          already_exists: "\u274C Le dossier existe d\xE9j\xE0",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Dossier cr\xE9\xE9 : {{name}}",
          create_failed: "\u274C \xC9chec de la cr\xE9ation du dossier : {{error}}",
          select_first: "\u26A0\uFE0F Veuillez d'abord s\xE9lectionner un dossier"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "Dans la version 1.3.0, vous pouvez sp\xE9cifier un dossier pour les rapports. Nous d\xE9placerons les rapports existants vers {{folder}}, ou vous pouvez s\xE9lectionner votre dossier pr\xE9f\xE9r\xE9 ci-dessous.",
        note: "Remarque : Le dossier ne peut pas se trouver dans Conversations ou Attachments.",
        report_folder_label: "\u{1F4CA} Dossier des rapports",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Parcourir",
          proceed: "Proc\xE9der"
        },
        error_invalid_folder: {
          title: "Emplacement de dossier invalide",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Merci d'avoir install\xE9 Nexus AI Chat Importer !",
        description: "Importez et g\xE9rez vos conversations ChatGPT, Claude et Le Chat directement dans votre Vault Obsidian.",
        resources_title: "Ressources",
        resources: {
          documentation: {
            title: "Documentation",
            description: "Apprenez \xE0 utiliser le plugin"
          },
          release_notes: {
            title: "Notes de version",
            description: "Les nouveaut\xE9s de cette version"
          },
          report_issues: {
            title: "Signaler un probl\xE8me",
            description: "Vous avez trouv\xE9 un bug ? Faites-le nous savoir"
          },
          community_forum: {
            title: "Forum communautaire",
            description: "Rejoignez la discussion"
          }
        },
        buttons: {
          get_started: "Commencer"
        }
      },
      notices: {
        import_analyzing: "Analyse des conversations \xE0 partir de {{count}} fichier(s)...",
        import_no_new: "Aucune conversation nouvelle ou mise \xE0 jour. Toutes les conversations sont d\xE9j\xE0 \xE0 jour.",
        import_starting: "Importation de {{count}} conversations ({{new}} nouvelles, {{updated}} mises \xE0 jour)...",
        import_starting_selected: "Importation de {{count}} conversations s\xE9lectionn\xE9es \xE0 partir de {{files}} fichier(s)...",
        import_completed_fallback: "Importation termin\xE9e. {{created}} cr\xE9\xE9es, {{updated}} mises \xE0 jour.",
        import_error: "Erreur lors de l'importation : {{error}}",
        import_error_analyzing: "Erreur lors de l'analyse des conversations : {{error}}",
        import_error_file: "Erreur lors du traitement de {{filename}}. Consultez la console pour plus de d\xE9tails.",
        import_no_selected: "Aucune conversation s\xE9lectionn\xE9e pour l'importation.",
        import_no_zip_gemini: "Veuillez s\xE9lectionner au moins un fichier ZIP Gemini Takeout (plus un JSON optionnel depuis l'extension).",
        import_no_zip: "Veuillez s\xE9lectionner au moins un fichier ZIP d'export.",
        import_gemini_json_failed: "\xC9chec de la lecture du JSON d'index Gemini. Continuation sans index.",
        report_failed: "\xC9chec de la cr\xE9ation du fichier journal. Consultez la console pour plus de d\xE9tails.",
        attachment_map_failed: "\xC9chec de la construction de la carte des pi\xE8ces jointes. Consultez la console pour plus de d\xE9tails.",
        ribbon_tooltip: "Nexus AI Chat Importer - Importer un nouveau fichier"
      },
      commands: {
        import_conversations: {
          name: "Importer des conversations IA"
        }
      },
      support_box: {
        header: "Soutenir ce plugin",
        header_highlight: "Soutenir ce plugin",
        default_message_emphasis: "Je travaille \xE0 temps plein sur les projets Nexus tout en \xE9tant sans emploi et en faisant face \xE0 des probl\xE8mes de sant\xE9.",
        default_message: "Si ce plugin vous facilite la vie, un don repr\xE9senterait \xE9norm\xE9ment pour moi et m'aiderait \xE0 les maintenir en vie.",
        reality_check: "Merci ! Des milliers d'heures de travail ont \xE9t\xE9 investies dans ces plugins, et chaque don m'aide \xE0 continuer \xE0 les am\xE9liorer tout en g\xE9rant des probl\xE8mes de sant\xE9 persistants. Si ce plugin vous facilite la vie, pensez \xE0 me soutenir.",
        button_alt: "Soutenir mon travail"
      }
    };
  }
});

// src/i18n/locales/de.json
var de_default;
var init_de = __esm({
  "src/i18n/locales/de.json"() {
    de_default = {
      common: {
        buttons: {
          cancel: "Abbrechen",
          ok: "OK",
          select: "Ausw\xE4hlen",
          browse: "Durchsuchen",
          continue: "Weiter",
          proceed: "Fortfahren",
          close: "Verstanden!",
          create: "Erstellen",
          remove: "Entfernen",
          run: "Ausf\xFChren",
          complete: "Abschlie\xDFen",
          view_report: "Bericht anzeigen",
          get_started: "Loslegen",
          create_new_folder: "Neuen Ordner erstellen"
        },
        status: {
          new: "Neu",
          updated: "Aktualisiert",
          unchanged: "Unver\xE4ndert",
          unknown: "Unbekannt"
        },
        progress: {
          phase_validation: "\u{1F50D} Validierung",
          phase_scanning: "\u{1F4CB} Scannen",
          phase_processing: "\u2699\uFE0F Verarbeitung",
          phase_writing: "\u{1F4BE} Schreiben",
          phase_complete: "\u2705 Abgeschlossen",
          phase_error: "\u274C Fehler"
        }
      },
      provider_selection: {
        title: "Archiv-Anbieter ausw\xE4hlen",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "OpenAI ChatGPT Gespr\xE4chsexporte"
          },
          claude: {
            name: "Claude",
            description: "Anthropic Claude Gespr\xE4chsexporte"
          },
          lechat: {
            name: "Le Chat",
            description: "Mistral AI Le Chat Gespr\xE4chsexporte"
          }
        },
        buttons: {
          select: "Ausw\xE4hlen",
          cancel: "Abbrechen"
        }
      },
      file_selection: {
        title: "{{provider}}-Gespr\xE4che importieren",
        import_mode: {
          section_title: "Importmodus",
          all_label: "Alle importieren",
          all_description: "Alle Gespr\xE4che importieren (schneller)",
          selective_label: "Gezielt ausw\xE4hlen",
          selective_description: "Gespr\xE4che in der Vorschau anzeigen und ausw\xE4hlen"
        },
        file_area: {
          section_title: "Dateien ausw\xE4hlen",
          drop_text_default: "ZIP-Dateien hier ablegen oder zum Durchsuchen klicken",
          drop_text_gemini: "ZIP- und JSON-Dateien hier ablegen oder zum Durchsuchen klicken",
          drop_subtext_default: "Unterst\xFCtzt Mehrfachauswahl von Dateien",
          drop_subtext_gemini: "ZIP (Takeout) + optionales JSON (Index aus der Erweiterung)"
        },
        selected_files: {
          section_title: "Ausgew\xE4hlte Dateien",
          remove_button: "Entfernen"
        },
        buttons: {
          cancel: "Abbrechen",
          continue: "Weiter"
        }
      },
      conversation_selection: {
        title: "Zu importierende Gespr\xE4che ausw\xE4hlen",
        controls: {
          select_all: "Alle ausw\xE4hlen",
          select_none: "Keine ausw\xE4hlen",
          search_placeholder: "Gespr\xE4che suchen...",
          status_label: "Status:",
          show_label: "Anzeigen:"
        },
        status_filter_options: {
          all: "Alle",
          new: "Neu",
          updated: "Aktualisiert",
          unchanged: "Unver\xE4ndert"
        },
        table_headers: {
          title: "Titel",
          created: "Erstellt",
          updated: "Aktualisiert",
          messages: "Nachrichten",
          status: "Status"
        },
        status_badges: {
          new: "Neu",
          updated: "Aktualisiert",
          unchanged: "Unver\xE4ndert",
          unknown: "Unbekannt",
          tooltip_new: "Dieses Gespr\xE4ch ist nicht in Ihrem Vault",
          tooltip_updated: "Dieses Gespr\xE4ch hat neuere Inhalte als Ihr Vault ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "Dieses Gespr\xE4ch ist identisch mit dem in Ihrem Vault"
        },
        pagination: {
          showing: "{{start}}\u2013{{end}} von {{total}} Gespr\xE4chen werden angezeigt",
          page_of: "Seite {{current}} von {{total}}",
          previous: "Zur\xFCck",
          next: "Weiter"
        },
        summary: {
          unique_conversations: "Eindeutige Gespr\xE4che",
          new: "Neu",
          updated: "Aktualisiert",
          unchanged: "Unver\xE4ndert",
          selected_of: "{{selected}} von {{total}} ausgew\xE4hlt"
        },
        buttons: {
          cancel: "Abbrechen",
          import_selected: "Auswahl importieren",
          import_selected_count: "{{count}} Ausgew\xE4hlte importieren"
        },
        date_unknown: "Unbekannt"
      },
      import_progress: {
        title: "{{filename}} wird importiert",
        initial: {
          title: "Import wird vorbereitet...",
          detail: "ZIP-Dateistruktur wird validiert"
        },
        conversation_counter: "{{current}}/{{total}} Gespr\xE4che",
        conversation_counter_selective: "{{current}}/{{total}} ausgew\xE4hlte Gespr\xE4che",
        selective_mode_indicator: "\u{1F4CB} Selektiver Import: {{selected}} von {{total}} Gespr\xE4chen",
        complete: {
          message: "Import erfolgreich abgeschlossen",
          detail: "Sie k\xF6nnen dieses Fenster schlie\xDFen"
        },
        error: {
          message: "Beim Import ist ein Fehler aufgetreten",
          detail: "Weitere Details finden Sie in der Konsole"
        }
      },
      import_completion: {
        title: "Import abgeschlossen",
        success_message: "\u2705 Gespr\xE4che erfolgreich importiert",
        stats: {
          zip_files_processed: "Verarbeitete ZIP-Dateien",
          unique_conversations: "Eindeutige Gespr\xE4che",
          duplicates: "Duplikate",
          new: "Neu",
          updated: "Aktualisiert",
          skipped: "\xDCbersprungen",
          failed: "Fehlgeschlagen"
        },
        attachments: {
          label: "Anh\xE4nge:",
          summary: "{{found}}/{{total}} extrahiert ({{percentage}}%)",
          missing_failed: "{{missing}} fehlend, {{failed}} fehlgeschlagen"
        },
        report: {
          label: "\u{1F4C4} Detaillierter Bericht:"
        },
        buttons: {
          view_report: "Bericht anzeigen",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Ordnerstruktur",
          conversation_folder: {
            name: "Gespr\xE4chsordner",
            desc: "Speicherort f\xFCr importierte Gespr\xE4che",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Ordner durchsuchen oder neuen erstellen"
          },
          reports_folder: {
            name: "Berichtsordner",
            desc: "Speicherort f\xFCr Importberichte",
            placeholder: "Nexus Reports",
            browse_tooltip: "Ordner durchsuchen oder neuen erstellen"
          },
          attachment_folder: {
            name: "Anhangsordner",
            desc: "Speicherort f\xFCr Anh\xE4nge (\u26A0\uFE0F Von der Synchronisierung ausschlie\xDFen, um Speicherplatz zu sparen)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Ordner durchsuchen oder neuen erstellen"
          }
        },
        display: {
          section_title: "\u{1F4C5} Datumspr\xE4fix",
          add_date_prefix: {
            name: "Datumspr\xE4fix zu Dateinamen hinzuf\xFCgen",
            desc: "Das Erstellungsdatum als Pr\xE4fix zu Gespr\xE4chsdateinamen hinzuf\xFCgen",
            format_label: "Datumsformat ausw\xE4hlen: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Nachrichtendatumsformat",
          custom_format: {
            name: "Benutzerdefiniertes Zeitstempelformat f\xFCr Nachrichten",
            desc: "Das standardm\xE4\xDFige gebietsschemabasierte Zeitstempelformat in Nachrichtenkopfzeilen \xFCberschreiben. Wenn deaktiviert, folgen Zeitstempel der Spracheinstellung von Obsidian. Wenn Obsidian auf Englisch eingestellt ist, wird das US-Format (YYYY/DD/MM) erzwungen."
          },
          timestamp_format: {
            name: "Zeitstempelformat",
            desc: "Das Format f\xFCr Nachrichtenzeitstempel in Gespr\xE4chsnotizen w\xE4hlen"
          },
          preview_label: "Vorschau: "
        },
        attachments: {
          section_title: "Anhangseinstellungen",
          import_attachments: {
            name: "Anh\xE4nge importieren",
            desc: 'Anhangsdateien auf dem Datentr\xE4ger speichern und in Gespr\xE4chen verlinken (verwendet eine "Best-Effort"-Strategie)'
          },
          handle_missing: {
            name: "Fehlende Anh\xE4nge behandeln",
            desc: "Wenn Anh\xE4nge in Exporten fehlen, informative Notizen erstellen statt sie zu \xFCberspringen"
          },
          show_details: {
            name: "Anhangsdetails in Berichten anzeigen",
            desc: "Detaillierte Statistiken zur Anhangsverarbeitung in Importberichte aufnehmen"
          },
          info_box: {
            title: "\u{1F4CE} \xDCber die Anhangsverarbeitung",
            best_effort: "Best-Effort-Strategie: In Exporten gefundene Dateien werden extrahiert und verlinkt; fehlende Dateien erhalten informative Notizen.",
            platform_diff: "Plattformunterschiede: ChatGPT-Exporte enthalten m\xF6glicherweise nicht alle Anh\xE4nge, insbesondere aus \xE4lteren Gespr\xE4chen.",
            organization: "Einfache Organisation: Dateien werden unter attachments/Anbieter/Kategorie/ organisiert (z. B. attachments/chatgpt/images/).",
            sync_tip: "Synchronisierungshinweis: Erw\xE4gen Sie, den Anhangsordner von der Synchronisierung auszuschlie\xDFen, um das Hochladen gro\xDFer Dateien zu vermeiden.",
            tip: "\u{1F4A1} Tipp: Aktivieren Sie \u201EAnhangsdetails anzeigen\u201C, um genau zu sehen, welche Dateien beim Import gefunden, fehlend oder fehlgeschlagen waren."
          }
        },
        migrations: {
          section_title: "Migrationen",
          description_manual: "Manuelle Vorg\xE4nge: Optionale Upgrade-Vorg\xE4nge, die bei Bedarf ausgef\xFChrt werden k\xF6nnen.",
          description_automatic: "Automatische Vorg\xE4nge (wie das Entfernen alter Daten) werden beim Upgrade automatisch ausgef\xFChrt und sind hier nicht aufgef\xFChrt.",
          version_header: "Version {{version}}",
          no_migrations: {
            title: "Keine manuellen Vorg\xE4nge verf\xFCgbar",
            desc: "Alle Upgrade-Vorg\xE4nge wurden automatisch abgeschlossen."
          },
          operation_completed_suffix: " \u2705 Abgeschlossen",
          buttons: {
            completed: "\u2705 Abgeschlossen",
            cannot_run: "Kann nicht ausgef\xFChrt werden",
            run: "Ausf\xFChren",
            running: "Wird ausgef\xFChrt..."
          },
          tooltips: {
            completed: "Dieser Vorgang wurde abgeschlossen",
            cannot_run: "Voraussetzungen f\xFCr diesen Vorgang nicht erf\xFCllt",
            run: "{{operation_name}} ausf\xFChren"
          },
          error_loading: "Fehler beim Laden der Migrationen:"
        },
        support: {
          section_title: "\u{1F49D} Support & Hilfe",
          resources: {
            name: "\u{1F4DA} Ressourcen",
            desc: "Dokumentation, Versionshinweise und Community-Links",
            documentation: "\u{1F4D6} Dokumentation",
            release_notes: "\u{1F4DD} Versionshinweise",
            issues: "\u{1F41B} Fehler melden",
            forum: "\u{1F4AC} Forum"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "Wird gestartet...",
          progress_label: "Fortschritt: {{percentage}}%",
          step_label: "Schritt {{current}}/{{total}}",
          complete_label: "Abgeschlossen",
          complete_message: "Erfolgreich abgeschlossen",
          error_message: "Ein Fehler ist aufgetreten"
        },
        multi_operation_modal: {
          progress_label: "Fortschritt: {{completed}}/{{total}} Vorg\xE4nge",
          progress_with_failures: "Fortschritt: {{completed}}/{{total}} Vorg\xE4nge ({{failed}} fehlgeschlagen)",
          all_completed: "Alle {{total}} Vorg\xE4nge erfolgreich abgeschlossen",
          mark_complete_default: "Alle Vorg\xE4nge erfolgreich abgeschlossen",
          buttons: {
            complete: "Abschlie\xDFen",
            close: "Schlie\xDFen"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migration erforderlich",
            message: "Die folgenden Aufgaben werden automatisch ausgef\xFChrt, um Ihre Daten auf v1.3.0 zu aktualisieren:",
            tasks: {
              folder_settings: "\u2713 Ordnereinstellungen zur neuen Struktur migrieren",
              timestamps: "\u2713 Zeitstempel auf ISO 8601-Format aktualisieren",
              aliases: "\u2713 Frontmatter-Aliase korrigieren",
              reports: "\u2713 Berichtsordner an den richtigen Speicherort verschieben",
              artifacts: "\u2713 Artefakt-Metadaten aktualisieren"
            },
            estimate: "Dies dauert einige Sekunden."
          },
          buttons: {
            run_migration: "\u{1F680} Migrationsaufgaben starten"
          }
        },
        complete_modal: {
          title: "\u2705 Upgrade abgeschlossen \u2013 v{{version}}",
          buttons: {
            got_it: "Verstanden!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "Verstanden!"
          }
        }
      },
      folder_migration: {
        title: "Vorhandene Dateien verschieben?",
        message_intro: "Sie \xE4ndern den Speicherort des Ordners {{folder_type}}:",
        path_from: "Von: {{path}}",
        path_to: "Nach: {{path}}",
        question: "M\xF6chten Sie vorhandene Dateien an den neuen Speicherort verschieben?",
        link_updates: {
          title: "\u{1F517} Link-Aktualisierungen:",
          attachments_text: "Das Verschieben von Anh\xE4ngen aktualisiert auch alle Gespr\xE4chsnotizen, die auf sie verweisen.",
          conversations_text: "Das Verschieben von Gespr\xE4chen aktualisiert auch alle Berichte und Anh\xE4nge, die auf sie verweisen.",
          estimated_time_seconds: "Gesch\xE4tzte Zeit: ~{{seconds}} Sekunden",
          estimated_time_minutes: "Gesch\xE4tzte Zeit: ~{{minutes}} Minute(n)"
        },
        warning: {
          title: "\u26A0\uFE0F Wichtig:",
          text: "Wenn Sie \u201ENein\u201C w\xE4hlen, verbleiben vorhandene Dateien am alten Speicherort und werden von zuk\xFCnftigen Updates nicht beeinflusst."
        },
        buttons: {
          cancel: "Abbrechen",
          keep: "Nein, Dateien am alten Speicherort behalten",
          move: "Ja, Dateien verschieben",
          move_with_links: "Ja, Dateien verschieben und Links aktualisieren"
        },
        progress: {
          title_moving: "{{folder_type}} wird verschoben und Links werden aktualisiert",
          step_moving_title: "Dateien werden verschoben...",
          step_moving_detail: "Verschieben von {{old_path}} nach {{new_path}}",
          step_moving_count: "{{current}} / {{total}} Dateien verarbeitet",
          step_moved_title: "Dateien verschoben",
          step_moved_detail: "{{moved}} Dateien verschoben, {{skipped}} \xFCbersprungen. Links werden vorbereitet...",
          step_updating_attachment_links: "Anhangs-Links werden aktualisiert...",
          step_updating_conversation_links: "Gespr\xE4chs-Links werden aktualisiert...",
          step_updating_report_links: "Links in Berichten werden aktualisiert...",
          step_updating_artifact_links: "Links in Artefakten werden aktualisiert...",
          complete_message: "{{moved}} Dateien verschoben. {{links}} Links erfolgreich aktualisiert"
        },
        result_dialog: {
          title: "Ergebnis der Ordnermigration",
          summary_title: "Migrationszusammenfassung",
          moved: "\u2705 Erfolgreich verschoben: {{count}} Datei(en)",
          skipped: "\u26A0\uFE0F \xDCbersprungen (bereits vorhanden): {{count}} Datei(en)",
          errors: "\u274C Fehler: {{count}} Datei(en)",
          explanation: "Dateien, die am Zielort bereits vorhanden waren, wurden zum Schutz Ihrer Daten nicht \xFCberschrieben.",
          error_details_title: "Fehlerdetails:"
        },
        error_target_not_empty: {
          title: "Zielordner ist nicht leer",
          message: "Der Ordner \u201E{{path}}\u201C enth\xE4lt bereits Dateien.\n\nUm den Ordnerspeicherort zu \xE4ndern:\n\u2022 Vorhandene Dateien manuell in Obsidian verschieben, ODER\n\u2022 Einen leeren Ordner w\xE4hlen oder einen neuen erstellen"
        },
        error_migration_failed: {
          title: "Migration fehlgeschlagen",
          message_move: "Dateien konnten nicht verschoben werden: {{error}}",
          message_links: "Dateien konnten nicht verschoben oder Links nicht aktualisiert werden: {{error}}"
        }
      },
      folder_browser: {
        title: "Ordner ausw\xE4hlen",
        vault_root: "Vault-Wurzel (/)",
        buttons: {
          create_new_folder: "Neuen Ordner erstellen",
          cancel: "Abbrechen",
          select: "Ausw\xE4hlen"
        },
        create_folder_dialog: {
          title: "Neuen Ordner erstellen",
          folder_name_label: "Ordnername:",
          buttons: {
            cancel: "Abbrechen",
            create: "Erstellen"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Bitte zuerst einen \xFCbergeordneten Ordner ausw\xE4hlen",
          invalid_name: "\u274C Ung\xFCltiger Ordnername: enth\xE4lt unerlaubte Zeichen",
          already_exists: "\u274C Ordner existiert bereits",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Ordner erstellt: {{name}}",
          create_failed: "\u274C Ordner konnte nicht erstellt werden: {{error}}",
          select_first: "\u26A0\uFE0F Bitte zuerst einen Ordner ausw\xE4hlen"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "In Version 1.3.0 k\xF6nnen Sie einen Ordner f\xFCr Berichte angeben. Vorhandene Berichte werden nach {{folder}} verschoben, oder Sie k\xF6nnen unten Ihren bevorzugten Ordner ausw\xE4hlen.",
        note: "Hinweis: Der Ordner darf sich nicht innerhalb von Conversations oder Attachments befinden.",
        report_folder_label: "\u{1F4CA} Berichtsordner",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Durchsuchen",
          proceed: "Fortfahren"
        },
        error_invalid_folder: {
          title: "Ung\xFCltiger Ordnerspeicherort",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Danke, dass Sie Nexus AI Chat Importer installiert haben!",
        description: "Importieren und verwalten Sie Ihre ChatGPT-, Claude- und Le Chat-Gespr\xE4che direkt in Ihrem Obsidian-Vault.",
        resources_title: "Ressourcen",
        resources: {
          documentation: {
            title: "Dokumentation",
            description: "Erfahren Sie, wie Sie das Plugin verwenden"
          },
          release_notes: {
            title: "Versionshinweise",
            description: "Neuigkeiten in dieser Version"
          },
          report_issues: {
            title: "Fehler melden",
            description: "Einen Fehler gefunden? Teilen Sie es uns mit"
          },
          community_forum: {
            title: "Community-Forum",
            description: "An der Diskussion teilnehmen"
          }
        },
        buttons: {
          get_started: "Loslegen"
        }
      },
      notices: {
        import_analyzing: "Gespr\xE4che aus {{count}} Datei(en) werden analysiert...",
        import_no_new: "Keine neuen oder aktualisierten Gespr\xE4che gefunden. Alle Gespr\xE4che sind bereits aktuell.",
        import_starting: "{{count}} Gespr\xE4che werden importiert ({{new}} neu, {{updated}} aktualisiert)...",
        import_starting_selected: "{{count}} ausgew\xE4hlte Gespr\xE4che aus {{files}} Datei(en) werden importiert...",
        import_completed_fallback: "Import abgeschlossen. {{created}} erstellt, {{updated}} aktualisiert.",
        import_error: "Fehler beim Import: {{error}}",
        import_error_analyzing: "Fehler beim Analysieren der Gespr\xE4che: {{error}}",
        import_error_file: "Fehler beim Verarbeiten von {{filename}}. Weitere Details in der Konsole.",
        import_no_selected: "Keine Gespr\xE4che f\xFCr den Import ausgew\xE4hlt.",
        import_no_zip_gemini: "Bitte w\xE4hlen Sie mindestens eine Gemini Takeout ZIP-Datei (plus optionalem JSON-Index aus der Erweiterung).",
        import_no_zip: "Bitte w\xE4hlen Sie mindestens eine ZIP-Exportdatei.",
        import_gemini_json_failed: "Gemini-Index JSON konnte nicht gelesen werden. Fortfahren ohne Index.",
        report_failed: "Protokolldatei konnte nicht erstellt werden. Weitere Details in der Konsole.",
        attachment_map_failed: "Anhangskarte konnte nicht erstellt werden. Weitere Details in der Konsole.",
        ribbon_tooltip: "Nexus AI Chat Importer - Neue Datei importieren"
      },
      commands: {
        import_conversations: {
          name: "KI-Gespr\xE4che importieren"
        }
      },
      support_box: {
        header: "Dieses Plugin unterst\xFCtzen",
        header_highlight: "Dieses Plugin unterst\xFCtzen",
        default_message_emphasis: "Ich arbeite Vollzeit an Nexus-Projekten, bin arbeitslos und k\xE4mpfe mit gesundheitlichen Problemen.",
        default_message: "Wenn dieses Plugin Ihr Leben leichter macht, w\xFCrde mir eine Spende sehr viel bedeuten und dazu beitragen, die Projekte am Leben zu erhalten.",
        reality_check: "Danke! Tausende Stunden Arbeit stecken in diesen Plugins, und jede Spende hilft mir, sie weiterzuentwickeln, w\xE4hrend ich mit anhaltenden gesundheitlichen Problemen umgehe. Wenn dieses Plugin Ihr Leben leichter macht, erw\xE4gen Sie bitte, mich zu unterst\xFCtzen.",
        button_alt: "Meine Arbeit unterst\xFCtzen"
      }
    };
  }
});

// src/i18n/locales/es.json
var es_default;
var init_es = __esm({
  "src/i18n/locales/es.json"() {
    es_default = {
      common: {
        buttons: {
          cancel: "Cancelar",
          ok: "OK",
          select: "Seleccionar",
          browse: "Explorar",
          continue: "Continuar",
          proceed: "Proceder",
          close: "\xA1Entendido!",
          create: "Crear",
          remove: "Eliminar",
          run: "Ejecutar",
          complete: "Finalizar",
          view_report: "Ver informe",
          get_started: "Comenzar",
          create_new_folder: "Crear nueva carpeta"
        },
        status: {
          new: "Nuevo",
          updated: "Actualizado",
          unchanged: "Sin cambios",
          unknown: "Desconocido"
        },
        progress: {
          phase_validation: "\u{1F50D} Validaci\xF3n",
          phase_scanning: "\u{1F4CB} Escaneo",
          phase_processing: "\u2699\uFE0F Procesando",
          phase_writing: "\u{1F4BE} Escribiendo",
          phase_complete: "\u2705 Completado",
          phase_error: "\u274C Error"
        }
      },
      provider_selection: {
        title: "Seleccionar proveedor de archivo",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "Exportaciones de conversaciones OpenAI ChatGPT"
          },
          claude: {
            name: "Claude",
            description: "Exportaciones de conversaciones Anthropic Claude"
          },
          lechat: {
            name: "Le Chat",
            description: "Exportaciones de conversaciones Mistral AI Le Chat"
          }
        },
        buttons: {
          select: "Seleccionar",
          cancel: "Cancelar"
        }
      },
      file_selection: {
        title: "Importar conversaciones de {{provider}}",
        import_mode: {
          section_title: "Modo de importaci\xF3n",
          all_label: "Importar todo",
          all_description: "Importar todas las conversaciones (m\xE1s r\xE1pido)",
          selective_label: "Selecci\xF3n espec\xEDfica",
          selective_description: "Vista previa y selecci\xF3n de conversaciones"
        },
        file_area: {
          section_title: "Seleccionar archivos",
          drop_text_default: "Suelte archivos ZIP aqu\xED o haga clic para explorar",
          drop_text_gemini: "Suelte archivos ZIP y JSON aqu\xED o haga clic para explorar",
          drop_subtext_default: "Admite selecci\xF3n m\xFAltiple de archivos",
          drop_subtext_gemini: "ZIP (Takeout) + JSON opcional (\xEDndice desde la extensi\xF3n)"
        },
        selected_files: {
          section_title: "Archivos seleccionados",
          remove_button: "Eliminar"
        },
        buttons: {
          cancel: "Cancelar",
          continue: "Continuar"
        }
      },
      conversation_selection: {
        title: "Seleccionar conversaciones para importar",
        controls: {
          select_all: "Seleccionar todo",
          select_none: "Deseleccionar todo",
          search_placeholder: "Buscar conversaciones...",
          status_label: "Estado:",
          show_label: "Mostrar:"
        },
        status_filter_options: {
          all: "Todos",
          new: "Nuevo",
          updated: "Actualizado",
          unchanged: "Sin cambios"
        },
        table_headers: {
          title: "T\xEDtulo",
          created: "Creado",
          updated: "Actualizado",
          messages: "Mensajes",
          status: "Estado"
        },
        status_badges: {
          new: "Nuevo",
          updated: "Actualizado",
          unchanged: "Sin cambios",
          unknown: "Desconocido",
          tooltip_new: "Esta conversaci\xF3n no est\xE1 en su Vault",
          tooltip_updated: "Esta conversaci\xF3n tiene contenido m\xE1s reciente que su Vault ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "Esta conversaci\xF3n es igual a la de su Vault"
        },
        pagination: {
          showing: "Mostrando {{start}}-{{end}} de {{total}} conversaciones",
          page_of: "P\xE1gina {{current}} de {{total}}",
          previous: "Anterior",
          next: "Siguiente"
        },
        summary: {
          unique_conversations: "Conversaciones \xFAnicas",
          new: "Nuevo",
          updated: "Actualizado",
          unchanged: "Sin cambios",
          selected_of: "{{selected}} de {{total}} seleccionadas"
        },
        buttons: {
          cancel: "Cancelar",
          import_selected: "Importar selecci\xF3n",
          import_selected_count: "Importar {{count}} seleccionadas"
        },
        date_unknown: "Desconocido"
      },
      import_progress: {
        title: "Importando {{filename}}",
        initial: {
          title: "Preparando la importaci\xF3n...",
          detail: "Validando la estructura del archivo ZIP"
        },
        conversation_counter: "{{current}}/{{total}} conversaciones",
        conversation_counter_selective: "{{current}}/{{total}} conversaciones seleccionadas",
        selective_mode_indicator: "\u{1F4CB} Importaci\xF3n selectiva: {{selected}} de {{total}} conversaciones",
        complete: {
          message: "Importaci\xF3n completada con \xE9xito",
          detail: "Puede cerrar este cuadro de di\xE1logo"
        },
        error: {
          message: "Se produjo un error durante la importaci\xF3n",
          detail: "Consulte la consola para m\xE1s detalles"
        }
      },
      import_completion: {
        title: "Importaci\xF3n completada",
        success_message: "\u2705 Conversaciones importadas con \xE9xito",
        stats: {
          zip_files_processed: "Archivos ZIP procesados",
          unique_conversations: "Conversaciones \xFAnicas",
          duplicates: "Duplicados",
          new: "Nuevo",
          updated: "Actualizado",
          skipped: "Omitidos",
          failed: "Fallidos"
        },
        attachments: {
          label: "Adjuntos:",
          summary: "{{found}}/{{total}} extra\xEDdos ({{percentage}}%)",
          missing_failed: "{{missing}} faltantes, {{failed}} fallidos"
        },
        report: {
          label: "\u{1F4C4} Informe detallado:"
        },
        buttons: {
          view_report: "Ver informe",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Estructura de carpetas",
          conversation_folder: {
            name: "Carpeta de conversaciones",
            desc: "D\xF3nde se almacenan las conversaciones importadas",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Explorar carpetas o crear una nueva"
          },
          reports_folder: {
            name: "Carpeta de informes",
            desc: "D\xF3nde se almacenan los informes de importaci\xF3n",
            placeholder: "Nexus Reports",
            browse_tooltip: "Explorar carpetas o crear una nueva"
          },
          attachment_folder: {
            name: "Carpeta de adjuntos",
            desc: "D\xF3nde se almacenan los adjuntos (\u26A0\uFE0F Excluir de la sincronizaci\xF3n para ahorrar espacio)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Explorar carpetas o crear una nueva"
          }
        },
        display: {
          section_title: "\u{1F4C5} Prefijo de fecha",
          add_date_prefix: {
            name: "A\xF1adir prefijo de fecha a los nombres de archivo",
            desc: "A\xF1adir la fecha de creaci\xF3n como prefijo a los nombres de archivo de conversaci\xF3n",
            format_label: "Seleccionar formato de fecha: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Formato de fecha de mensajes",
          custom_format: {
            name: "Formato de marca de tiempo personalizado para mensajes",
            desc: "Reemplazar el formato de marca de tiempo predeterminado basado en la configuraci\xF3n regional en los encabezados de mensajes. Cuando est\xE1 desactivado, las marcas de tiempo siguen la configuraci\xF3n de idioma de Obsidian. Si Obsidian est\xE1 en ingl\xE9s, se aplica el formato estadounidense (YYYY/DD/MM)."
          },
          timestamp_format: {
            name: "Formato de marca de tiempo",
            desc: "Elegir el formato para las marcas de tiempo de mensajes en las notas de conversaci\xF3n"
          },
          preview_label: "Vista previa: "
        },
        attachments: {
          section_title: "Configuraci\xF3n de adjuntos",
          import_attachments: {
            name: "Importar adjuntos",
            desc: "Guardar archivos adjuntos en disco y vincularlos en las conversaciones (utiliza una estrategia de \xABmejor esfuerzo\xBB)"
          },
          handle_missing: {
            name: "Gestionar adjuntos faltantes",
            desc: "Cuando faltan adjuntos en las exportaciones, crear notas informativas en lugar de omitirlos"
          },
          show_details: {
            name: "Mostrar detalles de adjuntos en informes",
            desc: "Incluir estad\xEDsticas detalladas del procesamiento de adjuntos en los informes de importaci\xF3n"
          },
          info_box: {
            title: "\u{1F4CE} Acerca del manejo de adjuntos",
            best_effort: "Estrategia de mejor esfuerzo: Los archivos encontrados en las exportaciones se extraen y vinculan; los archivos faltantes reciben notas informativas.",
            platform_diff: "Diferencias entre plataformas: Las exportaciones de ChatGPT pueden no incluir todos los adjuntos, especialmente de conversaciones m\xE1s antiguas.",
            organization: "Organizaci\xF3n sencilla: Los archivos se organizan en attachments/proveedor/categor\xEDa/ (p. ej., attachments/chatgpt/images/).",
            sync_tip: "Consejo de sincronizaci\xF3n: Considere excluir la carpeta de adjuntos de la sincronizaci\xF3n para evitar subir archivos grandes.",
            tip: "\u{1F4A1} Consejo: Active \xABMostrar detalles de adjuntos\xBB para ver exactamente qu\xE9 archivos se encontraron, faltaron o fallaron durante la importaci\xF3n."
          }
        },
        migrations: {
          section_title: "Migraciones",
          description_manual: "Operaciones manuales: Operaciones de actualizaci\xF3n opcionales que se pueden ejecutar cuando sea conveniente.",
          description_automatic: "Las operaciones autom\xE1ticas (como eliminar datos antiguos) se ejecutan autom\xE1ticamente durante la actualizaci\xF3n y no se muestran aqu\xED.",
          version_header: "Versi\xF3n {{version}}",
          no_migrations: {
            title: "No hay operaciones manuales disponibles",
            desc: "Todas las operaciones de actualizaci\xF3n se han completado autom\xE1ticamente."
          },
          operation_completed_suffix: " \u2705 Completado",
          buttons: {
            completed: "\u2705 Completado",
            cannot_run: "No se puede ejecutar",
            run: "Ejecutar",
            running: "Ejecutando..."
          },
          tooltips: {
            completed: "Esta operaci\xF3n ha sido completada",
            cannot_run: "Los requisitos previos no se cumplen para esta operaci\xF3n",
            run: "Ejecutar {{operation_name}}"
          },
          error_loading: "Error al cargar las migraciones:"
        },
        support: {
          section_title: "\u{1F49D} Soporte y ayuda",
          resources: {
            name: "\u{1F4DA} Recursos",
            desc: "Documentaci\xF3n, notas de versi\xF3n y enlaces de la comunidad",
            documentation: "\u{1F4D6} Documentaci\xF3n",
            release_notes: "\u{1F4DD} Notas de versi\xF3n",
            issues: "\u{1F41B} Problemas",
            forum: "\u{1F4AC} Foro"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "Iniciando...",
          progress_label: "Progreso: {{percentage}}%",
          step_label: "Paso {{current}}/{{total}}",
          complete_label: "Completado",
          complete_message: "Completado con \xE9xito",
          error_message: "Se produjo un error"
        },
        multi_operation_modal: {
          progress_label: "Progreso: {{completed}}/{{total}} operaciones",
          progress_with_failures: "Progreso: {{completed}}/{{total}} operaciones ({{failed}} fallidas)",
          all_completed: "Las {{total}} operaciones se completaron con \xE9xito",
          mark_complete_default: "Todas las operaciones se completaron con \xE9xito",
          buttons: {
            complete: "Finalizar",
            close: "Cerrar"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migraci\xF3n requerida",
            message: "Las siguientes tareas se ejecutar\xE1n autom\xE1ticamente para actualizar sus datos a v1.3.0:",
            tasks: {
              folder_settings: "\u2713 Migrar la configuraci\xF3n de carpetas a la nueva estructura",
              timestamps: "\u2713 Actualizar marcas de tiempo al formato ISO 8601",
              aliases: "\u2713 Corregir alias del frontmatter",
              reports: "\u2713 Mover la carpeta de informes a la ubicaci\xF3n correcta",
              artifacts: "\u2713 Actualizar metadatos de artefactos"
            },
            estimate: "Esto tomar\xE1 unos segundos."
          },
          buttons: {
            run_migration: "\u{1F680} Ejecutar tareas de migraci\xF3n"
          }
        },
        complete_modal: {
          title: "\u2705 Actualizaci\xF3n completada - v{{version}}",
          buttons: {
            got_it: "\xA1Entendido!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "\xA1Entendido!"
          }
        }
      },
      folder_migration: {
        title: "\xBFMover archivos existentes?",
        message_intro: "Est\xE1 cambiando la ubicaci\xF3n de la carpeta {{folder_type}}:",
        path_from: "Desde: {{path}}",
        path_to: "Hacia: {{path}}",
        question: "\xBFDesea mover los archivos existentes a la nueva ubicaci\xF3n?",
        link_updates: {
          title: "\u{1F517} Actualizaciones de enlaces:",
          attachments_text: "Mover los adjuntos tambi\xE9n actualizar\xE1 todas las notas de conversaci\xF3n que hagan referencia a ellos.",
          conversations_text: "Mover las conversaciones tambi\xE9n actualizar\xE1 todos los informes y adjuntos que hagan referencia a ellas.",
          estimated_time_seconds: "Tiempo estimado: ~{{seconds}} segundos",
          estimated_time_minutes: "Tiempo estimado: ~{{minutes}} minuto(s)"
        },
        warning: {
          title: "\u26A0\uFE0F Importante:",
          text: "Si elige \xABNo\xBB, los archivos existentes permanecer\xE1n en la ubicaci\xF3n anterior y no ser\xE1n afectados por futuras actualizaciones."
        },
        buttons: {
          cancel: "Cancelar",
          keep: "No, conservar los archivos en la ubicaci\xF3n anterior",
          move: "S\xED, mover los archivos",
          move_with_links: "S\xED, mover los archivos y actualizar enlaces"
        },
        progress: {
          title_moving: "Moviendo {{folder_type}} y actualizando enlaces",
          step_moving_title: "Moviendo archivos...",
          step_moving_detail: "Moviendo de {{old_path}} a {{new_path}}",
          step_moving_count: "{{current}} / {{total}} archivos procesados",
          step_moved_title: "Archivos movidos",
          step_moved_detail: "{{moved}} archivos movidos, {{skipped}} omitidos. Preparando actualizaci\xF3n de enlaces...",
          step_updating_attachment_links: "Actualizando enlaces de adjuntos...",
          step_updating_conversation_links: "Actualizando enlaces de conversaciones...",
          step_updating_report_links: "Actualizando enlaces en informes...",
          step_updating_artifact_links: "Actualizando enlaces en artefactos...",
          complete_message: "{{moved}} archivos movidos. {{links}} enlaces actualizados con \xE9xito"
        },
        result_dialog: {
          title: "Resultado de la migraci\xF3n de carpetas",
          summary_title: "Resumen de la migraci\xF3n",
          moved: "\u2705 Movidos con \xE9xito: {{count}} archivo(s)",
          skipped: "\u26A0\uFE0F Omitidos (ya exist\xEDan): {{count}} archivo(s)",
          errors: "\u274C Errores: {{count}} archivo(s)",
          explanation: "Los archivos que ya exist\xEDan en el destino no fueron sobrescritos para preservar sus datos.",
          error_details_title: "Detalles del error:"
        },
        error_target_not_empty: {
          title: "La carpeta de destino no est\xE1 vac\xEDa",
          message: "La carpeta \xAB{{path}}\xBB ya contiene archivos.\n\nPara cambiar la ubicaci\xF3n de la carpeta:\n\u2022 Mueva los archivos existentes manualmente en Obsidian, O\n\u2022 Elija una carpeta vac\xEDa o cree una nueva"
        },
        error_migration_failed: {
          title: "La migraci\xF3n ha fallado",
          message_move: "Error al mover archivos: {{error}}",
          message_links: "Error al mover archivos o actualizar enlaces: {{error}}"
        }
      },
      folder_browser: {
        title: "Seleccionar carpeta",
        vault_root: "Ra\xEDz del Vault (/)",
        buttons: {
          create_new_folder: "Crear nueva carpeta",
          cancel: "Cancelar",
          select: "Seleccionar"
        },
        create_folder_dialog: {
          title: "Crear nueva carpeta",
          folder_name_label: "Nombre de la carpeta:",
          buttons: {
            cancel: "Cancelar",
            create: "Crear"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Por favor, seleccione primero una carpeta principal",
          invalid_name: "\u274C Nombre de carpeta no v\xE1lido: contiene caracteres no permitidos",
          already_exists: "\u274C La carpeta ya existe",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Carpeta creada: {{name}}",
          create_failed: "\u274C Error al crear la carpeta: {{error}}",
          select_first: "\u26A0\uFE0F Por favor, seleccione primero una carpeta"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "En la versi\xF3n 1.3.0, puede especificar una carpeta para los informes. Moveremos los informes existentes a {{folder}}, o puede seleccionar su carpeta preferida a continuaci\xF3n.",
        note: "Nota: La carpeta no puede estar dentro de Conversations o Attachments.",
        report_folder_label: "\u{1F4CA} Carpeta de informes",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Explorar",
          proceed: "Proceder"
        },
        error_invalid_folder: {
          title: "Ubicaci\xF3n de carpeta no v\xE1lida",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "\xA1Gracias por instalar Nexus AI Chat Importer!",
        description: "Importe y gestione sus conversaciones de ChatGPT, Claude y Le Chat directamente en su Vault de Obsidian.",
        resources_title: "Recursos",
        resources: {
          documentation: {
            title: "Documentaci\xF3n",
            description: "Aprenda a usar el plugin"
          },
          release_notes: {
            title: "Notas de versi\xF3n",
            description: "Novedades en esta versi\xF3n"
          },
          report_issues: {
            title: "Reportar problemas",
            description: "\xBFEncontr\xF3 un error? H\xE1ganoslo saber"
          },
          community_forum: {
            title: "Foro de la comunidad",
            description: "\xDAnase a la discusi\xF3n"
          }
        },
        buttons: {
          get_started: "Comenzar"
        }
      },
      notices: {
        import_analyzing: "Analizando conversaciones de {{count}} archivo(s)...",
        import_no_new: "No se encontraron conversaciones nuevas o actualizadas. Todas las conversaciones ya est\xE1n al d\xEDa.",
        import_starting: "Importando {{count}} conversaciones ({{new}} nuevas, {{updated}} actualizadas)...",
        import_starting_selected: "Importando {{count}} conversaciones seleccionadas de {{files}} archivo(s)...",
        import_completed_fallback: "Importaci\xF3n completada. {{created}} creadas, {{updated}} actualizadas.",
        import_error: "Error durante la importaci\xF3n: {{error}}",
        import_error_analyzing: "Error al analizar las conversaciones: {{error}}",
        import_error_file: "Error al procesar {{filename}}. Consulte la consola para m\xE1s detalles.",
        import_no_selected: "No se han seleccionado conversaciones para importar.",
        import_no_zip_gemini: "Por favor, seleccione al menos un archivo ZIP de Gemini Takeout (m\xE1s un JSON opcional desde la extensi\xF3n).",
        import_no_zip: "Por favor, seleccione al menos un archivo ZIP de exportaci\xF3n.",
        import_gemini_json_failed: "No se pudo leer el JSON de \xEDndice de Gemini. Continuando sin \xEDndice.",
        report_failed: "No se pudo crear el archivo de registro. Consulte la consola para m\xE1s detalles.",
        attachment_map_failed: "No se pudo construir el mapa de adjuntos. Consulte la consola para m\xE1s detalles.",
        ribbon_tooltip: "Nexus AI Chat Importer - Importar nuevo archivo"
      },
      commands: {
        import_conversations: {
          name: "Importar conversaciones de IA"
        }
      },
      support_box: {
        header: "Apoyar este plugin",
        header_highlight: "Apoyar este plugin",
        default_message_emphasis: "Trabajo a tiempo completo en los proyectos Nexus estando desempleado y enfrentando problemas de salud.",
        default_message: "Si este plugin te facilita la vida, una donaci\xF3n significar\xEDa much\xEDsimo para m\xED y ayudar\xEDa a mantenerlos activos.",
        reality_check: "\xA1Gracias! Miles de horas de trabajo han ido a estos plugins, y cada donaci\xF3n me ayuda a seguir mejor\xE1ndolos mientras gestiono problemas de salud continuos. Si este plugin te facilita la vida, por favor considera apoyarme.",
        button_alt: "Apoyar mi trabajo"
      }
    };
  }
});

// src/i18n/locales/it.json
var it_default;
var init_it = __esm({
  "src/i18n/locales/it.json"() {
    it_default = {
      common: {
        buttons: {
          cancel: "Annulla",
          ok: "OK",
          select: "Seleziona",
          browse: "Sfoglia",
          continue: "Continua",
          proceed: "Procedi",
          close: "Capito!",
          create: "Crea",
          remove: "Rimuovi",
          run: "Esegui",
          complete: "Completa",
          view_report: "Visualizza report",
          get_started: "Inizia",
          create_new_folder: "Crea nuova cartella"
        },
        status: {
          new: "Nuovo",
          updated: "Aggiornato",
          unchanged: "Invariato",
          unknown: "Sconosciuto"
        },
        progress: {
          phase_validation: "\u{1F50D} Validazione",
          phase_scanning: "\u{1F4CB} Scansione",
          phase_processing: "\u2699\uFE0F Elaborazione",
          phase_writing: "\u{1F4BE} Scrittura",
          phase_complete: "\u2705 Completato",
          phase_error: "\u274C Errore"
        }
      },
      provider_selection: {
        title: "Seleziona il provider dell'archivio",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "Esportazioni di conversazioni OpenAI ChatGPT"
          },
          claude: {
            name: "Claude",
            description: "Esportazioni di conversazioni Anthropic Claude"
          },
          lechat: {
            name: "Le Chat",
            description: "Esportazioni di conversazioni Mistral AI Le Chat"
          }
        },
        buttons: {
          select: "Seleziona",
          cancel: "Annulla"
        }
      },
      file_selection: {
        title: "Importa conversazioni {{provider}}",
        import_mode: {
          section_title: "Modalit\xE0 di importazione",
          all_label: "Importa tutto",
          all_description: "Importa tutte le conversazioni (pi\xF9 veloce)",
          selective_label: "Selezione specifica",
          selective_description: "Anteprima e scelta delle conversazioni"
        },
        file_area: {
          section_title: "Seleziona file",
          drop_text_default: "Trascina qui i file ZIP o clicca per sfogliare",
          drop_text_gemini: "Trascina qui i file ZIP e JSON o clicca per sfogliare",
          drop_subtext_default: "Supporta la selezione multipla di file",
          drop_subtext_gemini: "ZIP (Takeout) + JSON opzionale (indice dall'estensione)"
        },
        selected_files: {
          section_title: "File selezionati",
          remove_button: "Rimuovi"
        },
        buttons: {
          cancel: "Annulla",
          continue: "Continua"
        }
      },
      conversation_selection: {
        title: "Seleziona le conversazioni da importare",
        controls: {
          select_all: "Seleziona tutto",
          select_none: "Deseleziona tutto",
          search_placeholder: "Cerca conversazioni...",
          status_label: "Stato:",
          show_label: "Mostra:"
        },
        status_filter_options: {
          all: "Tutti",
          new: "Nuovo",
          updated: "Aggiornato",
          unchanged: "Invariato"
        },
        table_headers: {
          title: "Titolo",
          created: "Creato",
          updated: "Aggiornato",
          messages: "Messaggi",
          status: "Stato"
        },
        status_badges: {
          new: "Nuovo",
          updated: "Aggiornato",
          unchanged: "Invariato",
          unknown: "Sconosciuto",
          tooltip_new: "Questa conversazione non \xE8 nel tuo Vault",
          tooltip_updated: "Questa conversazione ha contenuto pi\xF9 recente rispetto al tuo Vault ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "Questa conversazione \xE8 uguale a quella nel tuo Vault"
        },
        pagination: {
          showing: "Visualizzazione di {{start}}-{{end}} su {{total}} conversazioni",
          page_of: "Pagina {{current}} di {{total}}",
          previous: "Precedente",
          next: "Successivo"
        },
        summary: {
          unique_conversations: "Conversazioni uniche",
          new: "Nuovo",
          updated: "Aggiornato",
          unchanged: "Invariato",
          selected_of: "{{selected}} di {{total}} selezionate"
        },
        buttons: {
          cancel: "Annulla",
          import_selected: "Importa selezione",
          import_selected_count: "Importa {{count}} selezionate"
        },
        date_unknown: "Sconosciuto"
      },
      import_progress: {
        title: "Importazione di {{filename}}",
        initial: {
          title: "Preparazione dell'importazione...",
          detail: "Validazione della struttura del file ZIP"
        },
        conversation_counter: "{{current}}/{{total}} conversazioni",
        conversation_counter_selective: "{{current}}/{{total}} conversazioni selezionate",
        selective_mode_indicator: "\u{1F4CB} Importazione selettiva: {{selected}} di {{total}} conversazioni",
        complete: {
          message: "Importazione completata con successo",
          detail: "Puoi chiudere questa finestra"
        },
        error: {
          message: "Si \xE8 verificato un errore durante l'importazione",
          detail: "Consulta la console per maggiori dettagli"
        }
      },
      import_completion: {
        title: "Importazione completata",
        success_message: "\u2705 Conversazioni importate con successo",
        stats: {
          zip_files_processed: "File ZIP elaborati",
          unique_conversations: "Conversazioni uniche",
          duplicates: "Duplicati",
          new: "Nuovo",
          updated: "Aggiornato",
          skipped: "Saltati",
          failed: "Falliti"
        },
        attachments: {
          label: "Allegati:",
          summary: "{{found}}/{{total}} estratti ({{percentage}}%)",
          missing_failed: "{{missing}} mancanti, {{failed}} falliti"
        },
        report: {
          label: "\u{1F4C4} Report dettagliato:"
        },
        buttons: {
          view_report: "Visualizza report",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Struttura delle cartelle",
          conversation_folder: {
            name: "Cartella delle conversazioni",
            desc: "Dove vengono archiviate le conversazioni importate",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Sfoglia le cartelle o creane una nuova"
          },
          reports_folder: {
            name: "Cartella dei report",
            desc: "Dove vengono archiviati i report di importazione",
            placeholder: "Nexus Reports",
            browse_tooltip: "Sfoglia le cartelle o creane una nuova"
          },
          attachment_folder: {
            name: "Cartella degli allegati",
            desc: "Dove vengono archiviati gli allegati (\u26A0\uFE0F Escludere dalla sincronizzazione per risparmiare spazio)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Sfoglia le cartelle o creane una nuova"
          }
        },
        display: {
          section_title: "\u{1F4C5} Prefisso data",
          add_date_prefix: {
            name: "Aggiungi prefisso data ai nomi dei file",
            desc: "Aggiunge la data di creazione come prefisso ai nomi dei file delle conversazioni",
            format_label: "Seleziona formato data: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Formato data messaggi",
          custom_format: {
            name: "Formato timestamp personalizzato per i messaggi",
            desc: "Sostituisce il formato timestamp predefinito basato sulla lingua nelle intestazioni dei messaggi. Quando disabilitato, i timestamp seguono l'impostazione della lingua di Obsidian. Se Obsidian \xE8 impostato in inglese, viene applicato il formato americano (YYYY/DD/MM)."
          },
          timestamp_format: {
            name: "Formato timestamp",
            desc: "Scegli il formato per i timestamp dei messaggi nelle note delle conversazioni"
          },
          preview_label: "Anteprima: "
        },
        attachments: {
          section_title: "Impostazioni allegati",
          import_attachments: {
            name: "Importa allegati",
            desc: "Salva i file allegati su disco e collegali nelle conversazioni (utilizza una strategia \xABbest effort\xBB)"
          },
          handle_missing: {
            name: "Gestisci allegati mancanti",
            desc: "Quando gli allegati mancano dalle esportazioni, crea note informative invece di saltarli"
          },
          show_details: {
            name: "Mostra dettagli allegati nei report",
            desc: "Includi statistiche dettagliate sull'elaborazione degli allegati nei report di importazione"
          },
          info_box: {
            title: "\u{1F4CE} Informazioni sulla gestione degli allegati",
            best_effort: "Strategia best effort: I file trovati nelle esportazioni vengono estratti e collegati; i file mancanti ricevono note informative.",
            platform_diff: "Differenze tra piattaforme: Le esportazioni di ChatGPT potrebbero non includere tutti gli allegati, specialmente dalle conversazioni pi\xF9 vecchie.",
            organization: "Organizzazione semplice: I file sono organizzati in attachments/provider/categoria/ (es. attachments/chatgpt/images/).",
            sync_tip: "Consiglio sulla sincronizzazione: Valuta di escludere la cartella degli allegati dalla sincronizzazione per evitare di caricare file di grandi dimensioni.",
            tip: "\u{1F4A1} Consiglio: Abilita \xABMostra dettagli allegati\xBB per vedere esattamente quali file sono stati trovati, mancanti o falliti durante l'importazione."
          }
        },
        migrations: {
          section_title: "Migrazioni",
          description_manual: "Operazioni manuali: Operazioni di aggiornamento opzionali che possono essere eseguite quando conveniente.",
          description_automatic: "Le operazioni automatiche (come la rimozione dei dati vecchi) vengono eseguite automaticamente durante l'aggiornamento e non sono mostrate qui.",
          version_header: "Versione {{version}}",
          no_migrations: {
            title: "Nessuna operazione manuale disponibile",
            desc: "Tutte le operazioni di aggiornamento sono state completate automaticamente."
          },
          operation_completed_suffix: " \u2705 Completato",
          buttons: {
            completed: "\u2705 Completato",
            cannot_run: "Impossibile eseguire",
            run: "Esegui",
            running: "In esecuzione..."
          },
          tooltips: {
            completed: "Questa operazione \xE8 stata completata",
            cannot_run: "I prerequisiti non sono soddisfatti per questa operazione",
            run: "Esegui {{operation_name}}"
          },
          error_loading: "Errore nel caricamento delle migrazioni:"
        },
        support: {
          section_title: "\u{1F49D} Supporto e aiuto",
          resources: {
            name: "\u{1F4DA} Risorse",
            desc: "Documentazione, note di rilascio e link alla community",
            documentation: "\u{1F4D6} Documentazione",
            release_notes: "\u{1F4DD} Note di versione",
            issues: "\u{1F41B} Segnalazioni",
            forum: "\u{1F4AC} Forum"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "Avvio in corso...",
          progress_label: "Progresso: {{percentage}}%",
          step_label: "Passaggio {{current}}/{{total}}",
          complete_label: "Completato",
          complete_message: "Completato con successo",
          error_message: "Si \xE8 verificato un errore"
        },
        multi_operation_modal: {
          progress_label: "Progresso: {{completed}}/{{total}} operazioni",
          progress_with_failures: "Progresso: {{completed}}/{{total}} operazioni ({{failed}} fallite)",
          all_completed: "Tutte le {{total}} operazioni completate con successo",
          mark_complete_default: "Tutte le operazioni completate con successo",
          buttons: {
            complete: "Completa",
            close: "Chiudi"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migrazione richiesta",
            message: "Le seguenti attivit\xE0 verranno eseguite automaticamente per aggiornare i dati alla v1.3.0:",
            tasks: {
              folder_settings: "\u2713 Migra le impostazioni delle cartelle alla nuova struttura",
              timestamps: "\u2713 Aggiorna i timestamp al formato ISO 8601",
              aliases: "\u2713 Correggi gli alias del frontmatter",
              reports: "\u2713 Sposta la cartella dei report nella posizione corretta",
              artifacts: "\u2713 Aggiorna i metadati degli artefatti"
            },
            estimate: "Ci vorranno pochi secondi."
          },
          buttons: {
            run_migration: "\u{1F680} Avvia le attivit\xE0 di migrazione"
          }
        },
        complete_modal: {
          title: "\u2705 Aggiornamento completato - v{{version}}",
          buttons: {
            got_it: "Capito!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "Capito!"
          }
        }
      },
      folder_migration: {
        title: "Spostare i file esistenti?",
        message_intro: "Stai modificando la posizione della cartella {{folder_type}}:",
        path_from: "Da: {{path}}",
        path_to: "A: {{path}}",
        question: "Vuoi spostare i file esistenti nella nuova posizione?",
        link_updates: {
          title: "\u{1F517} Aggiornamenti dei collegamenti:",
          attachments_text: "Lo spostamento degli allegati aggiorner\xE0 anche tutte le note delle conversazioni che li referenziano.",
          conversations_text: "Lo spostamento delle conversazioni aggiorner\xE0 anche tutti i report e gli allegati che le referenziano.",
          estimated_time_seconds: "Tempo stimato: ~{{seconds}} secondi",
          estimated_time_minutes: "Tempo stimato: ~{{minutes}} minuto/i"
        },
        warning: {
          title: "\u26A0\uFE0F Importante:",
          text: "Se scegli \xABNo\xBB, i file esistenti rimarranno nella posizione precedente e non saranno interessati da futuri aggiornamenti."
        },
        buttons: {
          cancel: "Annulla",
          keep: "No, mantieni i file nella posizione precedente",
          move: "S\xEC, sposta i file",
          move_with_links: "S\xEC, sposta i file e aggiorna i collegamenti"
        },
        progress: {
          title_moving: "Spostamento di {{folder_type}} e aggiornamento dei collegamenti",
          step_moving_title: "Spostamento dei file...",
          step_moving_detail: "Spostamento da {{old_path}} a {{new_path}}",
          step_moving_count: "{{current}} / {{total}} file elaborati",
          step_moved_title: "File spostati",
          step_moved_detail: "{{moved}} file spostati, {{skipped}} saltati. Preparazione all'aggiornamento dei collegamenti...",
          step_updating_attachment_links: "Aggiornamento dei collegamenti degli allegati...",
          step_updating_conversation_links: "Aggiornamento dei collegamenti delle conversazioni...",
          step_updating_report_links: "Aggiornamento dei collegamenti nei report...",
          step_updating_artifact_links: "Aggiornamento dei collegamenti negli artefatti...",
          complete_message: "{{moved}} file spostati. {{links}} collegamenti aggiornati con successo"
        },
        result_dialog: {
          title: "Risultato della migrazione delle cartelle",
          summary_title: "Riepilogo della migrazione",
          moved: "\u2705 Spostati con successo: {{count}} file",
          skipped: "\u26A0\uFE0F Saltati (gi\xE0 esistenti): {{count}} file",
          errors: "\u274C Errori: {{count}} file",
          explanation: "I file gi\xE0 presenti nella destinazione non sono stati sovrascritti per preservare i tuoi dati.",
          error_details_title: "Dettagli degli errori:"
        },
        error_target_not_empty: {
          title: "La cartella di destinazione non \xE8 vuota",
          message: "La cartella \xAB{{path}}\xBB contiene gi\xE0 dei file.\n\nPer cambiare la posizione della cartella:\n\u2022 Sposta manualmente i file esistenti in Obsidian, OPPURE\n\u2022 Scegli una cartella vuota o creane una nuova"
        },
        error_migration_failed: {
          title: "Migrazione non riuscita",
          message_move: "Impossibile spostare i file: {{error}}",
          message_links: "Impossibile spostare i file o aggiornare i collegamenti: {{error}}"
        }
      },
      folder_browser: {
        title: "Seleziona cartella",
        vault_root: "Radice del Vault (/)",
        buttons: {
          create_new_folder: "Crea nuova cartella",
          cancel: "Annulla",
          select: "Seleziona"
        },
        create_folder_dialog: {
          title: "Crea nuova cartella",
          folder_name_label: "Nome cartella:",
          buttons: {
            cancel: "Annulla",
            create: "Crea"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Seleziona prima una cartella principale",
          invalid_name: "\u274C Nome cartella non valido: contiene caratteri non consentiti",
          already_exists: "\u274C La cartella esiste gi\xE0",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Cartella creata: {{name}}",
          create_failed: "\u274C Impossibile creare la cartella: {{error}}",
          select_first: "\u26A0\uFE0F Seleziona prima una cartella"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "Nella versione 1.3.0, puoi specificare una cartella per i report. I report esistenti verranno spostati in {{folder}}, oppure puoi selezionare la cartella preferita qui sotto.",
        note: "Nota: La cartella non pu\xF2 trovarsi all'interno di Conversations o Attachments.",
        report_folder_label: "\u{1F4CA} Cartella dei report",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Sfoglia",
          proceed: "Procedi"
        },
        error_invalid_folder: {
          title: "Posizione cartella non valida",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Grazie per aver installato Nexus AI Chat Importer!",
        description: "Importa e gestisci le tue conversazioni ChatGPT, Claude e Le Chat direttamente nel tuo Vault Obsidian.",
        resources_title: "Risorse",
        resources: {
          documentation: {
            title: "Documentazione",
            description: "Scopri come usare il plugin"
          },
          release_notes: {
            title: "Note di rilascio",
            description: "Novit\xE0 in questa versione"
          },
          report_issues: {
            title: "Segnala problemi",
            description: "Hai trovato un bug? Faccelo sapere"
          },
          community_forum: {
            title: "Forum della community",
            description: "Partecipa alla discussione"
          }
        },
        buttons: {
          get_started: "Inizia"
        }
      },
      notices: {
        import_analyzing: "Analisi delle conversazioni da {{count}} file...",
        import_no_new: "Nessuna conversazione nuova o aggiornata trovata. Tutte le conversazioni sono gi\xE0 aggiornate.",
        import_starting: "Importazione di {{count}} conversazioni ({{new}} nuove, {{updated}} aggiornate)...",
        import_starting_selected: "Importazione di {{count}} conversazioni selezionate da {{files}} file...",
        import_completed_fallback: "Importazione completata. {{created}} create, {{updated}} aggiornate.",
        import_error: "Errore durante l'importazione: {{error}}",
        import_error_analyzing: "Errore durante l'analisi delle conversazioni: {{error}}",
        import_error_file: "Errore durante l'elaborazione di {{filename}}. Consulta la console per maggiori dettagli.",
        import_no_selected: "Nessuna conversazione selezionata per l'importazione.",
        import_no_zip_gemini: "Seleziona almeno un file ZIP di Gemini Takeout (pi\xF9 un JSON opzionale dall'estensione).",
        import_no_zip: "Seleziona almeno un file ZIP di esportazione.",
        import_gemini_json_failed: "Impossibile leggere il JSON dell'indice Gemini. Continuo senza indice.",
        report_failed: "Impossibile creare il file di log. Consulta la console per maggiori dettagli.",
        attachment_map_failed: "Impossibile costruire la mappa degli allegati. Consulta la console per maggiori dettagli.",
        ribbon_tooltip: "Nexus AI Chat Importer - Importa nuovo file"
      },
      commands: {
        import_conversations: {
          name: "Importa conversazioni IA"
        }
      },
      support_box: {
        header: "Supporta questo plugin",
        header_highlight: "Supporta questo plugin",
        default_message_emphasis: "Lavoro a tempo pieno sui progetti Nexus mentre sono disoccupato e affronto problemi di salute.",
        default_message: "Se questo plugin ti semplifica la vita, una donazione significherebbe moltissimo per me e aiuterebbe a tenerli in vita.",
        reality_check: "Grazie! Migliaia di ore di lavoro sono state dedicate a questi plugin, e ogni donazione mi aiuta a continuare a migliorarli mentre gestisco problemi di salute continuativi. Se questo plugin ti semplifica la vita, considera di supportarmi.",
        button_alt: "Supportare il mio lavoro"
      }
    };
  }
});

// src/i18n/locales/ru.json
var ru_default;
var init_ru = __esm({
  "src/i18n/locales/ru.json"() {
    ru_default = {
      common: {
        buttons: {
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          ok: "\u041E\u041A",
          select: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C",
          browse: "\u041E\u0431\u0437\u043E\u0440",
          continue: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C",
          proceed: "\u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C",
          close: "\u041F\u043E\u043D\u044F\u0442\u043D\u043E!",
          create: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C",
          remove: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
          run: "\u0417\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
          complete: "\u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044C",
          view_report: "\u041F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u043E\u0442\u0447\u0451\u0442",
          get_started: "\u041D\u0430\u0447\u0430\u0442\u044C",
          create_new_folder: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u0443\u044E \u043F\u0430\u043F\u043A\u0443"
        },
        status: {
          new: "\u041D\u043E\u0432\u044B\u0439",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D",
          unchanged: "\u0411\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439",
          unknown: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E"
        },
        progress: {
          phase_validation: "\u{1F50D} \u041F\u0440\u043E\u0432\u0435\u0440\u043A\u0430",
          phase_scanning: "\u{1F4CB} \u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435",
          phase_processing: "\u2699\uFE0F \u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430",
          phase_writing: "\u{1F4BE} \u0417\u0430\u043F\u0438\u0441\u044C",
          phase_complete: "\u2705 \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E",
          phase_error: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430"
        }
      },
      provider_selection: {
        title: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u043E\u0441\u0442\u0430\u0432\u0449\u0438\u043A\u0430 \u0430\u0440\u0445\u0438\u0432\u0430",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 OpenAI ChatGPT"
          },
          claude: {
            name: "Claude",
            description: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 Anthropic Claude"
          },
          lechat: {
            name: "Le Chat",
            description: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 Mistral AI Le Chat"
          }
        },
        buttons: {
          select: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C",
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430"
        }
      },
      file_selection: {
        title: "\u0418\u043C\u043F\u043E\u0440\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 {{provider}}",
        import_mode: {
          section_title: "\u0420\u0435\u0436\u0438\u043C \u0438\u043C\u043F\u043E\u0440\u0442\u0430",
          all_label: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0451",
          all_description: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B (\u0431\u044B\u0441\u0442\u0440\u0435\u0435)",
          selective_label: "\u0412\u044B\u0431\u043E\u0440\u043E\u0447\u043D\u044B\u0439 \u0432\u044B\u0431\u043E\u0440",
          selective_description: "\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u0438 \u0432\u044B\u0431\u043E\u0440 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432"
        },
        file_area: {
          section_title: "\u0412\u044B\u0431\u043E\u0440 \u0444\u0430\u0439\u043B\u043E\u0432",
          drop_text_default: "\u041F\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 ZIP-\u0444\u0430\u0439\u043B\u044B \u0441\u044E\u0434\u0430 \u0438\u043B\u0438 \u043D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u0432\u044B\u0431\u043E\u0440\u0430",
          drop_text_gemini: "\u041F\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 ZIP- \u0438 JSON-\u0444\u0430\u0439\u043B\u044B \u0441\u044E\u0434\u0430 \u0438\u043B\u0438 \u043D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u0432\u044B\u0431\u043E\u0440\u0430",
          drop_subtext_default: "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432\u044B\u0431\u043E\u0440 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u0438\u0445 \u0444\u0430\u0439\u043B\u043E\u0432",
          drop_subtext_gemini: "ZIP (Takeout) + \u043D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0439 JSON (\u0438\u043D\u0434\u0435\u043A\u0441 \u0438\u0437 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F)"
        },
        selected_files: {
          section_title: "\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B",
          remove_button: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C"
        },
        buttons: {
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          continue: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C"
        }
      },
      conversation_selection: {
        title: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B \u0434\u043B\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0430",
        controls: {
          select_all: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0451",
          select_none: "\u0421\u043D\u044F\u0442\u044C \u0432\u044B\u0431\u043E\u0440",
          search_placeholder: "\u041F\u043E\u0438\u0441\u043A \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432...",
          status_label: "\u0421\u0442\u0430\u0442\u0443\u0441:",
          show_label: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C:"
        },
        status_filter_options: {
          all: "\u0412\u0441\u0435",
          new: "\u041D\u043E\u0432\u044B\u0435",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D\u043D\u044B\u0435",
          unchanged: "\u0411\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439"
        },
        table_headers: {
          title: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
          created: "\u0421\u043E\u0437\u0434\u0430\u043D",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D",
          messages: "\u0421\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F",
          status: "\u0421\u0442\u0430\u0442\u0443\u0441"
        },
        status_badges: {
          new: "\u041D\u043E\u0432\u044B\u0439",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D",
          unchanged: "\u0411\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439",
          unknown: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E",
          tooltip_new: "\u042D\u0442\u043E\u0433\u043E \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u0430 \u043D\u0435\u0442 \u0432 \u0432\u0430\u0448\u0435\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435",
          tooltip_updated: "\u042D\u0442\u043E\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442 \u0431\u043E\u043B\u0435\u0435 \u043D\u043E\u0432\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435, \u0447\u0435\u043C \u0432 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "\u042D\u0442\u043E\u0442 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442 \u0441 \u0432\u0435\u0440\u0441\u0438\u0435\u0439 \u0432 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435"
        },
        pagination: {
          showing: "\u041F\u043E\u043A\u0430\u0437\u0430\u043D\u044B {{start}}\u2013{{end}} \u0438\u0437 {{total}} \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
          page_of: "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 {{current}} \u0438\u0437 {{total}}",
          previous: "\u041D\u0430\u0437\u0430\u0434",
          next: "\u0414\u0430\u043B\u0435\u0435"
        },
        summary: {
          unique_conversations: "\u0423\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0435 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B",
          new: "\u041D\u043E\u0432\u044B\u0435",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D\u043D\u044B\u0435",
          unchanged: "\u0411\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439",
          selected_of: "{{selected}} \u0438\u0437 {{total}} \u0432\u044B\u0431\u0440\u0430\u043D\u043E"
        },
        buttons: {
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          import_selected: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435",
          import_selected_count: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C {{count}} \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0445"
        },
        date_unknown: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E"
      },
      import_progress: {
        title: "\u0418\u043C\u043F\u043E\u0440\u0442 {{filename}}",
        initial: {
          title: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u0438\u043C\u043F\u043E\u0440\u0442\u0430...",
          detail: "\u041F\u0440\u043E\u0432\u0435\u0440\u043A\u0430 \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B ZIP-\u0444\u0430\u0439\u043B\u0430"
        },
        conversation_counter: "{{current}}/{{total}} \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
        conversation_counter_selective: "{{current}}/{{total}} \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
        selective_mode_indicator: "\u{1F4CB} \u0412\u044B\u0431\u043E\u0440\u043E\u0447\u043D\u044B\u0439 \u0438\u043C\u043F\u043E\u0440\u0442: {{selected}} \u0438\u0437 {{total}} \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
        complete: {
          message: "\u0418\u043C\u043F\u043E\u0440\u0442 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043D",
          detail: "\u0412\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0437\u0430\u043A\u0440\u044B\u0442\u044C \u044D\u0442\u043E \u043E\u043A\u043D\u043E"
        },
        error: {
          message: "\u0412 \u043F\u0440\u043E\u0446\u0435\u0441\u0441\u0435 \u0438\u043C\u043F\u043E\u0440\u0442\u0430 \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430",
          detail: "\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438"
        }
      },
      import_completion: {
        title: "\u0418\u043C\u043F\u043E\u0440\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043D",
        success_message: "\u2705 \u0420\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u044B",
        stats: {
          zip_files_processed: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043E ZIP-\u0444\u0430\u0439\u043B\u043E\u0432",
          unique_conversations: "\u0423\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
          duplicates: "\u0414\u0443\u0431\u043B\u0438\u043A\u0430\u0442\u044B",
          new: "\u041D\u043E\u0432\u044B\u0435",
          updated: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D\u043D\u044B\u0435",
          skipped: "\u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E",
          failed: "\u041E\u0448\u0438\u0431\u043A\u0430"
        },
        attachments: {
          label: "\u0412\u043B\u043E\u0436\u0435\u043D\u0438\u044F:",
          summary: "{{found}}/{{total}} \u0438\u0437\u0432\u043B\u0435\u0447\u0435\u043D\u043E ({{percentage}}%)",
          missing_failed: "{{missing}} \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442, {{failed}} \u0441 \u043E\u0448\u0438\u0431\u043A\u0430\u043C\u0438"
        },
        report: {
          label: "\u{1F4C4} \u041F\u043E\u0434\u0440\u043E\u0431\u043D\u044B\u0439 \u043E\u0442\u0447\u0451\u0442:"
        },
        buttons: {
          view_report: "\u041F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u043E\u0442\u0447\u0451\u0442",
          ok: "\u041E\u041A"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} \u0421\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430 \u043F\u0430\u043F\u043E\u043A",
          conversation_folder: {
            name: "\u041F\u0430\u043F\u043A\u0430 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
            desc: "\u041C\u0435\u0441\u0442\u043E \u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "\u041E\u0431\u0437\u043E\u0440 \u043F\u0430\u043F\u043E\u043A \u0438\u043B\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043D\u043E\u0432\u043E\u0439"
          },
          reports_folder: {
            name: "\u041F\u0430\u043F\u043A\u0430 \u043E\u0442\u0447\u0451\u0442\u043E\u0432",
            desc: "\u041C\u0435\u0441\u0442\u043E \u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043E\u0442\u0447\u0451\u0442\u043E\u0432 \u043E\u0431 \u0438\u043C\u043F\u043E\u0440\u0442\u0435",
            placeholder: "Nexus Reports",
            browse_tooltip: "\u041E\u0431\u0437\u043E\u0440 \u043F\u0430\u043F\u043E\u043A \u0438\u043B\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043D\u043E\u0432\u043E\u0439"
          },
          attachment_folder: {
            name: "\u041F\u0430\u043F\u043A\u0430 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439",
            desc: "\u041C\u0435\u0441\u0442\u043E \u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 (\u26A0\uFE0F \u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u0438\u0437 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043B\u044F \u044D\u043A\u043E\u043D\u043E\u043C\u0438\u0438 \u043C\u0435\u0441\u0442\u0430)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "\u041E\u0431\u0437\u043E\u0440 \u043F\u0430\u043F\u043E\u043A \u0438\u043B\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043D\u043E\u0432\u043E\u0439"
          }
        },
        display: {
          section_title: "\u{1F4C5} \u041F\u0440\u0435\u0444\u0438\u043A\u0441 \u0434\u0430\u0442\u044B",
          add_date_prefix: {
            name: "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u043F\u0440\u0435\u0444\u0438\u043A\u0441 \u0434\u0430\u0442\u044B \u043A \u0438\u043C\u0435\u043D\u0430\u043C \u0444\u0430\u0439\u043B\u043E\u0432",
            desc: "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u0434\u0430\u0442\u0443 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0432 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043F\u0440\u0435\u0444\u0438\u043A\u0441\u0430 \u043A \u0438\u043C\u0435\u043D\u0430\u043C \u0444\u0430\u0439\u043B\u043E\u0432 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432",
            format_label: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0434\u0430\u0442\u044B: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} \u0424\u043E\u0440\u043C\u0430\u0442 \u0434\u0430\u0442\u044B \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439",
          custom_format: {
            name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u043C\u0435\u0442\u043E\u043A \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439",
            desc: "\u041F\u0435\u0440\u0435\u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0438\u0442\u044C \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u043C\u0435\u0442\u043E\u043A \u0432 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0430\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439. \u041F\u0440\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435 \u043C\u0435\u0442\u043A\u0438 \u0441\u043B\u0435\u0434\u0443\u044E\u0442 \u044F\u0437\u044B\u043A\u043E\u0432\u044B\u043C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u043C Obsidian. \u0415\u0441\u043B\u0438 Obsidian \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D \u043D\u0430 \u0430\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u0438\u0439 \u044F\u0437\u044B\u043A, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0444\u043E\u0440\u043C\u0430\u0442 \u0421\u0428\u0410 (YYYY/DD/MM)."
          },
          timestamp_format: {
            name: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0439 \u043C\u0435\u0442\u043A\u0438",
            desc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u043C\u0435\u0442\u043E\u043A \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439 \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432"
          },
          preview_label: "\u041F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440: "
        },
        attachments: {
          section_title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439",
          import_attachments: {
            name: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F",
            desc: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u043D\u0430 \u0434\u0438\u0441\u043A \u0438 \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0438 \u043D\u0430 \u043D\u0438\u0445 \u0432 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u0430\u0445 (\u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 \u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u044E \xAB\u043C\u0430\u043A\u0441\u0438\u043C\u0443\u043C \u0443\u0441\u0438\u043B\u0438\u0439\xBB)"
          },
          handle_missing: {
            name: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439",
            desc: "\u0415\u0441\u043B\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0442 \u0432 \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0435, \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0445 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430"
          },
          show_details: {
            name: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u0432 \u043E\u0442\u0447\u0451\u0442\u0430\u0445",
            desc: "\u0412\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u0443\u044E \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u0432 \u043E\u0442\u0447\u0451\u0442\u044B \u043E\u0431 \u0438\u043C\u043F\u043E\u0440\u0442\u0435"
          },
          info_box: {
            title: "\u{1F4CE} \u041E\u0431 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439",
            best_effort: "\u0421\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u044F \xAB\u043C\u0430\u043A\u0441\u0438\u043C\u0443\u043C \u0443\u0441\u0438\u043B\u0438\u0439\xBB: \u0444\u0430\u0439\u043B\u044B, \u043D\u0430\u0439\u0434\u0435\u043D\u043D\u044B\u0435 \u0432 \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0435, \u0438\u0437\u0432\u043B\u0435\u043A\u0430\u044E\u0442\u0441\u044F \u0438 \u0441\u0432\u044F\u0437\u044B\u0432\u0430\u044E\u0442\u0441\u044F; \u0434\u043B\u044F \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 \u0441\u043E\u0437\u0434\u0430\u044E\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438.",
            platform_diff: "\u0420\u0430\u0437\u043B\u0438\u0447\u0438\u044F \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C: \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u044B ChatGPT \u043C\u043E\u0433\u0443\u0442 \u043D\u0435 \u0432\u043A\u043B\u044E\u0447\u0430\u0442\u044C \u0432\u0441\u0435 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F, \u043E\u0441\u043E\u0431\u0435\u043D\u043D\u043E \u0438\u0437 \u0441\u0442\u0430\u0440\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432.",
            organization: "\u041F\u0440\u043E\u0441\u0442\u0430\u044F \u043E\u0440\u0433\u0430\u043D\u0438\u0437\u0430\u0446\u0438\u044F: \u0444\u0430\u0439\u043B\u044B \u043E\u0440\u0433\u0430\u043D\u0438\u0437\u043E\u0432\u0430\u043D\u044B \u043F\u043E \u0441\u0445\u0435\u043C\u0435 attachments/provider/category/ (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, attachments/chatgpt/images/).",
            sync_tip: "\u0421\u043E\u0432\u0435\u0442 \u043F\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: \u0440\u0430\u0441\u0441\u043C\u043E\u0442\u0440\u0438\u0442\u0435 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043F\u0430\u043F\u043A\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u0438\u0437 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438, \u0447\u0442\u043E\u0431\u044B \u0438\u0437\u0431\u0435\u0436\u0430\u0442\u044C \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0431\u043E\u043B\u044C\u0448\u0438\u0445 \u0444\u0430\u0439\u043B\u043E\u0432.",
            tip: "\u{1F4A1} \u0421\u043E\u0432\u0435\u0442: \u0432\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \xAB\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439\xBB, \u0447\u0442\u043E\u0431\u044B \u0442\u043E\u0447\u043D\u043E \u0432\u0438\u0434\u0435\u0442\u044C, \u043A\u0430\u043A\u0438\u0435 \u0444\u0430\u0439\u043B\u044B \u0431\u044B\u043B\u0438 \u043D\u0430\u0439\u0434\u0435\u043D\u044B, \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u043B\u0438 \u0438\u043B\u0438 \u043D\u0435 \u0431\u044B\u043B\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u044B \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0430."
          }
        },
        migrations: {
          section_title: "\u041C\u0438\u0433\u0440\u0430\u0446\u0438\u0438",
          description_manual: "\u0420\u0443\u0447\u043D\u044B\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438: \u043D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043C\u043E\u0436\u043D\u043E \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0432 \u0443\u0434\u043E\u0431\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F.",
          description_automatic: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0443\u0441\u0442\u0430\u0440\u0435\u0432\u0448\u0438\u0445 \u0434\u0430\u043D\u043D\u044B\u0445) \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u044E\u0442\u0441\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0438 \u0437\u0434\u0435\u0441\u044C \u043D\u0435 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F.",
          version_header: "\u0412\u0435\u0440\u0441\u0438\u044F {{version}}",
          no_migrations: {
            title: "\u041D\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 \u0440\u0443\u0447\u043D\u044B\u0445 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439",
            desc: "\u0412\u0441\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0431\u044B\u043B\u0438 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438."
          },
          operation_completed_suffix: " \u2705 \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E",
          buttons: {
            completed: "\u2705 \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E",
            cannot_run: "\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C",
            run: "\u0417\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
            running: "\u0412\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F..."
          },
          tooltips: {
            completed: "\u042D\u0442\u0430 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u044F \u0443\u0436\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0430",
            cannot_run: "\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0443\u0441\u043B\u043E\u0432\u0438\u044F \u0434\u043B\u044F \u044D\u0442\u043E\u0439 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438 \u043D\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u044B",
            run: "\u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C {{operation_name}}"
          },
          error_loading: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u0439:"
        },
        support: {
          section_title: "\u{1F49D} \u041F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0430 \u0438 \u043F\u043E\u043C\u043E\u0449\u044C",
          resources: {
            name: "\u{1F4DA} \u0420\u0435\u0441\u0443\u0440\u0441\u044B",
            desc: "\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0446\u0438\u044F, \u043F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u044F \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0443 \u0438 \u0441\u0441\u044B\u043B\u043A\u0438 \u043D\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u0441\u0442\u0432\u043E",
            documentation: "\u{1F4D6} \u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0446\u0438\u044F",
            release_notes: "\u{1F4DD} \u0418\u0441\u0442\u043E\u0440\u0438\u044F \u0432\u0435\u0440\u0441\u0438\u0439",
            issues: "\u{1F41B} \u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B",
            forum: "\u{1F4AC} \u0424\u043E\u0440\u0443\u043C"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "\u0417\u0430\u043F\u0443\u0441\u043A...",
          progress_label: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: {{percentage}}%",
          step_label: "\u0428\u0430\u0433 {{current}}/{{total}}",
          complete_label: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E",
          complete_message: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E",
          error_message: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430"
        },
        multi_operation_modal: {
          progress_label: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: {{completed}}/{{total}} \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439",
          progress_with_failures: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: {{completed}}/{{total}} \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439 ({{failed}} \u0441 \u043E\u0448\u0438\u0431\u043A\u0430\u043C\u0438)",
          all_completed: "\u0412\u0441\u0435 {{total}} \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u044B",
          mark_complete_default: "\u0412\u0441\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0438 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u044B",
          buttons: {
            complete: "\u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044C",
            close: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u044F",
            message: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435 \u0437\u0430\u0434\u0430\u0447\u0438 \u0431\u0443\u0434\u0443\u0442 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0434\u043B\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0432\u0430\u0448\u0438\u0445 \u0434\u0430\u043D\u043D\u044B\u0445 \u0434\u043E v1.3.0:",
            tasks: {
              folder_settings: "\u2713 \u041F\u0435\u0440\u0435\u043D\u043E\u0441 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A \u043F\u0430\u043F\u043E\u043A \u0432 \u043D\u043E\u0432\u0443\u044E \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0443",
              timestamps: "\u2713 \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u043C\u0435\u0442\u043E\u043A \u0434\u043E \u0444\u043E\u0440\u043C\u0430\u0442\u0430 ISO 8601",
              aliases: "\u2713 \u0418\u0441\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0441\u0435\u0432\u0434\u043E\u043D\u0438\u043C\u043E\u0432 frontmatter",
              reports: "\u2713 \u041F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0438 \u043E\u0442\u0447\u0451\u0442\u043E\u0432 \u0432 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0435 \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435",
              artifacts: "\u2713 \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0430\u0440\u0442\u0435\u0444\u0430\u043A\u0442\u043E\u0432"
            },
            estimate: "\u042D\u0442\u043E \u0437\u0430\u0439\u043C\u0451\u0442 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0441\u0435\u043A\u0443\u043D\u0434."
          },
          buttons: {
            run_migration: "\u{1F680} \u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0437\u0430\u0434\u0430\u0447\u0438 \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u0438"
          }
        },
        complete_modal: {
          title: "\u2705 \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E \u2014 v{{version}}",
          buttons: {
            got_it: "\u041F\u043E\u043D\u044F\u0442\u043D\u043E!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "\u041F\u043E\u043D\u044F\u0442\u043D\u043E!"
          }
        }
      },
      folder_migration: {
        title: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B?",
        message_intro: "\u0412\u044B \u0438\u0437\u043C\u0435\u043D\u044F\u0435\u0442\u0435 \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0438 {{folder_type}}:",
        path_from: "\u041E\u0442\u043A\u0443\u0434\u0430: {{path}}",
        path_to: "\u041A\u0443\u0434\u0430: {{path}}",
        question: "\u0425\u043E\u0442\u0438\u0442\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B \u0432 \u043D\u043E\u0432\u043E\u0435 \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435?",
        link_updates: {
          title: "\u{1F517} \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A:",
          attachments_text: "\u041F\u0440\u0438 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u0442\u0430\u043A\u0436\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B \u0432\u0441\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0430 \u043D\u0438\u0445 \u0441\u0441\u044B\u043B\u0430\u044E\u0442\u0441\u044F.",
          conversations_text: "\u041F\u0440\u0438 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0438 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 \u0442\u0430\u043A\u0436\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B \u0432\u0441\u0435 \u043E\u0442\u0447\u0451\u0442\u044B \u0438 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0430 \u043D\u0438\u0445 \u0441\u0441\u044B\u043B\u0430\u044E\u0442\u0441\u044F.",
          estimated_time_seconds: "\u041E\u0436\u0438\u0434\u0430\u0435\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F: ~{{seconds}} \u0441\u0435\u043A\u0443\u043D\u0434",
          estimated_time_minutes: "\u041E\u0436\u0438\u0434\u0430\u0435\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F: ~{{minutes}} \u043C\u0438\u043D\u0443\u0442(\u044B)"
        },
        warning: {
          title: "\u26A0\uFE0F \u0412\u0430\u0436\u043D\u043E:",
          text: "\u0415\u0441\u043B\u0438 \u0432\u044B \u0432\u044B\u0431\u0435\u0440\u0435\u0442\u0435 \xAB\u041D\u0435\u0442\xBB, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B \u043E\u0441\u0442\u0430\u043D\u0443\u0442\u0441\u044F \u0432 \u043F\u0440\u0435\u0436\u043D\u0435\u043C \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0438 \u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u0442\u0440\u043E\u043D\u0443\u0442\u044B \u0431\u0443\u0434\u0443\u0449\u0438\u043C\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F\u043C\u0438."
        },
        buttons: {
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          keep: "\u041D\u0435\u0442, \u043E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u043D\u0430 \u043F\u0440\u0435\u0436\u043D\u0435\u043C \u043C\u0435\u0441\u0442\u0435",
          move: "\u0414\u0430, \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0444\u0430\u0439\u043B\u044B",
          move_with_links: "\u0414\u0430, \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u0438 \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0438"
        },
        progress: {
          title_moving: "\u041F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435 {{folder_type}} \u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A",
          step_moving_title: "\u041F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432...",
          step_moving_detail: "\u041F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0438\u0437 {{old_path}} \u0432 {{new_path}}",
          step_moving_count: "{{current}} / {{total}} \u0444\u0430\u0439\u043B\u043E\u0432 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043E",
          step_moved_title: "\u0424\u0430\u0439\u043B\u044B \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u044B",
          step_moved_detail: "{{moved}} \u0444\u0430\u0439\u043B\u043E\u0432 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u043E, {{skipped}} \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E. \u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044E \u0441\u0441\u044B\u043B\u043E\u043A...",
          step_updating_attachment_links: "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A \u043D\u0430 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F...",
          step_updating_conversation_links: "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A \u043D\u0430 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B...",
          step_updating_report_links: "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A \u0432 \u043E\u0442\u0447\u0451\u0442\u0430\u0445...",
          step_updating_artifact_links: "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043E\u043A \u0432 \u0430\u0440\u0442\u0435\u0444\u0430\u043A\u0442\u0430\u0445...",
          complete_message: "{{moved}} \u0444\u0430\u0439\u043B\u043E\u0432 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u043E. {{links}} \u0441\u0441\u044B\u043B\u043E\u043A \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E"
        },
        result_dialog: {
          title: "\u0420\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442 \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u043F\u0430\u043F\u043A\u0438",
          summary_title: "\u0421\u0432\u043E\u0434\u043A\u0430 \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u0438",
          moved: "\u2705 \u0423\u0441\u043F\u0435\u0448\u043D\u043E \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u043E: {{count}} \u0444\u0430\u0439\u043B(\u043E\u0432)",
          skipped: "\u26A0\uFE0F \u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E (\u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0442): {{count}} \u0444\u0430\u0439\u043B(\u043E\u0432)",
          errors: "\u274C \u041E\u0448\u0438\u0431\u043A\u0438: {{count}} \u0444\u0430\u0439\u043B(\u043E\u0432)",
          explanation: "\u0424\u0430\u0439\u043B\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043E\u0432\u0430\u043B\u0438 \u0432 \u0446\u0435\u043B\u0435\u0432\u043E\u0439 \u043F\u0430\u043F\u043A\u0435, \u043D\u0435 \u0431\u044B\u043B\u0438 \u043F\u0435\u0440\u0435\u0437\u0430\u043F\u0438\u0441\u0430\u043D\u044B \u0434\u043B\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0432\u0430\u0448\u0438\u0445 \u0434\u0430\u043D\u043D\u044B\u0445.",
          error_details_title: "\u0414\u0435\u0442\u0430\u043B\u0438 \u043E\u0448\u0438\u0431\u043E\u043A:"
        },
        error_target_not_empty: {
          title: "\u0426\u0435\u043B\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430 \u043D\u0435 \u043F\u0443\u0441\u0442\u0430",
          message: '\u041F\u0430\u043F\u043A\u0430 "{{path}}" \u0443\u0436\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0430\u0439\u043B\u044B.\n\n\u0414\u043B\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u044F \u043F\u0430\u043F\u043A\u0438:\n\u2022 \u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0432 Obsidian, \u0418\u041B\u0418\n\u2022 \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0443\u0441\u0442\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0438\u043B\u0438 \u0441\u043E\u0437\u0434\u0430\u0439\u0442\u0435 \u043D\u043E\u0432\u0443\u044E'
        },
        error_migration_failed: {
          title: "\u041C\u0438\u0433\u0440\u0430\u0446\u0438\u044F \u043D\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0430",
          message_move: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0444\u0430\u0439\u043B\u044B: {{error}}",
          message_links: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u0438\u043B\u0438 \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0438: {{error}}"
        }
      },
      folder_browser: {
        title: "\u0412\u044B\u0431\u043E\u0440 \u043F\u0430\u043F\u043A\u0438",
        vault_root: "\u041A\u043E\u0440\u0435\u043D\u044C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430 (/)",
        buttons: {
          create_new_folder: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u0443\u044E \u043F\u0430\u043F\u043A\u0443",
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          select: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C"
        },
        create_folder_dialog: {
          title: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u0443\u044E \u043F\u0430\u043F\u043A\u0443",
          folder_name_label: "\u0418\u043C\u044F \u043F\u0430\u043F\u043A\u0438:",
          buttons: {
            cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
            create: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F \u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u0441\u043A\u0443\u044E \u043F\u0430\u043F\u043A\u0443",
          invalid_name: "\u274C \u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0438\u043C\u044F \u043F\u0430\u043F\u043A\u0438: \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442 \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B",
          already_exists: "\u274C \u041F\u0430\u043F\u043A\u0430 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 \u041F\u0430\u043F\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0430: {{name}}",
          create_failed: "\u274C \u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443: {{error}}",
          select_first: "\u26A0\uFE0F \u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0443"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "\u0412 \u0432\u0435\u0440\u0441\u0438\u0438 1.3.0 \u0432\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0434\u043B\u044F \u043E\u0442\u0447\u0451\u0442\u043E\u0432. \u041C\u044B \u043F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u043C \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043E\u0442\u0447\u0451\u0442\u044B \u0432 {{folder}}, \u0438\u043B\u0438 \u0432\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0432\u044B\u0431\u0440\u0430\u0442\u044C \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u043D\u0438\u0436\u0435.",
        note: "\u041F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u0435: \u043F\u0430\u043F\u043A\u0430 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u043D\u0430\u0445\u043E\u0434\u0438\u0442\u044C\u0441\u044F \u0432\u043D\u0443\u0442\u0440\u0438 \u043F\u0430\u043F\u043E\u043A \xAB\u0420\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B\xBB \u0438\u043B\u0438 \xAB\u0412\u043B\u043E\u0436\u0435\u043D\u0438\u044F\xBB.",
        report_folder_label: "\u{1F4CA} \u041F\u0430\u043F\u043A\u0430 \u043E\u0442\u0447\u0451\u0442\u043E\u0432",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "\u041E\u0431\u0437\u043E\u0440",
          proceed: "\u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C"
        },
        error_invalid_folder: {
          title: "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0438",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "\u0421\u043F\u0430\u0441\u0438\u0431\u043E \u0437\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0443 Nexus AI Chat Importer!",
        description: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B ChatGPT, Claude \u0438 Le Chat \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u044F\u0439\u0442\u0435 \u0438\u043C\u0438 \u043F\u0440\u044F\u043C\u043E \u0432 \u0432\u0430\u0448\u0435\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 Obsidian.",
        resources_title: "\u0420\u0435\u0441\u0443\u0440\u0441\u044B",
        resources: {
          documentation: {
            title: "\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0446\u0438\u044F",
            description: "\u0423\u0437\u043D\u0430\u0439\u0442\u0435, \u043A\u0430\u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D"
          },
          release_notes: {
            title: "\u041F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u044F \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0443",
            description: "\u0427\u0442\u043E \u043D\u043E\u0432\u043E\u0433\u043E \u0432 \u044D\u0442\u043E\u0439 \u0432\u0435\u0440\u0441\u0438\u0438"
          },
          report_issues: {
            title: "\u0421\u043E\u043E\u0431\u0449\u0438\u0442\u044C \u043E \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u0435",
            description: "\u041D\u0430\u0448\u043B\u0438 \u043E\u0448\u0438\u0431\u043A\u0443? \u0414\u0430\u0439\u0442\u0435 \u043D\u0430\u043C \u0437\u043D\u0430\u0442\u044C"
          },
          community_forum: {
            title: "\u0424\u043E\u0440\u0443\u043C \u0441\u043E\u043E\u0431\u0449\u0435\u0441\u0442\u0432\u0430",
            description: "\u041F\u0440\u0438\u0441\u043E\u0435\u0434\u0438\u043D\u044F\u0439\u0442\u0435\u0441\u044C \u043A \u043E\u0431\u0441\u0443\u0436\u0434\u0435\u043D\u0438\u044E"
          }
        },
        buttons: {
          get_started: "\u041D\u0430\u0447\u0430\u0442\u044C"
        }
      },
      notices: {
        import_analyzing: "\u0410\u043D\u0430\u043B\u0438\u0437 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 \u0438\u0437 {{count}} \u0444\u0430\u0439\u043B(\u043E\u0432)...",
        import_no_new: "\u041D\u043E\u0432\u044B\u0445 \u0438\u043B\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0451\u043D\u043D\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E. \u0412\u0441\u0435 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B \u0443\u0436\u0435 \u0430\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u044B.",
        import_starting: "\u0418\u043C\u043F\u043E\u0440\u0442 {{count}} \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 ({{new}} \u043D\u043E\u0432\u044B\u0445, {{updated}} \u043E\u0431\u043D\u043E\u0432\u043B\u0451\u043D\u043D\u044B\u0445)...",
        import_starting_selected: "\u0418\u043C\u043F\u043E\u0440\u0442 {{count}} \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432 \u0438\u0437 {{files}} \u0444\u0430\u0439\u043B(\u043E\u0432)...",
        import_completed_fallback: "\u0418\u043C\u043F\u043E\u0440\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043D. {{created}} \u0441\u043E\u0437\u0434\u0430\u043D\u043E, {{updated}} \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E.",
        import_error: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0430: {{error}}",
        import_error_analyzing: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0430\u043D\u0430\u043B\u0438\u0437\u0430 \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u043E\u0432: {{error}}",
        import_error_file: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438 {{filename}}. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438.",
        import_no_selected: "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D\u044B \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B \u0434\u043B\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0430.",
        import_no_zip_gemini: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0445\u043E\u0442\u044F \u0431\u044B \u043E\u0434\u0438\u043D ZIP-\u0444\u0430\u0439\u043B Gemini Takeout (\u043F\u043B\u044E\u0441 \u043D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0439 JSON-\u0438\u043D\u0434\u0435\u043A\u0441 \u0438\u0437 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F).",
        import_no_zip: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0445\u043E\u0442\u044F \u0431\u044B \u043E\u0434\u0438\u043D ZIP-\u0444\u0430\u0439\u043B \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0430.",
        import_gemini_json_failed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C JSON-\u0438\u043D\u0434\u0435\u043A\u0441 Gemini. \u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0435\u043D\u0438\u0435 \u0431\u0435\u0437 \u0438\u043D\u0434\u0435\u043A\u0441\u0430.",
        report_failed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0436\u0443\u0440\u043D\u0430\u043B\u0430. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438.",
        attachment_map_failed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u0443 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u0439. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C \u0434\u043B\u044F \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438.",
        ribbon_tooltip: "Nexus AI Chat Importer \u2014 \u0438\u043C\u043F\u043E\u0440\u0442 \u043D\u043E\u0432\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430"
      },
      commands: {
        import_conversations: {
          name: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0440\u0430\u0437\u0433\u043E\u0432\u043E\u0440\u044B \u0418\u0418"
        }
      },
      support_box: {
        header: "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D",
        header_highlight: "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D",
        default_message_emphasis: "\u042F \u0440\u0430\u0431\u043E\u0442\u0430\u044E \u043D\u0430\u0434 \u043F\u0440\u043E\u0435\u043A\u0442\u0430\u043C\u0438 Nexus \u043D\u0430 \u043F\u043E\u043B\u043D\u0443\u044E \u0441\u0442\u0430\u0432\u043A\u0443, \u0431\u0443\u0434\u0443\u0447\u0438 \u0431\u0435\u0437\u0440\u0430\u0431\u043E\u0442\u043D\u044B\u043C \u0438 \u0431\u043E\u0440\u044F\u0441\u044C \u0441 \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u0430\u043C\u0438 \u0441\u043E \u0437\u0434\u043E\u0440\u043E\u0432\u044C\u0435\u043C.",
        default_message: "\u0415\u0441\u043B\u0438 \u044D\u0442\u043E\u0442 \u043F\u043B\u0430\u0433\u0438\u043D \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442 \u0432\u0430\u0448\u0443 \u0436\u0438\u0437\u043D\u044C, \u043F\u043E\u0436\u0435\u0440\u0442\u0432\u043E\u0432\u0430\u043D\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u0434\u043B\u044F \u043C\u0435\u043D\u044F \u043E\u0447\u0435\u043D\u044C \u0437\u043D\u0430\u0447\u0438\u043C\u044B\u043C \u0438 \u043F\u043E\u043C\u043E\u0436\u0435\u0442 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442\u044B \u0432 \u0440\u0430\u0431\u043E\u0447\u0435\u043C \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0438.",
        reality_check: "\u0421\u043F\u0430\u0441\u0438\u0431\u043E! \u041D\u0430 \u044D\u0442\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u044B \u0443\u0448\u043B\u0438 \u0442\u044B\u0441\u044F\u0447\u0438 \u0447\u0430\u0441\u043E\u0432 \u0440\u0430\u0431\u043E\u0442\u044B, \u0438 \u043A\u0430\u0436\u0434\u043E\u0435 \u043F\u043E\u0436\u0435\u0440\u0442\u0432\u043E\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u043C\u043E\u0433\u0430\u0435\u0442 \u043C\u043D\u0435 \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0430\u0442\u044C \u0438\u0445 \u0443\u043B\u0443\u0447\u0448\u0430\u0442\u044C, \u0441\u043F\u0440\u0430\u0432\u043B\u044F\u044F\u0441\u044C \u0441 \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u0430\u043C\u0438 \u0441\u043E \u0437\u0434\u043E\u0440\u043E\u0432\u044C\u0435\u043C. \u0415\u0441\u043B\u0438 \u044D\u0442\u043E\u0442 \u043F\u043B\u0430\u0433\u0438\u043D \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442 \u0432\u0430\u0448\u0443 \u0436\u0438\u0437\u043D\u044C, \u043F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0440\u0430\u0441\u0441\u043C\u043E\u0442\u0440\u0438\u0442\u0435 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0438.",
        button_alt: "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043C\u043E\u044E \u0440\u0430\u0431\u043E\u0442\u0443"
      }
    };
  }
});

// src/i18n/locales/zh.json
var zh_default;
var init_zh = __esm({
  "src/i18n/locales/zh.json"() {
    zh_default = {
      common: {
        buttons: {
          cancel: "\u53D6\u6D88",
          ok: "\u786E\u5B9A",
          select: "\u9009\u62E9",
          browse: "\u6D4F\u89C8",
          continue: "\u7EE7\u7EED",
          proceed: "\u6267\u884C",
          close: "\u77E5\u9053\u4E86\uFF01",
          create: "\u521B\u5EFA",
          remove: "\u79FB\u9664",
          run: "\u8FD0\u884C",
          complete: "\u5B8C\u6210",
          view_report: "\u67E5\u770B\u62A5\u544A",
          get_started: "\u5F00\u59CB\u4F7F\u7528",
          create_new_folder: "\u65B0\u5EFA\u6587\u4EF6\u5939"
        },
        status: {
          new: "\u65B0\u5EFA",
          updated: "\u5DF2\u66F4\u65B0",
          unchanged: "\u672A\u53D8\u66F4",
          unknown: "\u672A\u77E5"
        },
        progress: {
          phase_validation: "\u{1F50D} \u9A8C\u8BC1",
          phase_scanning: "\u{1F4CB} \u626B\u63CF",
          phase_processing: "\u2699\uFE0F \u5904\u7406",
          phase_writing: "\u{1F4BE} \u5199\u5165",
          phase_complete: "\u2705 \u5B8C\u6210",
          phase_error: "\u274C \u9519\u8BEF"
        }
      },
      provider_selection: {
        title: "\u9009\u62E9\u5B58\u6863\u6765\u6E90",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "OpenAI ChatGPT \u5BF9\u8BDD\u5BFC\u51FA"
          },
          claude: {
            name: "Claude",
            description: "Anthropic Claude \u5BF9\u8BDD\u5BFC\u51FA"
          },
          lechat: {
            name: "Le Chat",
            description: "Mistral AI Le Chat \u5BF9\u8BDD\u5BFC\u51FA"
          }
        },
        buttons: {
          select: "\u9009\u62E9",
          cancel: "\u53D6\u6D88"
        }
      },
      file_selection: {
        title: "\u5BFC\u5165 {{provider}} \u5BF9\u8BDD",
        import_mode: {
          section_title: "\u5BFC\u5165\u6A21\u5F0F",
          all_label: "\u5168\u90E8\u5BFC\u5165",
          all_description: "\u5BFC\u5165\u6240\u6709\u5BF9\u8BDD\uFF08\u901F\u5EA6\u66F4\u5FEB\uFF09",
          selective_label: "\u9009\u62E9\u6027\u5BFC\u5165",
          selective_description: "\u9884\u89C8\u5E76\u9009\u62E9\u8981\u5BFC\u5165\u7684\u5BF9\u8BDD"
        },
        file_area: {
          section_title: "\u9009\u62E9\u6587\u4EF6",
          drop_text_default: "\u5C06 ZIP \u6587\u4EF6\u62D6\u653E\u81F3\u6B64\u5904\uFF0C\u6216\u70B9\u51FB\u6D4F\u89C8",
          drop_text_gemini: "\u5C06 ZIP \u548C JSON \u6587\u4EF6\u62D6\u653E\u81F3\u6B64\u5904\uFF0C\u6216\u70B9\u51FB\u6D4F\u89C8",
          drop_subtext_default: "\u652F\u6301\u591A\u6587\u4EF6\u9009\u62E9",
          drop_subtext_gemini: "ZIP\uFF08Takeout\uFF09+ \u53EF\u9009 JSON\uFF08\u6765\u81EA\u6269\u5C55\u7684\u7D22\u5F15\uFF09"
        },
        selected_files: {
          section_title: "\u5DF2\u9009\u6587\u4EF6",
          remove_button: "\u79FB\u9664"
        },
        buttons: {
          cancel: "\u53D6\u6D88",
          continue: "\u7EE7\u7EED"
        }
      },
      conversation_selection: {
        title: "\u9009\u62E9\u8981\u5BFC\u5165\u7684\u5BF9\u8BDD",
        controls: {
          select_all: "\u5168\u9009",
          select_none: "\u53D6\u6D88\u5168\u9009",
          search_placeholder: "\u641C\u7D22\u5BF9\u8BDD...",
          status_label: "\u72B6\u6001\uFF1A",
          show_label: "\u663E\u793A\uFF1A"
        },
        status_filter_options: {
          all: "\u5168\u90E8",
          new: "\u65B0\u5EFA",
          updated: "\u5DF2\u66F4\u65B0",
          unchanged: "\u672A\u53D8\u66F4"
        },
        table_headers: {
          title: "\u6807\u9898",
          created: "\u521B\u5EFA\u65F6\u95F4",
          updated: "\u66F4\u65B0\u65F6\u95F4",
          messages: "\u6D88\u606F\u6570",
          status: "\u72B6\u6001"
        },
        status_badges: {
          new: "\u65B0\u5EFA",
          updated: "\u5DF2\u66F4\u65B0",
          unchanged: "\u672A\u53D8\u66F4",
          unknown: "\u672A\u77E5",
          tooltip_new: "\u6B64\u5BF9\u8BDD\u4E0D\u5728\u60A8\u7684 Vault \u4E2D",
          tooltip_updated: "\u6B64\u5BF9\u8BDD\u7684\u5185\u5BB9\u6BD4\u60A8 Vault \u4E2D\u7684\u7248\u672C\u66F4\u65B0\uFF08{{existing_date}} \u2192 {{new_date}}\uFF09",
          tooltip_unchanged: "\u6B64\u5BF9\u8BDD\u4E0E\u60A8 Vault \u4E2D\u7684\u7248\u672C\u76F8\u540C"
        },
        pagination: {
          showing: "\u663E\u793A\u7B2C {{start}}\u2013{{end}} \u6761\uFF0C\u5171 {{total}} \u6761\u5BF9\u8BDD",
          page_of: "\u7B2C {{current}} \u9875\uFF0C\u5171 {{total}} \u9875",
          previous: "\u4E0A\u4E00\u9875",
          next: "\u4E0B\u4E00\u9875"
        },
        summary: {
          unique_conversations: "\u552F\u4E00\u5BF9\u8BDD",
          new: "\u65B0\u5EFA",
          updated: "\u5DF2\u66F4\u65B0",
          unchanged: "\u672A\u53D8\u66F4",
          selected_of: "\u5DF2\u9009 {{selected}} / {{total}}"
        },
        buttons: {
          cancel: "\u53D6\u6D88",
          import_selected: "\u5BFC\u5165\u5DF2\u9009",
          import_selected_count: "\u5BFC\u5165\u5DF2\u9009 {{count}} \u6761"
        },
        date_unknown: "\u672A\u77E5"
      },
      import_progress: {
        title: "\u6B63\u5728\u5BFC\u5165 {{filename}}",
        initial: {
          title: "\u6B63\u5728\u51C6\u5907\u5BFC\u5165...",
          detail: "\u6B63\u5728\u9A8C\u8BC1 ZIP \u6587\u4EF6\u7ED3\u6784"
        },
        conversation_counter: "{{current}}/{{total}} \u6761\u5BF9\u8BDD",
        conversation_counter_selective: "{{current}}/{{total}} \u6761\u5DF2\u9009\u5BF9\u8BDD",
        selective_mode_indicator: "\u{1F4CB} \u9009\u62E9\u6027\u5BFC\u5165\uFF1A{{total}} \u6761\u4E2D\u5DF2\u9009 {{selected}} \u6761",
        complete: {
          message: "\u5BFC\u5165\u5DF2\u6210\u529F\u5B8C\u6210",
          detail: "\u60A8\u53EF\u4EE5\u5173\u95ED\u6B64\u5BF9\u8BDD\u6846"
        },
        error: {
          message: "\u5BFC\u5165\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF",
          detail: "\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u7EC6\u4FE1\u606F"
        }
      },
      import_completion: {
        title: "\u5BFC\u5165\u5B8C\u6210",
        success_message: "\u2705 \u5BF9\u8BDD\u5DF2\u6210\u529F\u5BFC\u5165",
        stats: {
          zip_files_processed: "\u5DF2\u5904\u7406 ZIP \u6587\u4EF6",
          unique_conversations: "\u552F\u4E00\u5BF9\u8BDD",
          duplicates: "\u91CD\u590D",
          new: "\u65B0\u5EFA",
          updated: "\u5DF2\u66F4\u65B0",
          skipped: "\u5DF2\u8DF3\u8FC7",
          failed: "\u5931\u8D25"
        },
        attachments: {
          label: "\u9644\u4EF6\uFF1A",
          summary: "{{found}}/{{total}} \u5DF2\u63D0\u53D6\uFF08{{percentage}}%\uFF09",
          missing_failed: "{{missing}} \u7F3A\u5931\uFF0C{{failed}} \u5931\u8D25"
        },
        report: {
          label: "\u{1F4C4} \u8BE6\u7EC6\u62A5\u544A\uFF1A"
        },
        buttons: {
          view_report: "\u67E5\u770B\u62A5\u544A",
          ok: "\u786E\u5B9A"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} \u6587\u4EF6\u5939\u7ED3\u6784",
          conversation_folder: {
            name: "\u5BF9\u8BDD\u6587\u4EF6\u5939",
            desc: "\u5BFC\u5165\u7684\u5BF9\u8BDD\u5B58\u653E\u4F4D\u7F6E",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "\u6D4F\u89C8\u6587\u4EF6\u5939\u6216\u65B0\u5EFA\u6587\u4EF6\u5939"
          },
          reports_folder: {
            name: "\u62A5\u544A\u6587\u4EF6\u5939",
            desc: "\u5BFC\u5165\u62A5\u544A\u5B58\u653E\u4F4D\u7F6E",
            placeholder: "Nexus Reports",
            browse_tooltip: "\u6D4F\u89C8\u6587\u4EF6\u5939\u6216\u65B0\u5EFA\u6587\u4EF6\u5939"
          },
          attachment_folder: {
            name: "\u9644\u4EF6\u6587\u4EF6\u5939",
            desc: "\u9644\u4EF6\u5B58\u653E\u4F4D\u7F6E\uFF08\u26A0\uFE0F \u8BF7\u5C06\u5176\u6392\u9664\u5728\u540C\u6B65\u8303\u56F4\u4E4B\u5916\u4EE5\u8282\u7701\u7A7A\u95F4\uFF09",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "\u6D4F\u89C8\u6587\u4EF6\u5939\u6216\u65B0\u5EFA\u6587\u4EF6\u5939"
          }
        },
        display: {
          section_title: "\u{1F4C5} \u65E5\u671F\u524D\u7F00",
          add_date_prefix: {
            name: "\u4E3A\u6587\u4EF6\u540D\u6DFB\u52A0\u65E5\u671F\u524D\u7F00",
            desc: "\u5C06\u521B\u5EFA\u65E5\u671F\u4F5C\u4E3A\u524D\u7F00\u6DFB\u52A0\u5230\u5BF9\u8BDD\u6587\u4EF6\u540D",
            format_label: "\u9009\u62E9\u65E5\u671F\u683C\u5F0F\uFF1A"
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} \u6D88\u606F\u65E5\u671F\u683C\u5F0F",
          custom_format: {
            name: "\u81EA\u5B9A\u4E49\u6D88\u606F\u65F6\u95F4\u6233\u683C\u5F0F",
            desc: "\u8986\u76D6\u6D88\u606F\u6807\u9898\u4E2D\u9ED8\u8BA4\u7684\u57FA\u4E8E\u533A\u57DF\u8BBE\u7F6E\u7684\u65F6\u95F4\u6233\u683C\u5F0F\u3002\u7981\u7528\u65F6\uFF0C\u65F6\u95F4\u6233\u9075\u5FAA Obsidian \u7684\u8BED\u8A00\u8BBE\u7F6E\u3002\u82E5 Obsidian \u8BBE\u7F6E\u4E3A\u82F1\u8BED\uFF0C\u5219\u5F3A\u5236\u4F7F\u7528\u7F8E\u56FD\u683C\u5F0F\uFF08YYYY/DD/MM\uFF09\u3002"
          },
          timestamp_format: {
            name: "\u65F6\u95F4\u6233\u683C\u5F0F",
            desc: "\u9009\u62E9\u5BF9\u8BDD\u7B14\u8BB0\u4E2D\u6D88\u606F\u65F6\u95F4\u6233\u7684\u683C\u5F0F"
          },
          preview_label: "\u9884\u89C8\uFF1A"
        },
        attachments: {
          section_title: "\u9644\u4EF6\u8BBE\u7F6E",
          import_attachments: {
            name: "\u5BFC\u5165\u9644\u4EF6",
            desc: "\u5C06\u9644\u4EF6\u6587\u4EF6\u4FDD\u5B58\u5230\u78C1\u76D8\u5E76\u5728\u5BF9\u8BDD\u4E2D\u94FE\u63A5\uFF08\u91C7\u7528\u201C\u5C3D\u529B\u800C\u4E3A\u201D\u7B56\u7565\uFF09"
          },
          handle_missing: {
            name: "\u5904\u7406\u7F3A\u5931\u9644\u4EF6",
            desc: "\u5F53\u5BFC\u51FA\u4E2D\u7F3A\u5C11\u9644\u4EF6\u65F6\uFF0C\u521B\u5EFA\u63D0\u793A\u6027\u7B14\u8BB0\u800C\u975E\u76F4\u63A5\u8DF3\u8FC7"
          },
          show_details: {
            name: "\u5728\u62A5\u544A\u4E2D\u663E\u793A\u9644\u4EF6\u8BE6\u60C5",
            desc: "\u5728\u5BFC\u5165\u62A5\u544A\u4E2D\u5305\u542B\u8BE6\u7EC6\u7684\u9644\u4EF6\u5904\u7406\u7EDF\u8BA1\u4FE1\u606F"
          },
          info_box: {
            title: "\u{1F4CE} \u5173\u4E8E\u9644\u4EF6\u5904\u7406",
            best_effort: "\u5C3D\u529B\u800C\u4E3A\u7B56\u7565\uFF1A\u5BFC\u51FA\u4E2D\u627E\u5230\u7684\u6587\u4EF6\u5C06\u88AB\u63D0\u53D6\u5E76\u94FE\u63A5\uFF1B\u7F3A\u5931\u7684\u6587\u4EF6\u5C06\u751F\u6210\u63D0\u793A\u6027\u7B14\u8BB0\u3002",
            platform_diff: "\u5E73\u53F0\u5DEE\u5F02\uFF1AChatGPT \u5BFC\u51FA\u53EF\u80FD\u4E0D\u5305\u542B\u6240\u6709\u9644\u4EF6\uFF0C\u5C24\u5176\u662F\u6765\u81EA\u8F83\u65E9\u5BF9\u8BDD\u7684\u9644\u4EF6\u3002",
            organization: "\u7B80\u5355\u6574\u7406\uFF1A\u6587\u4EF6\u6309 attachments/provider/category/ \u7ED3\u6784\u7EC4\u7EC7\uFF08\u5982 attachments/chatgpt/images/\uFF09\u3002",
            sync_tip: "\u540C\u6B65\u63D0\u793A\uFF1A\u5EFA\u8BAE\u5C06\u9644\u4EF6\u6587\u4EF6\u5939\u6392\u9664\u5728\u540C\u6B65\u8303\u56F4\u4E4B\u5916\uFF0C\u4EE5\u907F\u514D\u4E0A\u4F20\u5927\u6587\u4EF6\u3002",
            tip: '\u{1F4A1} \u63D0\u793A\uFF1A\u542F\u7528"\u663E\u793A\u9644\u4EF6\u8BE6\u60C5"\u53EF\u7CBE\u786E\u67E5\u770B\u5BFC\u5165\u65F6\u54EA\u4E9B\u6587\u4EF6\u88AB\u627E\u5230\u3001\u7F3A\u5931\u6216\u5931\u8D25\u3002'
          }
        },
        migrations: {
          section_title: "\u6570\u636E\u8FC1\u79FB",
          description_manual: "\u624B\u52A8\u64CD\u4F5C\uFF1A\u53EF\u5728\u65B9\u4FBF\u65F6\u8FD0\u884C\u7684\u53EF\u9009\u5347\u7EA7\u64CD\u4F5C\u3002",
          description_automatic: "\u81EA\u52A8\u64CD\u4F5C\uFF08\u5982\u5220\u9664\u65E7\u6570\u636E\uFF09\u5728\u5347\u7EA7\u671F\u95F4\u81EA\u52A8\u8FD0\u884C\uFF0C\u6B64\u5904\u4E0D\u663E\u793A\u3002",
          version_header: "\u7248\u672C {{version}}",
          no_migrations: {
            title: "\u6CA1\u6709\u53EF\u7528\u7684\u624B\u52A8\u64CD\u4F5C",
            desc: "\u6240\u6709\u5347\u7EA7\u64CD\u4F5C\u5747\u5DF2\u81EA\u52A8\u5B8C\u6210\u3002"
          },
          operation_completed_suffix: " \u2705 \u5DF2\u5B8C\u6210",
          buttons: {
            completed: "\u2705 \u5DF2\u5B8C\u6210",
            cannot_run: "\u65E0\u6CD5\u8FD0\u884C",
            run: "\u8FD0\u884C",
            running: "\u8FD0\u884C\u4E2D..."
          },
          tooltips: {
            completed: "\u6B64\u64CD\u4F5C\u5DF2\u5B8C\u6210",
            cannot_run: "\u6B64\u64CD\u4F5C\u7684\u524D\u63D0\u6761\u4EF6\u672A\u6EE1\u8DB3",
            run: "\u6267\u884C {{operation_name}}"
          },
          error_loading: "\u52A0\u8F7D\u8FC1\u79FB\u65F6\u51FA\u9519\uFF1A"
        },
        support: {
          section_title: "\u{1F49D} \u652F\u6301\u4E0E\u5E2E\u52A9",
          resources: {
            name: "\u{1F4DA} \u8D44\u6E90",
            desc: "\u6587\u6863\u3001\u53D1\u5E03\u8BF4\u660E\u53CA\u793E\u533A\u94FE\u63A5",
            documentation: "\u{1F4D6} \u6587\u6863",
            release_notes: "\u{1F4DD} \u7248\u672C\u8BF4\u660E",
            issues: "\u{1F41B} \u95EE\u9898\u53CD\u9988",
            forum: "\u{1F4AC} \u8BBA\u575B"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "\u6B63\u5728\u542F\u52A8...",
          progress_label: "\u8FDB\u5EA6\uFF1A{{percentage}}%",
          step_label: "\u6B65\u9AA4 {{current}}/{{total}}",
          complete_label: "\u5DF2\u5B8C\u6210",
          complete_message: "\u5DF2\u6210\u529F\u5B8C\u6210",
          error_message: "\u53D1\u751F\u9519\u8BEF"
        },
        multi_operation_modal: {
          progress_label: "\u8FDB\u5EA6\uFF1A{{completed}}/{{total}} \u4E2A\u64CD\u4F5C",
          progress_with_failures: "\u8FDB\u5EA6\uFF1A{{completed}}/{{total}} \u4E2A\u64CD\u4F5C\uFF08{{failed}} \u4E2A\u5931\u8D25\uFF09",
          all_completed: "\u5168\u90E8 {{total}} \u4E2A\u64CD\u4F5C\u5DF2\u6210\u529F\u5B8C\u6210",
          mark_complete_default: "\u6240\u6709\u64CD\u4F5C\u5747\u5DF2\u6210\u529F\u5B8C\u6210",
          buttons: {
            complete: "\u5B8C\u6210",
            close: "\u5173\u95ED"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} \u9700\u8981\u8FC1\u79FB",
            message: "\u4EE5\u4E0B\u4EFB\u52A1\u5C06\u81EA\u52A8\u8FD0\u884C\uFF0C\u4EE5\u5C06\u60A8\u7684\u6570\u636E\u5347\u7EA7\u5230 v1.3.0\uFF1A",
            tasks: {
              folder_settings: "\u2713 \u5C06\u6587\u4EF6\u5939\u8BBE\u7F6E\u8FC1\u79FB\u5230\u65B0\u7ED3\u6784",
              timestamps: "\u2713 \u5C06\u65F6\u95F4\u6233\u66F4\u65B0\u4E3A ISO 8601 \u683C\u5F0F",
              aliases: "\u2713 \u4FEE\u590D frontmatter \u522B\u540D",
              reports: "\u2713 \u5C06\u62A5\u544A\u6587\u4EF6\u5939\u79FB\u81F3\u6B63\u786E\u4F4D\u7F6E",
              artifacts: "\u2713 \u66F4\u65B0 artifact \u5143\u6570\u636E"
            },
            estimate: "\u8FD9\u5C06\u9700\u8981\u51E0\u79D2\u949F\u3002"
          },
          buttons: {
            run_migration: "\u{1F680} \u8FD0\u884C\u8FC1\u79FB\u4EFB\u52A1"
          }
        },
        complete_modal: {
          title: "\u2705 \u5347\u7EA7\u5B8C\u6210 - v{{version}}",
          buttons: {
            got_it: "\u77E5\u9053\u4E86\uFF01"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "\u77E5\u9053\u4E86\uFF01"
          }
        }
      },
      folder_migration: {
        title: "\u79FB\u52A8\u73B0\u6709\u6587\u4EF6\uFF1F",
        message_intro: "\u60A8\u6B63\u5728\u66F4\u6539 {{folder_type}} \u6587\u4EF6\u5939\u7684\u4F4D\u7F6E\uFF1A",
        path_from: "\u4ECE\uFF1A{{path}}",
        path_to: "\u5230\uFF1A{{path}}",
        question: "\u662F\u5426\u5C06\u73B0\u6709\u6587\u4EF6\u79FB\u52A8\u5230\u65B0\u4F4D\u7F6E\uFF1F",
        link_updates: {
          title: "\u{1F517} \u94FE\u63A5\u66F4\u65B0\uFF1A",
          attachments_text: "\u79FB\u52A8\u9644\u4EF6\u65F6\uFF0C\u6240\u6709\u5F15\u7528\u8FD9\u4E9B\u9644\u4EF6\u7684\u5BF9\u8BDD\u7B14\u8BB0\u4E5F\u5C06\u540C\u6B65\u66F4\u65B0\u3002",
          conversations_text: "\u79FB\u52A8\u5BF9\u8BDD\u65F6\uFF0C\u6240\u6709\u5F15\u7528\u8FD9\u4E9B\u5BF9\u8BDD\u7684\u62A5\u544A\u548C\u9644\u4EF6\u4E5F\u5C06\u540C\u6B65\u66F4\u65B0\u3002",
          estimated_time_seconds: "\u9884\u8BA1\u65F6\u95F4\uFF1A\u7EA6 {{seconds}} \u79D2",
          estimated_time_minutes: "\u9884\u8BA1\u65F6\u95F4\uFF1A\u7EA6 {{minutes}} \u5206\u949F"
        },
        warning: {
          title: "\u26A0\uFE0F \u91CD\u8981\u63D0\u793A\uFF1A",
          text: "\u82E5\u9009\u62E9\u201C\u5426\u201D\uFF0C\u73B0\u6709\u6587\u4EF6\u5C06\u4FDD\u7559\u5728\u539F\u4F4D\u7F6E\uFF0C\u4E0D\u53D7\u672A\u6765\u66F4\u65B0\u7684\u5F71\u54CD\u3002"
        },
        buttons: {
          cancel: "\u53D6\u6D88",
          keep: "\u5426\uFF0C\u4FDD\u7559\u6587\u4EF6\u5728\u539F\u4F4D\u7F6E",
          move: "\u662F\uFF0C\u79FB\u52A8\u6587\u4EF6",
          move_with_links: "\u662F\uFF0C\u79FB\u52A8\u6587\u4EF6\u5E76\u66F4\u65B0\u94FE\u63A5"
        },
        progress: {
          title_moving: "\u6B63\u5728\u79FB\u52A8 {{folder_type}} \u5E76\u66F4\u65B0\u94FE\u63A5",
          step_moving_title: "\u6B63\u5728\u79FB\u52A8\u6587\u4EF6...",
          step_moving_detail: "\u4ECE {{old_path}} \u79FB\u52A8\u5230 {{new_path}}",
          step_moving_count: "\u5DF2\u5904\u7406 {{current}} / {{total}} \u4E2A\u6587\u4EF6",
          step_moved_title: "\u6587\u4EF6\u5DF2\u79FB\u52A8",
          step_moved_detail: "{{moved}} \u4E2A\u6587\u4EF6\u5DF2\u79FB\u52A8\uFF0C{{skipped}} \u4E2A\u5DF2\u8DF3\u8FC7\u3002\u6B63\u5728\u51C6\u5907\u66F4\u65B0\u94FE\u63A5...",
          step_updating_attachment_links: "\u6B63\u5728\u66F4\u65B0\u9644\u4EF6\u94FE\u63A5...",
          step_updating_conversation_links: "\u6B63\u5728\u66F4\u65B0\u5BF9\u8BDD\u94FE\u63A5...",
          step_updating_report_links: "\u6B63\u5728\u66F4\u65B0\u62A5\u544A\u4E2D\u7684\u94FE\u63A5...",
          step_updating_artifact_links: "\u6B63\u5728\u66F4\u65B0 artifact \u4E2D\u7684\u94FE\u63A5...",
          complete_message: "{{moved}} \u4E2A\u6587\u4EF6\u5DF2\u79FB\u52A8\u3002{{links}} \u4E2A\u94FE\u63A5\u5DF2\u6210\u529F\u66F4\u65B0"
        },
        result_dialog: {
          title: "\u6587\u4EF6\u5939\u8FC1\u79FB\u7ED3\u679C",
          summary_title: "\u8FC1\u79FB\u6458\u8981",
          moved: "\u2705 \u6210\u529F\u79FB\u52A8\uFF1A{{count}} \u4E2A\u6587\u4EF6",
          skipped: "\u26A0\uFE0F \u5DF2\u8DF3\u8FC7\uFF08\u5DF2\u5B58\u5728\uFF09\uFF1A{{count}} \u4E2A\u6587\u4EF6",
          errors: "\u274C \u9519\u8BEF\uFF1A{{count}} \u4E2A\u6587\u4EF6",
          explanation: "\u76EE\u6807\u4F4D\u7F6E\u5DF2\u5B58\u5728\u7684\u6587\u4EF6\u672A\u88AB\u8986\u76D6\uFF0C\u4EE5\u4FDD\u62A4\u60A8\u7684\u6570\u636E\u3002",
          error_details_title: "\u9519\u8BEF\u8BE6\u60C5\uFF1A"
        },
        error_target_not_empty: {
          title: "\u76EE\u6807\u6587\u4EF6\u5939\u975E\u7A7A",
          message: '\u6587\u4EF6\u5939"{{path}}"\u4E2D\u5DF2\u5305\u542B\u6587\u4EF6\u3002\n\n\u8981\u66F4\u6539\u6587\u4EF6\u5939\u4F4D\u7F6E\uFF0C\u8BF7\uFF1A\n\u2022 \u5728 Obsidian \u4E2D\u624B\u52A8\u79FB\u52A8\u73B0\u6709\u6587\u4EF6\uFF0C\u6216\n\u2022 \u9009\u62E9\u4E00\u4E2A\u7A7A\u6587\u4EF6\u5939\u6216\u65B0\u5EFA\u6587\u4EF6\u5939'
        },
        error_migration_failed: {
          title: "\u8FC1\u79FB\u5931\u8D25",
          message_move: "\u79FB\u52A8\u6587\u4EF6\u5931\u8D25\uFF1A{{error}}",
          message_links: "\u79FB\u52A8\u6587\u4EF6\u6216\u66F4\u65B0\u94FE\u63A5\u5931\u8D25\uFF1A{{error}}"
        }
      },
      folder_browser: {
        title: "\u9009\u62E9\u6587\u4EF6\u5939",
        vault_root: "Vault \u6839\u76EE\u5F55\uFF08/\uFF09",
        buttons: {
          create_new_folder: "\u65B0\u5EFA\u6587\u4EF6\u5939",
          cancel: "\u53D6\u6D88",
          select: "\u9009\u62E9"
        },
        create_folder_dialog: {
          title: "\u65B0\u5EFA\u6587\u4EF6\u5939",
          folder_name_label: "\u6587\u4EF6\u5939\u540D\u79F0\uFF1A",
          buttons: {
            cancel: "\u53D6\u6D88",
            create: "\u521B\u5EFA"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F \u8BF7\u5148\u9009\u62E9\u7236\u6587\u4EF6\u5939",
          invalid_name: "\u274C \u65E0\u6548\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF1A\u5305\u542B\u975E\u6CD5\u5B57\u7B26",
          already_exists: "\u274C \u6587\u4EF6\u5939\u5DF2\u5B58\u5728",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 \u5DF2\u521B\u5EFA\u6587\u4EF6\u5939\uFF1A{{name}}",
          create_failed: "\u274C \u521B\u5EFA\u6587\u4EF6\u5939\u5931\u8D25\uFF1A{{error}}",
          select_first: "\u26A0\uFE0F \u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u6587\u4EF6\u5939"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "\u5728 1.3.0 \u7248\u672C\u4E2D\uFF0C\u60A8\u53EF\u4EE5\u4E3A\u62A5\u544A\u6307\u5B9A\u4E13\u7528\u6587\u4EF6\u5939\u3002\u6211\u4EEC\u5C06\u628A\u73B0\u6709\u62A5\u544A\u79FB\u81F3 {{folder}}\uFF0C\u60A8\u4E5F\u53EF\u4EE5\u5728\u4E0B\u65B9\u9009\u62E9\u60A8\u504F\u597D\u7684\u6587\u4EF6\u5939\u3002",
        note: "\u6CE8\u610F\uFF1A\u8BE5\u6587\u4EF6\u5939\u4E0D\u80FD\u4F4D\u4E8E\u5BF9\u8BDD\u6216\u9644\u4EF6\u6587\u4EF6\u5939\u5185\u90E8\u3002",
        report_folder_label: "\u{1F4CA} \u62A5\u544A\u6587\u4EF6\u5939",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "\u6D4F\u89C8",
          proceed: "\u6267\u884C"
        },
        error_invalid_folder: {
          title: "\u65E0\u6548\u7684\u6587\u4EF6\u5939\u4F4D\u7F6E",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "\u611F\u8C22\u5B89\u88C5 Nexus AI Chat Importer\uFF01",
        description: "\u76F4\u63A5\u5728\u60A8\u7684 Obsidian Vault \u4E2D\u5BFC\u5165\u548C\u7BA1\u7406 ChatGPT\u3001Claude \u53CA Le Chat \u5BF9\u8BDD\u3002",
        resources_title: "\u8D44\u6E90",
        resources: {
          documentation: {
            title: "\u6587\u6863",
            description: "\u4E86\u89E3\u5982\u4F55\u4F7F\u7528\u6B64\u63D2\u4EF6"
          },
          release_notes: {
            title: "\u53D1\u5E03\u8BF4\u660E",
            description: "\u672C\u7248\u672C\u65B0\u589E\u5185\u5BB9"
          },
          report_issues: {
            title: "\u53CD\u9988\u95EE\u9898",
            description: "\u53D1\u73B0 bug\uFF1F\u8BF7\u544A\u77E5\u6211\u4EEC"
          },
          community_forum: {
            title: "\u793E\u533A\u8BBA\u575B",
            description: "\u52A0\u5165\u8BA8\u8BBA"
          }
        },
        buttons: {
          get_started: "\u5F00\u59CB\u4F7F\u7528"
        }
      },
      notices: {
        import_analyzing: "\u6B63\u5728\u5206\u6790\u6765\u81EA {{count}} \u4E2A\u6587\u4EF6\u7684\u5BF9\u8BDD...",
        import_no_new: "\u672A\u53D1\u73B0\u65B0\u7684\u6216\u5DF2\u66F4\u65B0\u7684\u5BF9\u8BDD\uFF0C\u6240\u6709\u5BF9\u8BDD\u5747\u5DF2\u662F\u6700\u65B0\u72B6\u6001\u3002",
        import_starting: "\u6B63\u5728\u5BFC\u5165 {{count}} \u6761\u5BF9\u8BDD\uFF08{{new}} \u6761\u65B0\u5EFA\uFF0C{{updated}} \u6761\u5DF2\u66F4\u65B0\uFF09...",
        import_starting_selected: "\u6B63\u5728\u4ECE {{files}} \u4E2A\u6587\u4EF6\u4E2D\u5BFC\u5165 {{count}} \u6761\u5DF2\u9009\u5BF9\u8BDD...",
        import_completed_fallback: "\u5BFC\u5165\u5B8C\u6210\u3002\u5DF2\u521B\u5EFA {{created}} \u6761\uFF0C\u5DF2\u66F4\u65B0 {{updated}} \u6761\u3002",
        import_error: "\u5BFC\u5165\u65F6\u53D1\u751F\u9519\u8BEF\uFF1A{{error}}",
        import_error_analyzing: "\u5206\u6790\u5BF9\u8BDD\u65F6\u53D1\u751F\u9519\u8BEF\uFF1A{{error}}",
        import_error_file: "\u5904\u7406 {{filename}} \u65F6\u53D1\u751F\u9519\u8BEF\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u7EC6\u4FE1\u606F\u3002",
        import_no_selected: "\u672A\u9009\u62E9\u8981\u5BFC\u5165\u7684\u5BF9\u8BDD\u3002",
        import_no_zip_gemini: "\u8BF7\u81F3\u5C11\u9009\u62E9\u4E00\u4E2A Gemini Takeout ZIP \u6587\u4EF6\uFF08\u4EE5\u53CA\u53EF\u9009\u7684\u6765\u81EA\u6269\u5C55\u7684 JSON \u7D22\u5F15\uFF09\u3002",
        import_no_zip: "\u8BF7\u81F3\u5C11\u9009\u62E9\u4E00\u4E2A ZIP \u5BFC\u51FA\u6587\u4EF6\u3002",
        import_gemini_json_failed: "\u8BFB\u53D6 Gemini \u7D22\u5F15 JSON \u5931\u8D25\uFF0C\u5C06\u5728\u4E0D\u4F7F\u7528\u7D22\u5F15\u7684\u60C5\u51B5\u4E0B\u7EE7\u7EED\u3002",
        report_failed: "\u521B\u5EFA\u65E5\u5FD7\u6587\u4EF6\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u7EC6\u4FE1\u606F\u3002",
        attachment_map_failed: "\u6784\u5EFA\u9644\u4EF6\u6620\u5C04\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u7EC6\u4FE1\u606F\u3002",
        ribbon_tooltip: "Nexus AI Chat Importer - \u5BFC\u5165\u65B0\u6587\u4EF6"
      },
      commands: {
        import_conversations: {
          name: "\u5BFC\u5165 AI \u5BF9\u8BDD"
        }
      },
      support_box: {
        header: "\u652F\u6301\u6B64\u63D2\u4EF6",
        header_highlight: "\u652F\u6301\u6B64\u63D2\u4EF6",
        default_message_emphasis: "\u6211\u5728\u5931\u4E1A\u5E76\u4E0E\u5065\u5EB7\u95EE\u9898\u6297\u4E89\u7684\u540C\u65F6\uFF0C\u5168\u804C\u6295\u5165\u4E8E Nexus \u9879\u76EE\u7684\u5F00\u53D1\u3002",
        default_message: "\u5982\u679C\u8FD9\u4E2A\u63D2\u4EF6\u8BA9\u60A8\u7684\u751F\u6D3B\u66F4\u4FBF\u6377\uFF0C\u4E00\u7B14\u6350\u6B3E\u5BF9\u6211\u610F\u4E49\u91CD\u5927\uFF0C\u4E5F\u5C06\u5E2E\u52A9\u8FD9\u4E9B\u9879\u76EE\u6301\u7EED\u8FD0\u8F6C\u3002",
        reality_check: "\u611F\u8C22\u60A8\uFF01\u8FD9\u4E9B\u63D2\u4EF6\u51DD\u805A\u4E86\u6570\u5343\u5C0F\u65F6\u7684\u5FC3\u8840\uFF0C\u6BCF\u4E00\u7B14\u6350\u6B3E\u90FD\u5E2E\u52A9\u6211\u5728\u5E94\u5BF9\u6301\u7EED\u5065\u5EB7\u95EE\u9898\u7684\u540C\u65F6\u4E0D\u65AD\u6539\u8FDB\u5B83\u4EEC\u3002\u5982\u679C\u8FD9\u4E2A\u63D2\u4EF6\u8BA9\u60A8\u7684\u751F\u6D3B\u66F4\u4FBF\u6377\uFF0C\u8BF7\u8003\u8651\u652F\u6301\u6211\u3002",
        button_alt: "\u652F\u6301\u6211\u7684\u5DE5\u4F5C"
      }
    };
  }
});

// src/i18n/locales/ja.json
var ja_default;
var init_ja = __esm({
  "src/i18n/locales/ja.json"() {
    ja_default = {
      common: {
        buttons: {
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
          ok: "OK",
          select: "\u9078\u629E",
          browse: "\u53C2\u7167",
          continue: "\u7D9A\u884C",
          proceed: "\u5B9F\u884C",
          close: "\u4E86\u89E3\uFF01",
          create: "\u4F5C\u6210",
          remove: "\u524A\u9664",
          run: "\u5B9F\u884C",
          complete: "\u5B8C\u4E86",
          view_report: "\u30EC\u30DD\u30FC\u30C8\u3092\u898B\u308B",
          get_started: "\u59CB\u3081\u308B",
          create_new_folder: "\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210"
        },
        status: {
          new: "\u65B0\u898F",
          updated: "\u66F4\u65B0\u6E08\u307F",
          unchanged: "\u5909\u66F4\u306A\u3057",
          unknown: "\u4E0D\u660E"
        },
        progress: {
          phase_validation: "\u{1F50D} \u691C\u8A3C",
          phase_scanning: "\u{1F4CB} \u30B9\u30AD\u30E3\u30F3",
          phase_processing: "\u2699\uFE0F \u51E6\u7406\u4E2D",
          phase_writing: "\u{1F4BE} \u66F8\u304D\u8FBC\u307F",
          phase_complete: "\u2705 \u5B8C\u4E86",
          phase_error: "\u274C \u30A8\u30E9\u30FC"
        }
      },
      provider_selection: {
        title: "\u30A2\u30FC\u30AB\u30A4\u30D6\u306E\u30D7\u30ED\u30D0\u30A4\u30C0\u30FC\u3092\u9078\u629E",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "OpenAI ChatGPT \u306E\u4F1A\u8A71\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8"
          },
          claude: {
            name: "Claude",
            description: "Anthropic Claude \u306E\u4F1A\u8A71\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8"
          },
          lechat: {
            name: "Le Chat",
            description: "Mistral AI Le Chat \u306E\u4F1A\u8A71\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8"
          }
        },
        buttons: {
          select: "\u9078\u629E",
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
        }
      },
      file_selection: {
        title: "{{provider}} \u306E\u4F1A\u8A71\u3092\u30A4\u30F3\u30DD\u30FC\u30C8",
        import_mode: {
          section_title: "\u30A4\u30F3\u30DD\u30FC\u30C8\u30E2\u30FC\u30C9",
          all_label: "\u3059\u3079\u3066\u30A4\u30F3\u30DD\u30FC\u30C8",
          all_description: "\u3059\u3079\u3066\u306E\u4F1A\u8A71\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3059\u308B\uFF08\u9AD8\u901F\uFF09",
          selective_label: "\u500B\u5225\u306B\u9078\u629E",
          selective_description: "\u4F1A\u8A71\u3092\u30D7\u30EC\u30D3\u30E5\u30FC\u3057\u3066\u9078\u629E\u3059\u308B"
        },
        file_area: {
          section_title: "\u30D5\u30A1\u30A4\u30EB\u3092\u9078\u629E",
          drop_text_default: "ZIP\u30D5\u30A1\u30A4\u30EB\u3092\u3053\u3053\u306B\u30C9\u30ED\u30C3\u30D7\u3059\u308B\u304B\u3001\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u53C2\u7167",
          drop_text_gemini: "ZIP\u30D5\u30A1\u30A4\u30EB\u307E\u305F\u306FJSON\u30D5\u30A1\u30A4\u30EB\u3092\u3053\u3053\u306B\u30C9\u30ED\u30C3\u30D7\u3059\u308B\u304B\u3001\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u53C2\u7167",
          drop_subtext_default: "\u8907\u6570\u30D5\u30A1\u30A4\u30EB\u306E\u9078\u629E\u306B\u5BFE\u5FDC",
          drop_subtext_gemini: "ZIP\uFF08Takeout\uFF09\uFF0B \u30AA\u30D7\u30B7\u30E7\u30F3\u306EJSON\uFF08\u62E1\u5F35\u6A5F\u80FD\u304B\u3089\u306E\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\uFF09"
        },
        selected_files: {
          section_title: "\u9078\u629E\u6E08\u307F\u30D5\u30A1\u30A4\u30EB",
          remove_button: "\u524A\u9664"
        },
        buttons: {
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
          continue: "\u7D9A\u884C"
        }
      },
      conversation_selection: {
        title: "\u30A4\u30F3\u30DD\u30FC\u30C8\u3059\u308B\u4F1A\u8A71\u3092\u9078\u629E",
        controls: {
          select_all: "\u3059\u3079\u3066\u9078\u629E",
          select_none: "\u9078\u629E\u89E3\u9664",
          search_placeholder: "\u4F1A\u8A71\u3092\u691C\u7D22...",
          status_label: "\u30B9\u30C6\u30FC\u30BF\u30B9\uFF1A",
          show_label: "\u8868\u793A\uFF1A"
        },
        status_filter_options: {
          all: "\u3059\u3079\u3066",
          new: "\u65B0\u898F",
          updated: "\u66F4\u65B0\u6E08\u307F",
          unchanged: "\u5909\u66F4\u306A\u3057"
        },
        table_headers: {
          title: "\u30BF\u30A4\u30C8\u30EB",
          created: "\u4F5C\u6210\u65E5",
          updated: "\u66F4\u65B0\u65E5",
          messages: "\u30E1\u30C3\u30BB\u30FC\u30B8\u6570",
          status: "\u30B9\u30C6\u30FC\u30BF\u30B9"
        },
        status_badges: {
          new: "\u65B0\u898F",
          updated: "\u66F4\u65B0\u6E08\u307F",
          unchanged: "\u5909\u66F4\u306A\u3057",
          unknown: "\u4E0D\u660E",
          tooltip_new: "\u3053\u306E\u4F1A\u8A71\u306FVault\u306B\u5B58\u5728\u3057\u307E\u305B\u3093",
          tooltip_updated: "\u3053\u306E\u4F1A\u8A71\u306FVault\u5185\u306E\u30D0\u30FC\u30B8\u30E7\u30F3\u3088\u308A\u65B0\u3057\u3044\u5185\u5BB9\u3092\u542B\u3093\u3067\u3044\u307E\u3059\uFF08{{existing_date}} \u2192 {{new_date}}\uFF09",
          tooltip_unchanged: "\u3053\u306E\u4F1A\u8A71\u306FVault\u5185\u306E\u30D0\u30FC\u30B8\u30E7\u30F3\u3068\u540C\u3058\u3067\u3059"
        },
        pagination: {
          showing: "{{total}} \u4EF6\u4E2D {{start}}\u2013{{end}} \u4EF6\u3092\u8868\u793A",
          page_of: "{{total}} \u30DA\u30FC\u30B8\u4E2D {{current}} \u30DA\u30FC\u30B8",
          previous: "\u524D\u3078",
          next: "\u6B21\u3078"
        },
        summary: {
          unique_conversations: "\u56FA\u6709\u306E\u4F1A\u8A71",
          new: "\u65B0\u898F",
          updated: "\u66F4\u65B0\u6E08\u307F",
          unchanged: "\u5909\u66F4\u306A\u3057",
          selected_of: "{{total}} \u4EF6\u4E2D {{selected}} \u4EF6\u3092\u9078\u629E"
        },
        buttons: {
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
          import_selected: "\u9078\u629E\u6E08\u307F\u3092\u30A4\u30F3\u30DD\u30FC\u30C8",
          import_selected_count: "\u9078\u629E\u3057\u305F {{count}} \u4EF6\u3092\u30A4\u30F3\u30DD\u30FC\u30C8"
        },
        date_unknown: "\u4E0D\u660E"
      },
      import_progress: {
        title: "{{filename}} \u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u4E2D",
        initial: {
          title: "\u30A4\u30F3\u30DD\u30FC\u30C8\u3092\u6E96\u5099\u4E2D...",
          detail: "ZIP\u30D5\u30A1\u30A4\u30EB\u306E\u69CB\u9020\u3092\u691C\u8A3C\u3057\u3066\u3044\u307E\u3059"
        },
        conversation_counter: "{{current}}/{{total}} \u4EF6\u306E\u4F1A\u8A71",
        conversation_counter_selective: "{{current}}/{{total}} \u4EF6\u306E\u9078\u629E\u6E08\u307F\u4F1A\u8A71",
        selective_mode_indicator: "\u{1F4CB} \u9078\u629E\u30A4\u30F3\u30DD\u30FC\u30C8\uFF1A{{total}} \u4EF6\u4E2D {{selected}} \u4EF6",
        complete: {
          message: "\u30A4\u30F3\u30DD\u30FC\u30C8\u304C\u6B63\u5E38\u306B\u5B8C\u4E86\u3057\u307E\u3057\u305F",
          detail: "\u3053\u306E\u30C0\u30A4\u30A2\u30ED\u30B0\u3092\u9589\u3058\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059"
        },
        error: {
          message: "\u30A4\u30F3\u30DD\u30FC\u30C8\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F",
          detail: "\u8A73\u7D30\u306F\u30B3\u30F3\u30BD\u30FC\u30EB\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044"
        }
      },
      import_completion: {
        title: "\u30A4\u30F3\u30DD\u30FC\u30C8\u5B8C\u4E86",
        success_message: "\u2705 \u4F1A\u8A71\u304C\u6B63\u5E38\u306B\u30A4\u30F3\u30DD\u30FC\u30C8\u3055\u308C\u307E\u3057\u305F",
        stats: {
          zip_files_processed: "\u51E6\u7406\u6E08\u307FZIP\u30D5\u30A1\u30A4\u30EB",
          unique_conversations: "\u56FA\u6709\u306E\u4F1A\u8A71",
          duplicates: "\u91CD\u8907",
          new: "\u65B0\u898F",
          updated: "\u66F4\u65B0\u6E08\u307F",
          skipped: "\u30B9\u30AD\u30C3\u30D7\u6E08\u307F",
          failed: "\u5931\u6557"
        },
        attachments: {
          label: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\uFF1A",
          summary: "{{found}}/{{total}} \u4EF6\u3092\u62BD\u51FA\uFF08{{percentage}}%\uFF09",
          missing_failed: "{{missing}} \u4EF6\u6B20\u843D\u3001{{failed}} \u4EF6\u5931\u6557"
        },
        report: {
          label: "\u{1F4C4} \u8A73\u7D30\u30EC\u30DD\u30FC\u30C8\uFF1A"
        },
        buttons: {
          view_report: "\u30EC\u30DD\u30FC\u30C8\u3092\u898B\u308B",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} \u30D5\u30A9\u30EB\u30C0\u30FC\u69CB\u9020",
          conversation_folder: {
            name: "\u4F1A\u8A71\u30D5\u30A9\u30EB\u30C0\u30FC",
            desc: "\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u305F\u4F1A\u8A71\u306E\u4FDD\u5B58\u5148",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u53C2\u7167\u3059\u308B\u304B\u3001\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210"
          },
          reports_folder: {
            name: "\u30EC\u30DD\u30FC\u30C8\u30D5\u30A9\u30EB\u30C0\u30FC",
            desc: "\u30A4\u30F3\u30DD\u30FC\u30C8\u30EC\u30DD\u30FC\u30C8\u306E\u4FDD\u5B58\u5148",
            placeholder: "Nexus Reports",
            browse_tooltip: "\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u53C2\u7167\u3059\u308B\u304B\u3001\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210"
          },
          attachment_folder: {
            name: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u30D5\u30A9\u30EB\u30C0\u30FC",
            desc: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u4FDD\u5B58\u5148\uFF08\u26A0\uFE0F \u5BB9\u91CF\u7BC0\u7D04\u306E\u305F\u3081\u540C\u671F\u304B\u3089\u9664\u5916\u3059\u308B\u3053\u3068\u3092\u63A8\u5968\uFF09",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u53C2\u7167\u3059\u308B\u304B\u3001\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210"
          }
        },
        display: {
          section_title: "\u{1F4C5} \u65E5\u4ED8\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9",
          add_date_prefix: {
            name: "\u30D5\u30A1\u30A4\u30EB\u540D\u306B\u65E5\u4ED8\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9\u3092\u8FFD\u52A0",
            desc: "\u4F1A\u8A71\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u5148\u982D\u306B\u4F5C\u6210\u65E5\u3092\u4ED8\u52A0\u3059\u308B",
            format_label: "\u65E5\u4ED8\u5F62\u5F0F\u3092\u9078\u629E\uFF1A"
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} \u30E1\u30C3\u30BB\u30FC\u30B8\u306E\u65E5\u4ED8\u5F62\u5F0F",
          custom_format: {
            name: "\u30E1\u30C3\u30BB\u30FC\u30B8\u306E\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u5F62\u5F0F\u3092\u30AB\u30B9\u30BF\u30DE\u30A4\u30BA",
            desc: "\u30E1\u30C3\u30BB\u30FC\u30B8\u30D8\u30C3\u30C0\u30FC\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30ED\u30B1\u30FC\u30EB\u30D9\u30FC\u30B9\u306E\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u5F62\u5F0F\u3092\u4E0A\u66F8\u304D\u3057\u307E\u3059\u3002\u7121\u52B9\u306E\u5834\u5408\u3001\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u306F Obsidian \u306E\u8A00\u8A9E\u8A2D\u5B9A\u306B\u5F93\u3044\u307E\u3059\u3002Obsidian \u304C\u82F1\u8A9E\u306B\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u308B\u5834\u5408\u3001US\u5F62\u5F0F\uFF08YYYY/DD/MM\uFF09\u304C\u9069\u7528\u3055\u308C\u307E\u3059\u3002"
          },
          timestamp_format: {
            name: "\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u5F62\u5F0F",
            desc: "\u4F1A\u8A71\u30CE\u30FC\u30C8\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u306E\u5F62\u5F0F\u3092\u9078\u629E"
          },
          preview_label: "\u30D7\u30EC\u30D3\u30E5\u30FC\uFF1A"
        },
        attachments: {
          section_title: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u8A2D\u5B9A",
          import_attachments: {
            name: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u3092\u30A4\u30F3\u30DD\u30FC\u30C8",
            desc: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u3092\u30C7\u30A3\u30B9\u30AF\u306B\u4FDD\u5B58\u3057\u3001\u4F1A\u8A71\u5185\u3067\u30EA\u30F3\u30AF\u3057\u307E\u3059\uFF08\u300C\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u300D\u65B9\u5F0F\uFF09"
          },
          handle_missing: {
            name: "\u6B20\u843D\u3057\u305F\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u3092\u51E6\u7406",
            desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u304C\u542B\u307E\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u30B9\u30AD\u30C3\u30D7\u305B\u305A\u306B\u60C5\u5831\u30CE\u30FC\u30C8\u3092\u4F5C\u6210\u3059\u308B"
          },
          show_details: {
            name: "\u30EC\u30DD\u30FC\u30C8\u306B\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u8A73\u7D30\u3092\u8868\u793A",
            desc: "\u30A4\u30F3\u30DD\u30FC\u30C8\u30EC\u30DD\u30FC\u30C8\u306B\u8A73\u7D30\u306A\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u51E6\u7406\u306E\u7D71\u8A08\u3092\u542B\u3081\u308B"
          },
          info_box: {
            title: "\u{1F4CE} \u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u51E6\u7406\u306B\u3064\u3044\u3066",
            best_effort: "\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u65B9\u5F0F\uFF1A\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3067\u898B\u3064\u304B\u3063\u305F\u30D5\u30A1\u30A4\u30EB\u306F\u62BD\u51FA\u3057\u3066\u30EA\u30F3\u30AF\u3057\u307E\u3059\u3002\u6B20\u843D\u3057\u3066\u3044\u308B\u30D5\u30A1\u30A4\u30EB\u306B\u306F\u60C5\u5831\u30CE\u30FC\u30C8\u3092\u4F5C\u6210\u3057\u307E\u3059\u3002",
            platform_diff: "\u30D7\u30E9\u30C3\u30C8\u30D5\u30A9\u30FC\u30E0\u306E\u9055\u3044\uFF1AChatGPT\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u306F\u3001\u7279\u306B\u53E4\u3044\u4F1A\u8A71\u306E\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u304C\u3059\u3079\u3066\u542B\u307E\u308C\u306A\u3044\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002",
            organization: "\u30B7\u30F3\u30D7\u30EB\u306A\u6574\u7406\uFF1A\u30D5\u30A1\u30A4\u30EB\u306F attachments/provider/category/ \u306E\u5F62\u5F0F\u3067\u6574\u7406\u3055\u308C\u307E\u3059\uFF08\u4F8B\uFF1Aattachments/chatgpt/images/\uFF09\u3002",
            sync_tip: "\u540C\u671F\u306E\u30D2\u30F3\u30C8\uFF1A\u5927\u5BB9\u91CF\u30D5\u30A1\u30A4\u30EB\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3092\u907F\u3051\u308B\u305F\u3081\u3001\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u540C\u671F\u304B\u3089\u9664\u5916\u3059\u308B\u3053\u3068\u3092\u691C\u8A0E\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
            tip: "\u{1F4A1} \u30D2\u30F3\u30C8\uFF1A\u300C\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u8A73\u7D30\u3092\u8868\u793A\u300D\u3092\u6709\u52B9\u306B\u3059\u308B\u3068\u3001\u30A4\u30F3\u30DD\u30FC\u30C8\u6642\u306B\u898B\u3064\u304B\u3063\u305F\u30D5\u30A1\u30A4\u30EB\u30FB\u6B20\u843D\u3057\u305F\u30D5\u30A1\u30A4\u30EB\u30FB\u5931\u6557\u3057\u305F\u30D5\u30A1\u30A4\u30EB\u3092\u6B63\u78BA\u306B\u78BA\u8A8D\u3067\u304D\u307E\u3059\u3002"
          }
        },
        migrations: {
          section_title: "\u30DE\u30A4\u30B0\u30EC\u30FC\u30B7\u30E7\u30F3",
          description_manual: "\u624B\u52D5\u64CD\u4F5C\uFF1A\u90FD\u5408\u306E\u3088\u3044\u3068\u304D\u306B\u5B9F\u884C\u3067\u304D\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u64CD\u4F5C\u3067\u3059\u3002",
          description_automatic: "\u81EA\u52D5\u64CD\u4F5C\uFF08\u53E4\u3044\u30C7\u30FC\u30BF\u306E\u524A\u9664\u306A\u3069\uFF09\u306F\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u6642\u306B\u81EA\u52D5\u7684\u306B\u5B9F\u884C\u3055\u308C\u3001\u3053\u3053\u306B\u306F\u8868\u793A\u3055\u308C\u307E\u305B\u3093\u3002",
          version_header: "\u30D0\u30FC\u30B8\u30E7\u30F3 {{version}}",
          no_migrations: {
            title: "\u5229\u7528\u53EF\u80FD\u306A\u624B\u52D5\u64CD\u4F5C\u306F\u3042\u308A\u307E\u305B\u3093",
            desc: "\u3059\u3079\u3066\u306E\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u64CD\u4F5C\u306F\u81EA\u52D5\u7684\u306B\u5B8C\u4E86\u3057\u307E\u3057\u305F\u3002"
          },
          operation_completed_suffix: " \u2705 \u5B8C\u4E86",
          buttons: {
            completed: "\u2705 \u5B8C\u4E86",
            cannot_run: "\u5B9F\u884C\u4E0D\u53EF",
            run: "\u5B9F\u884C",
            running: "\u5B9F\u884C\u4E2D..."
          },
          tooltips: {
            completed: "\u3053\u306E\u64CD\u4F5C\u306F\u3059\u3067\u306B\u5B8C\u4E86\u3057\u3066\u3044\u307E\u3059",
            cannot_run: "\u3053\u306E\u64CD\u4F5C\u306E\u524D\u63D0\u6761\u4EF6\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u307E\u305B\u3093",
            run: "{{operation_name}} \u3092\u5B9F\u884C"
          },
          error_loading: "\u30DE\u30A4\u30B0\u30EC\u30FC\u30B7\u30E7\u30F3\u306E\u8AAD\u307F\u8FBC\u307F\u30A8\u30E9\u30FC\uFF1A"
        },
        support: {
          section_title: "\u{1F49D} \u30B5\u30DD\u30FC\u30C8\u3068\u30D8\u30EB\u30D7",
          resources: {
            name: "\u{1F4DA} \u30EA\u30BD\u30FC\u30B9",
            desc: "\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u3001\u30EA\u30EA\u30FC\u30B9\u30CE\u30FC\u30C8\u3001\u30B3\u30DF\u30E5\u30CB\u30C6\u30A3\u30EA\u30F3\u30AF",
            documentation: "\u{1F4D6} \u30C9\u30AD\u30E5\u30E1\u30F3\u30C8",
            release_notes: "\u{1F4DD} \u30EA\u30EA\u30FC\u30B9\u30CE\u30FC\u30C8",
            issues: "\u{1F41B} \u554F\u984C\u5831\u544A",
            forum: "\u{1F4AC} \u30D5\u30A9\u30FC\u30E9\u30E0"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "\u958B\u59CB\u4E2D...",
          progress_label: "\u9032\u6357\uFF1A{{percentage}}%",
          step_label: "\u30B9\u30C6\u30C3\u30D7 {{current}}/{{total}}",
          complete_label: "\u5B8C\u4E86",
          complete_message: "\u6B63\u5E38\u306B\u5B8C\u4E86\u3057\u307E\u3057\u305F",
          error_message: "\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F"
        },
        multi_operation_modal: {
          progress_label: "\u9032\u6357\uFF1A{{completed}}/{{total}} \u64CD\u4F5C",
          progress_with_failures: "\u9032\u6357\uFF1A{{completed}}/{{total}} \u64CD\u4F5C\uFF08{{failed}} \u4EF6\u5931\u6557\uFF09",
          all_completed: "{{total}} \u4EF6\u306E\u64CD\u4F5C\u304C\u3059\u3079\u3066\u6B63\u5E38\u306B\u5B8C\u4E86\u3057\u307E\u3057\u305F",
          mark_complete_default: "\u3059\u3079\u3066\u306E\u64CD\u4F5C\u304C\u6B63\u5E38\u306B\u5B8C\u4E86\u3057\u307E\u3057\u305F",
          buttons: {
            complete: "\u5B8C\u4E86",
            close: "\u9589\u3058\u308B"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} \u30DE\u30A4\u30B0\u30EC\u30FC\u30B7\u30E7\u30F3\u304C\u5FC5\u8981\u3067\u3059",
            message: "\u4EE5\u4E0B\u306E\u30BF\u30B9\u30AF\u304C\u81EA\u52D5\u7684\u306B\u5B9F\u884C\u3055\u308C\u3001\u30C7\u30FC\u30BF\u304C v1.3.0 \u306B\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u3055\u308C\u307E\u3059\uFF1A",
            tasks: {
              folder_settings: "\u2713 \u30D5\u30A9\u30EB\u30C0\u30FC\u8A2D\u5B9A\u3092\u65B0\u3057\u3044\u69CB\u9020\u306B\u79FB\u884C",
              timestamps: "\u2713 \u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7\u3092 ISO 8601 \u5F62\u5F0F\u306B\u66F4\u65B0",
              aliases: "\u2713 frontmatter \u306E\u30A8\u30A4\u30EA\u30A2\u30B9\u3092\u4FEE\u6B63",
              reports: "\u2713 \u30EC\u30DD\u30FC\u30C8\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9069\u5207\u306A\u5834\u6240\u306B\u79FB\u52D5",
              artifacts: "\u2713 \u30A2\u30FC\u30C6\u30A3\u30D5\u30A1\u30AF\u30C8\u306E\u30E1\u30BF\u30C7\u30FC\u30BF\u3092\u66F4\u65B0"
            },
            estimate: "\u6570\u79D2\u304B\u304B\u308A\u307E\u3059\u3002"
          },
          buttons: {
            run_migration: "\u{1F680} \u30DE\u30A4\u30B0\u30EC\u30FC\u30B7\u30E7\u30F3\u3092\u5B9F\u884C"
          }
        },
        complete_modal: {
          title: "\u2705 \u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u5B8C\u4E86 - v{{version}}",
          buttons: {
            got_it: "\u4E86\u89E3\uFF01"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "\u4E86\u89E3\uFF01"
          }
        }
      },
      folder_migration: {
        title: "\u65E2\u5B58\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3057\u307E\u3059\u304B\uFF1F",
        message_intro: "{{folder_type}} \u30D5\u30A9\u30EB\u30C0\u30FC\u306E\u5834\u6240\u3092\u5909\u66F4\u3057\u3066\u3044\u307E\u3059\uFF1A",
        path_from: "\u79FB\u52D5\u5143\uFF1A{{path}}",
        path_to: "\u79FB\u52D5\u5148\uFF1A{{path}}",
        question: "\u65E2\u5B58\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u65B0\u3057\u3044\u5834\u6240\u306B\u79FB\u52D5\u3057\u307E\u3059\u304B\uFF1F",
        link_updates: {
          title: "\u{1F517} \u30EA\u30F3\u30AF\u306E\u66F4\u65B0\uFF1A",
          attachments_text: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3059\u308B\u3068\u3001\u305D\u308C\u3089\u3092\u53C2\u7167\u3057\u3066\u3044\u308B\u3059\u3079\u3066\u306E\u4F1A\u8A71\u30CE\u30FC\u30C8\u3082\u66F4\u65B0\u3055\u308C\u307E\u3059\u3002",
          conversations_text: "\u4F1A\u8A71\u3092\u79FB\u52D5\u3059\u308B\u3068\u3001\u305D\u308C\u3089\u3092\u53C2\u7167\u3057\u3066\u3044\u308B\u3059\u3079\u3066\u306E\u30EC\u30DD\u30FC\u30C8\u3068\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u3082\u66F4\u65B0\u3055\u308C\u307E\u3059\u3002",
          estimated_time_seconds: "\u63A8\u5B9A\u6642\u9593\uFF1A\u7D04 {{seconds}} \u79D2",
          estimated_time_minutes: "\u63A8\u5B9A\u6642\u9593\uFF1A\u7D04 {{minutes}} \u5206"
        },
        warning: {
          title: "\u26A0\uFE0F \u91CD\u8981\uFF1A",
          text: "\u300C\u3044\u3044\u3048\u300D\u3092\u9078\u629E\u3057\u305F\u5834\u5408\u3001\u65E2\u5B58\u306E\u30D5\u30A1\u30A4\u30EB\u306F\u5143\u306E\u5834\u6240\u306B\u6B8B\u308A\u3001\u4ECA\u5F8C\u306E\u66F4\u65B0\u306E\u5F71\u97FF\u3092\u53D7\u3051\u307E\u305B\u3093\u3002"
        },
        buttons: {
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
          keep: "\u3044\u3044\u3048\u3001\u5143\u306E\u5834\u6240\u306B\u4FDD\u6301\u3059\u308B",
          move: "\u306F\u3044\u3001\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3059\u308B",
          move_with_links: "\u306F\u3044\u3001\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3057\u3066\u30EA\u30F3\u30AF\u3082\u66F4\u65B0\u3059\u308B"
        },
        progress: {
          title_moving: "{{folder_type}} \u3092\u79FB\u52D5\u3057\u3066\u30EA\u30F3\u30AF\u3092\u66F4\u65B0\u4E2D",
          step_moving_title: "\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u4E2D...",
          step_moving_detail: "{{old_path}} \u304B\u3089 {{new_path}} \u3078\u79FB\u52D5\u4E2D",
          step_moving_count: "{{current}} / {{total}} \u30D5\u30A1\u30A4\u30EB\u3092\u51E6\u7406\u6E08\u307F",
          step_moved_title: "\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3057\u307E\u3057\u305F",
          step_moved_detail: "{{moved}} \u4EF6\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3001{{skipped}} \u4EF6\u3092\u30B9\u30AD\u30C3\u30D7\u3002\u30EA\u30F3\u30AF\u306E\u66F4\u65B0\u3092\u6E96\u5099\u4E2D...",
          step_updating_attachment_links: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u306E\u30EA\u30F3\u30AF\u3092\u66F4\u65B0\u4E2D...",
          step_updating_conversation_links: "\u4F1A\u8A71\u306E\u30EA\u30F3\u30AF\u3092\u66F4\u65B0\u4E2D...",
          step_updating_report_links: "\u30EC\u30DD\u30FC\u30C8\u5185\u306E\u30EA\u30F3\u30AF\u3092\u66F4\u65B0\u4E2D...",
          step_updating_artifact_links: "\u30A2\u30FC\u30C6\u30A3\u30D5\u30A1\u30AF\u30C8\u5185\u306E\u30EA\u30F3\u30AF\u3092\u66F4\u65B0\u4E2D...",
          complete_message: "{{moved}} \u4EF6\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u79FB\u52D5\u3057\u307E\u3057\u305F\u3002{{links}} \u4EF6\u306E\u30EA\u30F3\u30AF\u3092\u6B63\u5E38\u306B\u66F4\u65B0\u3057\u307E\u3057\u305F"
        },
        result_dialog: {
          title: "\u30D5\u30A9\u30EB\u30C0\u30FC\u79FB\u884C\u306E\u7D50\u679C",
          summary_title: "\u79FB\u884C\u306E\u6982\u8981",
          moved: "\u2705 \u6B63\u5E38\u306B\u79FB\u52D5\uFF1A{{count}} \u30D5\u30A1\u30A4\u30EB",
          skipped: "\u26A0\uFE0F \u30B9\u30AD\u30C3\u30D7\u6E08\u307F\uFF08\u3059\u3067\u306B\u5B58\u5728\uFF09\uFF1A{{count}} \u30D5\u30A1\u30A4\u30EB",
          errors: "\u274C \u30A8\u30E9\u30FC\uFF1A{{count}} \u30D5\u30A1\u30A4\u30EB",
          explanation: "\u79FB\u52D5\u5148\u306B\u3059\u3067\u306B\u5B58\u5728\u3059\u308B\u30D5\u30A1\u30A4\u30EB\u306F\u30C7\u30FC\u30BF\u4FDD\u8B77\u306E\u305F\u3081\u4E0A\u66F8\u304D\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002",
          error_details_title: "\u30A8\u30E9\u30FC\u306E\u8A73\u7D30\uFF1A"
        },
        error_target_not_empty: {
          title: "\u79FB\u52D5\u5148\u30D5\u30A9\u30EB\u30C0\u30FC\u304C\u7A7A\u3067\u306F\u3042\u308A\u307E\u305B\u3093",
          message: "\u30D5\u30A9\u30EB\u30C0\u30FC\u300C{{path}}\u300D\u306B\u306F\u3059\u3067\u306B\u30D5\u30A1\u30A4\u30EB\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\n\n\u30D5\u30A9\u30EB\u30C0\u30FC\u306E\u5834\u6240\u3092\u5909\u66F4\u3059\u308B\u306B\u306F\uFF1A\n\u2022 Obsidian \u3067\u65E2\u5B58\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u624B\u52D5\u3067\u79FB\u52D5\u3059\u308B\u3001\u307E\u305F\u306F\n\u2022 \u7A7A\u306E\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9078\u629E\u3059\u308B\u304B\u3001\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210\u3059\u308B"
        },
        error_migration_failed: {
          title: "\u79FB\u884C\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
          message_move: "\u30D5\u30A1\u30A4\u30EB\u306E\u79FB\u52D5\u306B\u5931\u6557\u3057\u307E\u3057\u305F\uFF1A{{error}}",
          message_links: "\u30D5\u30A1\u30A4\u30EB\u306E\u79FB\u52D5\u307E\u305F\u306F\u30EA\u30F3\u30AF\u306E\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F\uFF1A{{error}}"
        }
      },
      folder_browser: {
        title: "\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9078\u629E",
        vault_root: "Vault \u306E\u30EB\u30FC\u30C8\uFF08/\uFF09",
        buttons: {
          create_new_folder: "\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210",
          cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
          select: "\u9078\u629E"
        },
        create_folder_dialog: {
          title: "\u65B0\u3057\u3044\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210",
          folder_name_label: "\u30D5\u30A9\u30EB\u30C0\u30FC\u540D\uFF1A",
          buttons: {
            cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
            create: "\u4F5C\u6210"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F \u6700\u521D\u306B\u89AA\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
          invalid_name: "\u274C \u7121\u52B9\u306A\u30D5\u30A9\u30EB\u30C0\u30FC\u540D\uFF1A\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059",
          already_exists: "\u274C \u30D5\u30A9\u30EB\u30C0\u30FC\u306F\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 \u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u4F5C\u6210\u3057\u307E\u3057\u305F\uFF1A{{name}}",
          create_failed: "\u274C \u30D5\u30A9\u30EB\u30C0\u30FC\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F\uFF1A{{error}}",
          select_first: "\u26A0\uFE0F \u6700\u521D\u306B\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "\u30D0\u30FC\u30B8\u30E7\u30F3 1.3.0 \u3067\u306F\u3001\u30EC\u30DD\u30FC\u30C8\u7528\u306E\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u6307\u5B9A\u3067\u304D\u308B\u3088\u3046\u306B\u306A\u308A\u307E\u3057\u305F\u3002\u65E2\u5B58\u306E\u30EC\u30DD\u30FC\u30C8\u306F {{folder}} \u306B\u79FB\u52D5\u3055\u308C\u307E\u3059\u3002\u307E\u305F\u306F\u3001\u4EE5\u4E0B\u304B\u3089\u5E0C\u671B\u306E\u30D5\u30A9\u30EB\u30C0\u30FC\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
        note: "\u6CE8\u610F\uFF1A\u3053\u306E\u30D5\u30A9\u30EB\u30C0\u30FC\u306F\u300C\u4F1A\u8A71\u300D\u307E\u305F\u306F\u300C\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u300D\u30D5\u30A9\u30EB\u30C0\u30FC\u306E\u5185\u90E8\u306B\u8A2D\u5B9A\u3067\u304D\u307E\u305B\u3093\u3002",
        report_folder_label: "\u{1F4CA} \u30EC\u30DD\u30FC\u30C8\u30D5\u30A9\u30EB\u30C0\u30FC",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "\u53C2\u7167",
          proceed: "\u5B9F\u884C"
        },
        error_invalid_folder: {
          title: "\u7121\u52B9\u306A\u30D5\u30A9\u30EB\u30C0\u30FC\u306E\u5834\u6240",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Nexus AI Chat Importer \u3092\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u3044\u305F\u3060\u304D\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\uFF01",
        description: "ChatGPT\u3001Claude\u3001Le Chat \u306E\u4F1A\u8A71\u3092 Obsidian Vault \u306B\u76F4\u63A5\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u3066\u7BA1\u7406\u3067\u304D\u307E\u3059\u3002",
        resources_title: "\u30EA\u30BD\u30FC\u30B9",
        resources: {
          documentation: {
            title: "\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8",
            description: "\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u4F7F\u3044\u65B9\u3092\u5B66\u3076"
          },
          release_notes: {
            title: "\u30EA\u30EA\u30FC\u30B9\u30CE\u30FC\u30C8",
            description: "\u3053\u306E\u30D0\u30FC\u30B8\u30E7\u30F3\u306E\u65B0\u6A5F\u80FD"
          },
          report_issues: {
            title: "\u554F\u984C\u3092\u5831\u544A",
            description: "\u30D0\u30B0\u3092\u898B\u3064\u3051\u307E\u3057\u305F\u304B\uFF1F\u304A\u77E5\u3089\u305B\u304F\u3060\u3055\u3044"
          },
          community_forum: {
            title: "\u30B3\u30DF\u30E5\u30CB\u30C6\u30A3\u30D5\u30A9\u30FC\u30E9\u30E0",
            description: "\u30C7\u30A3\u30B9\u30AB\u30C3\u30B7\u30E7\u30F3\u306B\u53C2\u52A0\u3059\u308B"
          }
        },
        buttons: {
          get_started: "\u59CB\u3081\u308B"
        }
      },
      notices: {
        import_analyzing: "{{count}} \u4EF6\u306E\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u4F1A\u8A71\u3092\u5206\u6790\u4E2D...",
        import_no_new: "\u65B0\u898F\u307E\u305F\u306F\u66F4\u65B0\u3055\u308C\u305F\u4F1A\u8A71\u306F\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u3059\u3079\u3066\u306E\u4F1A\u8A71\u306F\u6700\u65B0\u306E\u72B6\u614B\u3067\u3059\u3002",
        import_starting: "{{count}} \u4EF6\u306E\u4F1A\u8A71\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u4E2D\uFF08\u65B0\u898F {{new}} \u4EF6\u3001\u66F4\u65B0\u6E08\u307F {{updated}} \u4EF6\uFF09...",
        import_starting_selected: "{{files}} \u4EF6\u306E\u30D5\u30A1\u30A4\u30EB\u304B\u3089\u9078\u629E\u3057\u305F {{count}} \u4EF6\u306E\u4F1A\u8A71\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u4E2D...",
        import_completed_fallback: "\u30A4\u30F3\u30DD\u30FC\u30C8\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F\u3002{{created}} \u4EF6\u3092\u4F5C\u6210\u3001{{updated}} \u4EF6\u3092\u66F4\u65B0\u3002",
        import_error: "\u30A4\u30F3\u30DD\u30FC\u30C8\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\uFF1A{{error}}",
        import_error_analyzing: "\u4F1A\u8A71\u306E\u5206\u6790\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\uFF1A{{error}}",
        import_error_file: "{{filename}} \u306E\u51E6\u7406\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u8A73\u7D30\u306F\u30B3\u30F3\u30BD\u30FC\u30EB\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002",
        import_no_selected: "\u30A4\u30F3\u30DD\u30FC\u30C8\u3059\u308B\u4F1A\u8A71\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002",
        import_no_zip_gemini: "Gemini Takeout \u306E ZIP \u30D5\u30A1\u30A4\u30EB\u3092\u5C11\u306A\u304F\u3068\u3082 1 \u3064\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\uFF08\u30AA\u30D7\u30B7\u30E7\u30F3\u3068\u3057\u3066\u62E1\u5F35\u6A5F\u80FD\u304B\u3089\u306E JSON \u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u3082\u6307\u5B9A\u3067\u304D\u307E\u3059\uFF09\u3002",
        import_no_zip: "ZIP \u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30D5\u30A1\u30A4\u30EB\u3092\u5C11\u306A\u304F\u3068\u3082 1 \u3064\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
        import_gemini_json_failed: "Gemini \u30A4\u30F3\u30C7\u30C3\u30AF\u30B9 JSON \u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u306A\u3057\u3067\u7D9A\u884C\u3057\u307E\u3059\u3002",
        report_failed: "\u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u8A73\u7D30\u306F\u30B3\u30F3\u30BD\u30FC\u30EB\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002",
        attachment_map_failed: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB\u30DE\u30C3\u30D7\u306E\u69CB\u7BC9\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u8A73\u7D30\u306F\u30B3\u30F3\u30BD\u30FC\u30EB\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002",
        ribbon_tooltip: "Nexus AI Chat Importer - \u65B0\u3057\u3044\u30D5\u30A1\u30A4\u30EB\u3092\u30A4\u30F3\u30DD\u30FC\u30C8"
      },
      commands: {
        import_conversations: {
          name: "AI \u4F1A\u8A71\u3092\u30A4\u30F3\u30DD\u30FC\u30C8"
        }
      },
      support_box: {
        header: "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u652F\u63F4\u3059\u308B",
        header_highlight: "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u652F\u63F4\u3059\u308B",
        default_message_emphasis: "\u79C1\u306F\u5931\u696D\u4E2D\u3067\u5065\u5EB7\u4E0A\u306E\u554F\u984C\u3092\u62B1\u3048\u306A\u304C\u3089\u3001Nexus \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306B\u30D5\u30EB\u30BF\u30A4\u30E0\u3067\u53D6\u308A\u7D44\u3093\u3067\u3044\u307E\u3059\u3002",
        default_message: "\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u5F79\u306B\u7ACB\u3063\u3066\u3044\u308B\u306A\u3089\u3001\u5BC4\u4ED8\u306F\u3068\u3066\u3082\u5927\u304D\u306A\u52B1\u307F\u306B\u306A\u308A\u3001\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306E\u7D99\u7D9A\u3092\u652F\u3048\u3066\u304F\u308C\u307E\u3059\u3002",
        reality_check: "\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\uFF01\u3053\u308C\u3089\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u306B\u306F\u6570\u5343\u6642\u9593\u306E\u4F5C\u696D\u304C\u6CE8\u304E\u8FBC\u307E\u308C\u3066\u304A\u308A\u3001\u3054\u652F\u63F4\u304C\u5065\u5EB7\u4E0A\u306E\u554F\u984C\u3068\u5411\u304D\u5408\u3044\u306A\u304C\u3089\u6539\u5584\u3092\u7D9A\u3051\u308B\u79C1\u306E\u529B\u306B\u306A\u308A\u307E\u3059\u3002\u3053\u306E\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u304A\u5F79\u306B\u7ACB\u3063\u3066\u3044\u308B\u306A\u3089\u3001\u305C\u3072\u30B5\u30DD\u30FC\u30C8\u3092\u3054\u691C\u8A0E\u304F\u3060\u3055\u3044\u3002",
        button_alt: "\u79C1\u306E\u6D3B\u52D5\u3092\u652F\u63F4\u3059\u308B"
      }
    };
  }
});

// src/i18n/locales/pt.json
var pt_default;
var init_pt = __esm({
  "src/i18n/locales/pt.json"() {
    pt_default = {
      common: {
        buttons: {
          cancel: "Cancelar",
          ok: "OK",
          select: "Selecionar",
          browse: "Procurar",
          continue: "Continuar",
          proceed: "Prosseguir",
          close: "Entendido!",
          create: "Criar",
          remove: "Remover",
          run: "Executar",
          complete: "Concluir",
          view_report: "Ver relat\xF3rio",
          get_started: "Come\xE7ar",
          create_new_folder: "Criar nova pasta"
        },
        status: {
          new: "Novo",
          updated: "Atualizado",
          unchanged: "Sem altera\xE7\xF5es",
          unknown: "Desconhecido"
        },
        progress: {
          phase_validation: "\u{1F50D} Valida\xE7\xE3o",
          phase_scanning: "\u{1F4CB} An\xE1lise",
          phase_processing: "\u2699\uFE0F Processamento",
          phase_writing: "\u{1F4BE} Escrita",
          phase_complete: "\u2705 Conclu\xEDdo",
          phase_error: "\u274C Erro"
        }
      },
      provider_selection: {
        title: "Selecionar fornecedor de arquivo",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "Exporta\xE7\xF5es de conversas do OpenAI ChatGPT"
          },
          claude: {
            name: "Claude",
            description: "Exporta\xE7\xF5es de conversas do Anthropic Claude"
          },
          lechat: {
            name: "Le Chat",
            description: "Exporta\xE7\xF5es de conversas do Mistral AI Le Chat"
          }
        },
        buttons: {
          select: "Selecionar",
          cancel: "Cancelar"
        }
      },
      file_selection: {
        title: "Importar conversas do {{provider}}",
        import_mode: {
          section_title: "Modo de importa\xE7\xE3o",
          all_label: "Importar tudo",
          all_description: "Importar todas as conversas (mais r\xE1pido)",
          selective_label: "Selecionar individualmente",
          selective_description: "Pr\xE9-visualizar e escolher conversas"
        },
        file_area: {
          section_title: "Selecionar ficheiros",
          drop_text_default: "Arraste ficheiros ZIP para aqui ou clique para procurar",
          drop_text_gemini: "Arraste ficheiros ZIP e JSON para aqui ou clique para procurar",
          drop_subtext_default: "Suporta sele\xE7\xE3o de m\xFAltiplos ficheiros",
          drop_subtext_gemini: "ZIP (Takeout) + JSON opcional (\xEDndice da extens\xE3o)"
        },
        selected_files: {
          section_title: "Ficheiros selecionados",
          remove_button: "Remover"
        },
        buttons: {
          cancel: "Cancelar",
          continue: "Continuar"
        }
      },
      conversation_selection: {
        title: "Selecionar conversas para importar",
        controls: {
          select_all: "Selecionar tudo",
          select_none: "Desselecionar tudo",
          search_placeholder: "Pesquisar conversas...",
          status_label: "Estado:",
          show_label: "Mostrar:"
        },
        status_filter_options: {
          all: "Todas",
          new: "Novas",
          updated: "Atualizadas",
          unchanged: "Sem altera\xE7\xF5es"
        },
        table_headers: {
          title: "T\xEDtulo",
          created: "Criado em",
          updated: "Atualizado em",
          messages: "Mensagens",
          status: "Estado"
        },
        status_badges: {
          new: "Novo",
          updated: "Atualizado",
          unchanged: "Sem altera\xE7\xF5es",
          unknown: "Desconhecido",
          tooltip_new: "Esta conversa n\xE3o existe no seu cofre",
          tooltip_updated: "Esta conversa tem conte\xFAdo mais recente do que o seu cofre ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "Esta conversa \xE9 id\xEAntica \xE0 vers\xE3o no seu cofre"
        },
        pagination: {
          showing: "A mostrar {{start}}\u2013{{end}} de {{total}} conversas",
          page_of: "P\xE1gina {{current}} de {{total}}",
          previous: "Anterior",
          next: "Seguinte"
        },
        summary: {
          unique_conversations: "Conversas \xFAnicas",
          new: "Novas",
          updated: "Atualizadas",
          unchanged: "Sem altera\xE7\xF5es",
          selected_of: "{{selected}} de {{total}} selecionadas"
        },
        buttons: {
          cancel: "Cancelar",
          import_selected: "Importar selecionadas",
          import_selected_count: "Importar {{count}} selecionadas"
        },
        date_unknown: "Desconhecido"
      },
      import_progress: {
        title: "A importar {{filename}}",
        initial: {
          title: "A preparar importa\xE7\xE3o...",
          detail: "A validar a estrutura do ficheiro ZIP"
        },
        conversation_counter: "{{current}}/{{total}} conversas",
        conversation_counter_selective: "{{current}}/{{total}} conversas selecionadas",
        selective_mode_indicator: "\u{1F4CB} Importa\xE7\xE3o seletiva: {{selected}} de {{total}} conversas",
        complete: {
          message: "Importa\xE7\xE3o conclu\xEDda com sucesso",
          detail: "Pode fechar esta janela"
        },
        error: {
          message: "Ocorreu um erro durante a importa\xE7\xE3o",
          detail: "Consulte a consola para mais detalhes"
        }
      },
      import_completion: {
        title: "Importa\xE7\xE3o conclu\xEDda",
        success_message: "\u2705 Conversas importadas com sucesso",
        stats: {
          zip_files_processed: "Ficheiros ZIP processados",
          unique_conversations: "Conversas \xFAnicas",
          duplicates: "Duplicados",
          new: "Novas",
          updated: "Atualizadas",
          skipped: "Ignoradas",
          failed: "Falhadas"
        },
        attachments: {
          label: "Anexos:",
          summary: "{{found}}/{{total}} extra\xEDdos ({{percentage}}%)",
          missing_failed: "{{missing}} em falta, {{failed}} falhados"
        },
        report: {
          label: "\u{1F4C4} Relat\xF3rio detalhado:"
        },
        buttons: {
          view_report: "Ver relat\xF3rio",
          ok: "OK"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} Estrutura de pastas",
          conversation_folder: {
            name: "Pasta de conversas",
            desc: "Local onde as conversas importadas s\xE3o guardadas",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "Procurar pastas ou criar uma nova"
          },
          reports_folder: {
            name: "Pasta de relat\xF3rios",
            desc: "Local onde os relat\xF3rios de importa\xE7\xE3o s\xE3o guardados",
            placeholder: "Nexus Reports",
            browse_tooltip: "Procurar pastas ou criar uma nova"
          },
          attachment_folder: {
            name: "Pasta de anexos",
            desc: "Local onde os anexos s\xE3o guardados (\u26A0\uFE0F Excluir da sincroniza\xE7\xE3o para poupar espa\xE7o)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "Procurar pastas ou criar uma nova"
          }
        },
        display: {
          section_title: "\u{1F4C5} Prefixo de data",
          add_date_prefix: {
            name: "Adicionar prefixo de data aos nomes de ficheiro",
            desc: "Adicionar a data de cria\xE7\xE3o como prefixo aos nomes dos ficheiros de conversa",
            format_label: "Selecionar formato de data: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} Formato de data das mensagens",
          custom_format: {
            name: "Formato de data e hora personalizado nas mensagens",
            desc: "Substituir o formato de data e hora predefinido baseado nas defini\xE7\xF5es de idioma nos cabe\xE7alhos das mensagens. Quando desativado, os carimbos de data e hora seguem as defini\xE7\xF5es de idioma do Obsidian. Se o Obsidian estiver em ingl\xEAs, o formato norte-americano (YYYY/DD/MM) \xE9 aplicado."
          },
          timestamp_format: {
            name: "Formato de data e hora",
            desc: "Escolher o formato dos carimbos de data e hora nas notas de conversa"
          },
          preview_label: "Pr\xE9-visualiza\xE7\xE3o: "
        },
        attachments: {
          section_title: "Defini\xE7\xF5es de anexos",
          import_attachments: {
            name: "Importar anexos",
            desc: "Guardar ficheiros de anexo no disco e associ\xE1-los nas conversas (utiliza estrat\xE9gia de 'melhor esfor\xE7o')"
          },
          handle_missing: {
            name: "Lidar com anexos em falta",
            desc: "Quando os anexos est\xE3o ausentes das exporta\xE7\xF5es, criar notas informativas em vez de os ignorar"
          },
          show_details: {
            name: "Mostrar detalhes de anexos nos relat\xF3rios",
            desc: "Incluir estat\xEDsticas detalhadas do processamento de anexos nos relat\xF3rios de importa\xE7\xE3o"
          },
          info_box: {
            title: "\u{1F4CE} Sobre o tratamento de anexos",
            best_effort: "Estrat\xE9gia de melhor esfor\xE7o: os ficheiros encontrados nas exporta\xE7\xF5es s\xE3o extra\xEDdos e associados; os ficheiros em falta recebem notas informativas.",
            platform_diff: "Diferen\xE7as entre plataformas: as exporta\xE7\xF5es do ChatGPT podem n\xE3o incluir todos os anexos, especialmente de conversas mais antigas.",
            organization: "Organiza\xE7\xE3o simples: ficheiros organizados como attachments/provider/category/ (por exemplo, attachments/chatgpt/images/).",
            sync_tip: "Dica de sincroniza\xE7\xE3o: considere excluir a pasta de anexos da sincroniza\xE7\xE3o para evitar o envio de ficheiros grandes.",
            tip: "\u{1F4A1} Dica: ative 'Mostrar detalhes de anexos' para ver exatamente quais ficheiros foram encontrados, est\xE3o em falta ou falharam durante a importa\xE7\xE3o."
          }
        },
        migrations: {
          section_title: "Migra\xE7\xF5es",
          description_manual: "Opera\xE7\xF5es manuais: opera\xE7\xF5es de atualiza\xE7\xE3o opcionais que podem ser executadas quando for conveniente.",
          description_automatic: "As opera\xE7\xF5es autom\xE1ticas (como a remo\xE7\xE3o de dados antigos) s\xE3o executadas automaticamente durante a atualiza\xE7\xE3o e n\xE3o s\xE3o apresentadas aqui.",
          version_header: "Vers\xE3o {{version}}",
          no_migrations: {
            title: "N\xE3o h\xE1 opera\xE7\xF5es manuais dispon\xEDveis",
            desc: "Todas as opera\xE7\xF5es de atualiza\xE7\xE3o foram conclu\xEDdas automaticamente."
          },
          operation_completed_suffix: " \u2705 Conclu\xEDdo",
          buttons: {
            completed: "\u2705 Conclu\xEDdo",
            cannot_run: "N\xE3o \xE9 poss\xEDvel executar",
            run: "Executar",
            running: "A executar..."
          },
          tooltips: {
            completed: "Esta opera\xE7\xE3o foi conclu\xEDda",
            cannot_run: "Os pr\xE9-requisitos desta opera\xE7\xE3o n\xE3o foram cumpridos",
            run: "Executar {{operation_name}}"
          },
          error_loading: "Erro ao carregar migra\xE7\xF5es:"
        },
        support: {
          section_title: "\u{1F49D} Suporte e ajuda",
          resources: {
            name: "\u{1F4DA} Recursos",
            desc: "Documenta\xE7\xE3o, notas de vers\xE3o e liga\xE7\xF5es para a comunidade",
            documentation: "\u{1F4D6} Documenta\xE7\xE3o",
            release_notes: "\u{1F4DD} Notas de vers\xE3o",
            issues: "\u{1F41B} Problemas",
            forum: "\u{1F4AC} F\xF3rum"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "A iniciar...",
          progress_label: "Progresso: {{percentage}}%",
          step_label: "Passo {{current}}/{{total}}",
          complete_label: "Conclu\xEDdo",
          complete_message: "Conclu\xEDdo com sucesso",
          error_message: "Ocorreu um erro"
        },
        multi_operation_modal: {
          progress_label: "Progresso: {{completed}}/{{total}} opera\xE7\xF5es",
          progress_with_failures: "Progresso: {{completed}}/{{total}} opera\xE7\xF5es ({{failed}} falhadas)",
          all_completed: "Todas as {{total}} opera\xE7\xF5es conclu\xEDdas com sucesso",
          mark_complete_default: "Todas as opera\xE7\xF5es conclu\xEDdas com sucesso",
          buttons: {
            complete: "Concluir",
            close: "Fechar"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} Migra\xE7\xE3o necess\xE1ria",
            message: "As seguintes tarefas ser\xE3o executadas automaticamente para atualizar os seus dados para v1.3.0:",
            tasks: {
              folder_settings: "\u2713 Migrar defini\xE7\xF5es de pastas para a nova estrutura",
              timestamps: "\u2713 Atualizar carimbos de data e hora para o formato ISO 8601",
              aliases: "\u2713 Corrigir aliases do frontmatter",
              reports: "\u2713 Mover a pasta de relat\xF3rios para o local correto",
              artifacts: "\u2713 Atualizar metadados de artefactos"
            },
            estimate: "Isto demorar\xE1 alguns segundos."
          },
          buttons: {
            run_migration: "\u{1F680} Executar tarefas de migra\xE7\xE3o"
          }
        },
        complete_modal: {
          title: "\u2705 Atualiza\xE7\xE3o conclu\xEDda - v{{version}}",
          buttons: {
            got_it: "Entendido!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "Entendido!"
          }
        }
      },
      folder_migration: {
        title: "Mover ficheiros existentes?",
        message_intro: "Est\xE1 a alterar a localiza\xE7\xE3o da pasta {{folder_type}}:",
        path_from: "De: {{path}}",
        path_to: "Para: {{path}}",
        question: "Deseja mover os ficheiros existentes para a nova localiza\xE7\xE3o?",
        link_updates: {
          title: "\u{1F517} Atualiza\xE7\xE3o de liga\xE7\xF5es:",
          attachments_text: "Mover os anexos ir\xE1 tamb\xE9m atualizar todas as notas de conversa que os referenciam.",
          conversations_text: "Mover as conversas ir\xE1 tamb\xE9m atualizar todos os relat\xF3rios e anexos que as referenciam.",
          estimated_time_seconds: "Tempo estimado: ~{{seconds}} segundos",
          estimated_time_minutes: "Tempo estimado: ~{{minutes}} minuto(s)"
        },
        warning: {
          title: "\u26A0\uFE0F Importante:",
          text: "Se escolher 'N\xE3o', os ficheiros existentes permanecer\xE3o na localiza\xE7\xE3o antiga e n\xE3o ser\xE3o afetados por atualiza\xE7\xF5es futuras."
        },
        buttons: {
          cancel: "Cancelar",
          keep: "N\xE3o, manter os ficheiros na localiza\xE7\xE3o antiga",
          move: "Sim, mover os ficheiros",
          move_with_links: "Sim, mover os ficheiros e atualizar as liga\xE7\xF5es"
        },
        progress: {
          title_moving: "A mover {{folder_type}} e a atualizar liga\xE7\xF5es",
          step_moving_title: "A mover ficheiros...",
          step_moving_detail: "A mover de {{old_path}} para {{new_path}}",
          step_moving_count: "{{current}} / {{total}} ficheiros processados",
          step_moved_title: "Ficheiros movidos",
          step_moved_detail: "{{moved}} ficheiros movidos, {{skipped}} ignorados. A preparar a atualiza\xE7\xE3o de liga\xE7\xF5es...",
          step_updating_attachment_links: "A atualizar liga\xE7\xF5es de anexos...",
          step_updating_conversation_links: "A atualizar liga\xE7\xF5es de conversas...",
          step_updating_report_links: "A atualizar liga\xE7\xF5es nos relat\xF3rios...",
          step_updating_artifact_links: "A atualizar liga\xE7\xF5es nos artefactos...",
          complete_message: "{{moved}} ficheiros movidos. {{links}} liga\xE7\xF5es atualizadas com sucesso"
        },
        result_dialog: {
          title: "Resultado da migra\xE7\xE3o de pasta",
          summary_title: "Resumo da migra\xE7\xE3o",
          moved: "\u2705 Movidos com sucesso: {{count}} ficheiro(s)",
          skipped: "\u26A0\uFE0F Ignorados (j\xE1 existem): {{count}} ficheiro(s)",
          errors: "\u274C Erros: {{count}} ficheiro(s)",
          explanation: "Os ficheiros que j\xE1 existiam no destino n\xE3o foram substitu\xEDdos para preservar os seus dados.",
          error_details_title: "Detalhes dos erros:"
        },
        error_target_not_empty: {
          title: "A pasta de destino n\xE3o est\xE1 vazia",
          message: 'A pasta "{{path}}" j\xE1 cont\xE9m ficheiros.\n\nPara alterar a localiza\xE7\xE3o da pasta:\n\u2022 Mova os ficheiros existentes manualmente no Obsidian, OU\n\u2022 Escolha uma pasta vazia ou crie uma nova'
        },
        error_migration_failed: {
          title: "Migra\xE7\xE3o falhou",
          message_move: "Falha ao mover ficheiros: {{error}}",
          message_links: "Falha ao mover ficheiros ou atualizar liga\xE7\xF5es: {{error}}"
        }
      },
      folder_browser: {
        title: "Selecionar pasta",
        vault_root: "Raiz do cofre (/)",
        buttons: {
          create_new_folder: "Criar nova pasta",
          cancel: "Cancelar",
          select: "Selecionar"
        },
        create_folder_dialog: {
          title: "Criar nova pasta",
          folder_name_label: "Nome da pasta:",
          buttons: {
            cancel: "Cancelar",
            create: "Criar"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F Por favor, selecione primeiro uma pasta pai",
          invalid_name: "\u274C Nome de pasta inv\xE1lido: cont\xE9m caracteres ilegais",
          already_exists: "\u274C A pasta j\xE1 existe",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 Pasta criada: {{name}}",
          create_failed: "\u274C Falha ao criar pasta: {{error}}",
          select_first: "\u26A0\uFE0F Por favor, selecione primeiro uma pasta"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "Na vers\xE3o 1.3.0, pode especificar uma pasta para os relat\xF3rios. Os relat\xF3rios existentes ser\xE3o movidos para {{folder}}, ou pode selecionar a sua pasta preferida abaixo.",
        note: "Nota: A pasta n\xE3o pode estar dentro de Conversas ou Anexos.",
        report_folder_label: "\u{1F4CA} Pasta de relat\xF3rios",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "Procurar",
          proceed: "Prosseguir"
        },
        error_invalid_folder: {
          title: "Localiza\xE7\xE3o de pasta inv\xE1lida",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Obrigado por instalar o Nexus AI Chat Importer!",
        description: "Importe e fa\xE7a a gest\xE3o das suas conversas do ChatGPT, Claude e Le Chat diretamente no seu cofre do Obsidian.",
        resources_title: "Recursos",
        resources: {
          documentation: {
            title: "Documenta\xE7\xE3o",
            description: "Saiba como utilizar o plugin"
          },
          release_notes: {
            title: "Notas de vers\xE3o",
            description: "O que h\xE1 de novo nesta vers\xE3o"
          },
          report_issues: {
            title: "Reportar problemas",
            description: "Encontrou um erro? Diga-nos"
          },
          community_forum: {
            title: "F\xF3rum da comunidade",
            description: "Junte-se \xE0 discuss\xE3o"
          }
        },
        buttons: {
          get_started: "Come\xE7ar"
        }
      },
      notices: {
        import_analyzing: "A analisar conversas de {{count}} ficheiro(s)...",
        import_no_new: "N\xE3o foram encontradas conversas novas ou atualizadas. Todas as conversas j\xE1 est\xE3o atualizadas.",
        import_starting: "A importar {{count}} conversas ({{new}} novas, {{updated}} atualizadas)...",
        import_starting_selected: "A importar {{count}} conversas selecionadas de {{files}} ficheiro(s)...",
        import_completed_fallback: "Importa\xE7\xE3o conclu\xEDda. {{created}} criadas, {{updated}} atualizadas.",
        import_error: "Erro durante a importa\xE7\xE3o: {{error}}",
        import_error_analyzing: "Erro ao analisar conversas: {{error}}",
        import_error_file: "Erro ao processar {{filename}}. Consulte a consola para mais detalhes.",
        import_no_selected: "Nenhuma conversa selecionada para importar.",
        import_no_zip_gemini: "Por favor, selecione pelo menos um ficheiro ZIP do Gemini Takeout (mais o \xEDndice JSON opcional da extens\xE3o).",
        import_no_zip: "Por favor, selecione pelo menos um ficheiro ZIP de exporta\xE7\xE3o.",
        import_gemini_json_failed: "Falha ao ler o \xEDndice JSON do Gemini. A continuar sem \xEDndice.",
        report_failed: "Falha ao criar o ficheiro de registo. Consulte a consola para mais detalhes.",
        attachment_map_failed: "Falha ao construir o mapa de anexos. Consulte a consola para mais detalhes.",
        ribbon_tooltip: "Nexus AI Chat Importer - Importar novo ficheiro"
      },
      commands: {
        import_conversations: {
          name: "Importar conversas de IA"
        }
      },
      support_box: {
        header: "Apoiar este plugin",
        header_highlight: "Apoiar este plugin",
        default_message_emphasis: "Estou a trabalhar nos projetos Nexus a tempo inteiro enquanto estou desempregado e a lidar com problemas de sa\xFAde.",
        default_message: "Se este plugin facilita a sua vida, uma doa\xE7\xE3o significaria muito para mim e ajudaria a mant\xEA-los vivos.",
        reality_check: "Obrigado! Milhares de horas de trabalho foram dedicadas a estes plugins, e cada doa\xE7\xE3o ajuda-me a continuar a melhor\xE1-los enquanto lido com problemas de sa\xFAde cont\xEDnuos. Se este plugin facilita a sua vida, por favor considere apoiar-me.",
        button_alt: "Apoiar o meu trabalho"
      }
    };
  }
});

// src/i18n/locales/ko.json
var ko_default;
var init_ko = __esm({
  "src/i18n/locales/ko.json"() {
    ko_default = {
      common: {
        buttons: {
          cancel: "\uCDE8\uC18C",
          ok: "\uD655\uC778",
          select: "\uC120\uD0DD",
          browse: "\uCC3E\uC544\uBCF4\uAE30",
          continue: "\uACC4\uC18D",
          proceed: "\uC9C4\uD589",
          close: "\uC54C\uACA0\uC5B4\uC694!",
          create: "\uB9CC\uB4E4\uAE30",
          remove: "\uC81C\uAC70",
          run: "\uC2E4\uD589",
          complete: "\uC644\uB8CC",
          view_report: "\uBCF4\uACE0\uC11C \uBCF4\uAE30",
          get_started: "\uC2DC\uC791\uD558\uAE30",
          create_new_folder: "\uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30"
        },
        status: {
          new: "\uC2E0\uADDC",
          updated: "\uC5C5\uB370\uC774\uD2B8\uB428",
          unchanged: "\uBCC0\uACBD \uC5C6\uC74C",
          unknown: "\uC54C \uC218 \uC5C6\uC74C"
        },
        progress: {
          phase_validation: "\u{1F50D} \uC720\uD6A8\uC131 \uAC80\uC0AC",
          phase_scanning: "\u{1F4CB} \uC2A4\uCE94 \uC911",
          phase_processing: "\u2699\uFE0F \uCC98\uB9AC \uC911",
          phase_writing: "\u{1F4BE} \uC4F0\uB294 \uC911",
          phase_complete: "\u2705 \uC644\uB8CC",
          phase_error: "\u274C \uC624\uB958"
        }
      },
      provider_selection: {
        title: "\uC544\uCE74\uC774\uBE0C \uC81C\uACF5\uC790 \uC120\uD0DD",
        providers: {
          chatgpt: {
            name: "ChatGPT",
            description: "OpenAI ChatGPT \uB300\uD654 \uB0B4\uBCF4\uB0B4\uAE30"
          },
          claude: {
            name: "Claude",
            description: "Anthropic Claude \uB300\uD654 \uB0B4\uBCF4\uB0B4\uAE30"
          },
          lechat: {
            name: "Le Chat",
            description: "Mistral AI Le Chat \uB300\uD654 \uB0B4\uBCF4\uB0B4\uAE30"
          }
        },
        buttons: {
          select: "\uC120\uD0DD",
          cancel: "\uCDE8\uC18C"
        }
      },
      file_selection: {
        title: "{{provider}} \uB300\uD654 \uAC00\uC838\uC624\uAE30",
        import_mode: {
          section_title: "\uAC00\uC838\uC624\uAE30 \uBC29\uC2DD",
          all_label: "\uC804\uCCB4 \uAC00\uC838\uC624\uAE30",
          all_description: "\uBAA8\uB4E0 \uB300\uD654\uB97C \uAC00\uC838\uC635\uB2C8\uB2E4 (\uB354 \uBE60\uB984)",
          selective_label: "\uAC1C\uBCC4 \uC120\uD0DD",
          selective_description: "\uB300\uD654\uB97C \uBBF8\uB9AC \uBCF4\uACE0 \uC120\uD0DD\uD569\uB2C8\uB2E4"
        },
        file_area: {
          section_title: "\uD30C\uC77C \uC120\uD0DD",
          drop_text_default: "ZIP \uD30C\uC77C\uC744 \uC5EC\uAE30\uC5D0 \uB04C\uC5B4\uB2E4 \uB193\uAC70\uB098 \uD074\uB9AD\uD558\uC5EC \uCC3E\uC544\uBCF4\uAE30",
          drop_text_gemini: "ZIP \uBC0F JSON \uD30C\uC77C\uC744 \uC5EC\uAE30\uC5D0 \uB04C\uC5B4\uB2E4 \uB193\uAC70\uB098 \uD074\uB9AD\uD558\uC5EC \uCC3E\uC544\uBCF4\uAE30",
          drop_subtext_default: "\uC5EC\uB7EC \uD30C\uC77C \uC120\uD0DD \uC9C0\uC6D0",
          drop_subtext_gemini: "ZIP (Takeout) + \uC120\uD0DD\uC801 JSON (\uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8\uC758 \uC778\uB371\uC2A4)"
        },
        selected_files: {
          section_title: "\uC120\uD0DD\uB41C \uD30C\uC77C",
          remove_button: "\uC81C\uAC70"
        },
        buttons: {
          cancel: "\uCDE8\uC18C",
          continue: "\uACC4\uC18D"
        }
      },
      conversation_selection: {
        title: "\uAC00\uC838\uC62C \uB300\uD654 \uC120\uD0DD",
        controls: {
          select_all: "\uC804\uCCB4 \uC120\uD0DD",
          select_none: "\uC120\uD0DD \uD574\uC81C",
          search_placeholder: "\uB300\uD654 \uAC80\uC0C9...",
          status_label: "\uC0C1\uD0DC:",
          show_label: "\uD45C\uC2DC:"
        },
        status_filter_options: {
          all: "\uC804\uCCB4",
          new: "\uC2E0\uADDC",
          updated: "\uC5C5\uB370\uC774\uD2B8\uB428",
          unchanged: "\uBCC0\uACBD \uC5C6\uC74C"
        },
        table_headers: {
          title: "\uC81C\uBAA9",
          created: "\uC0DD\uC131\uC77C",
          updated: "\uC5C5\uB370\uC774\uD2B8\uC77C",
          messages: "\uBA54\uC2DC\uC9C0",
          status: "\uC0C1\uD0DC"
        },
        status_badges: {
          new: "\uC2E0\uADDC",
          updated: "\uC5C5\uB370\uC774\uD2B8\uB428",
          unchanged: "\uBCC0\uACBD \uC5C6\uC74C",
          unknown: "\uC54C \uC218 \uC5C6\uC74C",
          tooltip_new: "\uC774 \uB300\uD654\uB294 \uBCF4\uAD00\uD568\uC5D0 \uC5C6\uC2B5\uB2C8\uB2E4",
          tooltip_updated: "\uC774 \uB300\uD654\uB294 \uBCF4\uAD00\uD568\uC758 \uBC84\uC804\uBCF4\uB2E4 \uCD5C\uC2E0 \uB0B4\uC6A9\uC744 \uD3EC\uD568\uD569\uB2C8\uB2E4 ({{existing_date}} \u2192 {{new_date}})",
          tooltip_unchanged: "\uC774 \uB300\uD654\uB294 \uBCF4\uAD00\uD568\uC758 \uBC84\uC804\uACFC \uB3D9\uC77C\uD569\uB2C8\uB2E4"
        },
        pagination: {
          showing: "\uC804\uCCB4 {{total}}\uAC1C \uC911 {{start}}\u2013{{end}}\uAC1C \uD45C\uC2DC",
          page_of: "{{total}}\uD398\uC774\uC9C0 \uC911 {{current}}\uD398\uC774\uC9C0",
          previous: "\uC774\uC804",
          next: "\uB2E4\uC74C"
        },
        summary: {
          unique_conversations: "\uACE0\uC720 \uB300\uD654",
          new: "\uC2E0\uADDC",
          updated: "\uC5C5\uB370\uC774\uD2B8\uB428",
          unchanged: "\uBCC0\uACBD \uC5C6\uC74C",
          selected_of: "{{total}}\uAC1C \uC911 {{selected}}\uAC1C \uC120\uD0DD\uB428"
        },
        buttons: {
          cancel: "\uCDE8\uC18C",
          import_selected: "\uC120\uD0DD \uD56D\uBAA9 \uAC00\uC838\uC624\uAE30",
          import_selected_count: "\uC120\uD0DD\uD55C {{count}}\uAC1C \uAC00\uC838\uC624\uAE30"
        },
        date_unknown: "\uC54C \uC218 \uC5C6\uC74C"
      },
      import_progress: {
        title: "{{filename}} \uAC00\uC838\uC624\uB294 \uC911",
        initial: {
          title: "\uAC00\uC838\uC624\uAE30 \uC900\uBE44 \uC911...",
          detail: "ZIP \uD30C\uC77C \uAD6C\uC870\uB97C \uD655\uC778\uD558\uB294 \uC911"
        },
        conversation_counter: "{{current}}/{{total}}\uAC1C \uB300\uD654",
        conversation_counter_selective: "{{current}}/{{total}}\uAC1C \uC120\uD0DD\uB41C \uB300\uD654",
        selective_mode_indicator: "\u{1F4CB} \uC120\uD0DD \uAC00\uC838\uC624\uAE30: {{total}}\uAC1C \uC911 {{selected}}\uAC1C",
        complete: {
          message: "\uAC00\uC838\uC624\uAE30\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
          detail: "\uC774 \uCC3D\uC744 \uB2EB\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4"
        },
        error: {
          message: "\uAC00\uC838\uC624\uB294 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4",
          detail: "\uC790\uC138\uD55C \uB0B4\uC6A9\uC740 \uCF58\uC194\uC744 \uD655\uC778\uD558\uC138\uC694"
        }
      },
      import_completion: {
        title: "\uAC00\uC838\uC624\uAE30 \uC644\uB8CC",
        success_message: "\u2705 \uB300\uD654\uB97C \uC131\uACF5\uC801\uC73C\uB85C \uAC00\uC838\uC654\uC2B5\uB2C8\uB2E4",
        stats: {
          zip_files_processed: "\uCC98\uB9AC\uB41C ZIP \uD30C\uC77C",
          unique_conversations: "\uACE0\uC720 \uB300\uD654",
          duplicates: "\uC911\uBCF5",
          new: "\uC2E0\uADDC",
          updated: "\uC5C5\uB370\uC774\uD2B8\uB428",
          skipped: "\uAC74\uB108\uB700",
          failed: "\uC2E4\uD328"
        },
        attachments: {
          label: "\uCCA8\uBD80 \uD30C\uC77C:",
          summary: "{{found}}/{{total}}\uAC1C \uCD94\uCD9C\uB428 ({{percentage}}%)",
          missing_failed: "{{missing}}\uAC1C \uC5C6\uC74C, {{failed}}\uAC1C \uC2E4\uD328"
        },
        report: {
          label: "\u{1F4C4} \uC0C1\uC138 \uBCF4\uACE0\uC11C:"
        },
        buttons: {
          view_report: "\uBCF4\uACE0\uC11C \uBCF4\uAE30",
          ok: "\uD655\uC778"
        }
      },
      settings: {
        tab_title: "Nexus AI Chat Importer",
        folders: {
          section_title: "\u{1F4C1} \uD3F4\uB354 \uAD6C\uC870",
          conversation_folder: {
            name: "\uB300\uD654 \uD3F4\uB354",
            desc: "\uAC00\uC838\uC628 \uB300\uD654\uAC00 \uC800\uC7A5\uB418\uB294 \uC704\uCE58",
            placeholder: "Nexus/Conversations",
            browse_tooltip: "\uD3F4\uB354 \uCC3E\uC544\uBCF4\uAE30 \uB610\uB294 \uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30"
          },
          reports_folder: {
            name: "\uBCF4\uACE0\uC11C \uD3F4\uB354",
            desc: "\uAC00\uC838\uC624\uAE30 \uBCF4\uACE0\uC11C\uAC00 \uC800\uC7A5\uB418\uB294 \uC704\uCE58",
            placeholder: "Nexus Reports",
            browse_tooltip: "\uD3F4\uB354 \uCC3E\uC544\uBCF4\uAE30 \uB610\uB294 \uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30"
          },
          attachment_folder: {
            name: "\uCCA8\uBD80 \uD30C\uC77C \uD3F4\uB354",
            desc: "\uCCA8\uBD80 \uD30C\uC77C\uC774 \uC800\uC7A5\uB418\uB294 \uC704\uCE58 (\u26A0\uFE0F \uC6A9\uB7C9 \uC808\uC57D\uC744 \uC704\uD574 \uB3D9\uAE30\uD654\uC5D0\uC11C \uC81C\uC678\uD558\uC138\uC694)",
            placeholder: "Nexus/Attachments",
            browse_tooltip: "\uD3F4\uB354 \uCC3E\uC544\uBCF4\uAE30 \uB610\uB294 \uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30"
          }
        },
        display: {
          section_title: "\u{1F4C5} \uB0A0\uC9DC \uC811\uB450\uC0AC",
          add_date_prefix: {
            name: "\uD30C\uC77C \uC774\uB984\uC5D0 \uB0A0\uC9DC \uC811\uB450\uC0AC \uCD94\uAC00",
            desc: "\uB300\uD654 \uD30C\uC77C \uC774\uB984 \uC55E\uC5D0 \uC0DD\uC131 \uB0A0\uC9DC\uB97C \uC811\uB450\uC0AC\uB85C \uCD94\uAC00\uD569\uB2C8\uB2E4",
            format_label: "\uB0A0\uC9DC \uD615\uC2DD \uC120\uD0DD: "
          }
        },
        timestamps: {
          section_title: "\u{1F4C5} \uBA54\uC2DC\uC9C0 \uB0A0\uC9DC \uD615\uC2DD",
          custom_format: {
            name: "\uBA54\uC2DC\uC9C0 \uD0C0\uC784\uC2A4\uD0EC\uD504 \uD615\uC2DD \uC0AC\uC6A9\uC790 \uC9C0\uC815",
            desc: "\uBA54\uC2DC\uC9C0 \uD5E4\uB354\uC758 \uAE30\uBCF8 \uB85C\uCF00\uC77C \uAE30\uBC18 \uD0C0\uC784\uC2A4\uD0EC\uD504 \uD615\uC2DD\uC744 \uC7AC\uC815\uC758\uD569\uB2C8\uB2E4. \uBE44\uD65C\uC131\uD654\uB418\uBA74 \uD0C0\uC784\uC2A4\uD0EC\uD504\uB294 Obsidian\uC758 \uC5B8\uC5B4 \uC124\uC815\uC744 \uB530\uB985\uB2C8\uB2E4. Obsidian\uC774 \uC601\uC5B4\uB85C \uC124\uC815\uB41C \uACBD\uC6B0 \uBBF8\uAD6D \uD615\uC2DD(YYYY/DD/MM)\uC774 \uC801\uC6A9\uB429\uB2C8\uB2E4."
          },
          timestamp_format: {
            name: "\uD0C0\uC784\uC2A4\uD0EC\uD504 \uD615\uC2DD",
            desc: "\uB300\uD654 \uB178\uD2B8\uC758 \uBA54\uC2DC\uC9C0 \uD0C0\uC784\uC2A4\uD0EC\uD504 \uD615\uC2DD\uC744 \uC120\uD0DD\uD569\uB2C8\uB2E4"
          },
          preview_label: "\uBBF8\uB9AC \uBCF4\uAE30: "
        },
        attachments: {
          section_title: "\uCCA8\uBD80 \uD30C\uC77C \uC124\uC815",
          import_attachments: {
            name: "\uCCA8\uBD80 \uD30C\uC77C \uAC00\uC838\uC624\uAE30",
            desc: "\uCCA8\uBD80 \uD30C\uC77C\uC744 \uB514\uC2A4\uD06C\uC5D0 \uC800\uC7A5\uD558\uACE0 \uB300\uD654\uC5D0 \uC5F0\uACB0\uD569\uB2C8\uB2E4 ('\uCD5C\uC120 \uB178\uB825' \uC804\uB7B5 \uC0AC\uC6A9)"
          },
          handle_missing: {
            name: "\uB204\uB77D\uB41C \uCCA8\uBD80 \uD30C\uC77C \uCC98\uB9AC",
            desc: "\uB0B4\uBCF4\uB0B4\uAE30\uC5D0 \uCCA8\uBD80 \uD30C\uC77C\uC774 \uC5C6\uC744 \uB54C \uAC74\uB108\uB6F0\uB294 \uB300\uC2E0 \uC548\uB0B4 \uB178\uD2B8\uB97C \uB9CC\uB4ED\uB2C8\uB2E4"
          },
          show_details: {
            name: "\uBCF4\uACE0\uC11C\uC5D0 \uCCA8\uBD80 \uD30C\uC77C \uC138\uBD80 \uC815\uBCF4 \uD45C\uC2DC",
            desc: "\uAC00\uC838\uC624\uAE30 \uBCF4\uACE0\uC11C\uC5D0 \uC0C1\uC138\uD55C \uCCA8\uBD80 \uD30C\uC77C \uCC98\uB9AC \uD1B5\uACC4\uB97C \uD3EC\uD568\uD569\uB2C8\uB2E4"
          },
          info_box: {
            title: "\u{1F4CE} \uCCA8\uBD80 \uD30C\uC77C \uCC98\uB9AC \uBC29\uC2DD",
            best_effort: "\uCD5C\uC120 \uB178\uB825 \uC804\uB7B5: \uB0B4\uBCF4\uB0B4\uAE30\uC5D0\uC11C \uCC3E\uC740 \uD30C\uC77C\uC740 \uCD94\uCD9C\uD558\uC5EC \uC5F0\uACB0\uD558\uACE0, \uC5C6\uB294 \uD30C\uC77C\uC740 \uC548\uB0B4 \uB178\uD2B8\uB97C \uB9CC\uB4ED\uB2C8\uB2E4.",
            platform_diff: "\uD50C\uB7AB\uD3FC \uCC28\uC774: ChatGPT \uB0B4\uBCF4\uB0B4\uAE30\uC5D0\uB294 \uD2B9\uD788 \uC624\uB798\uB41C \uB300\uD654\uC758 \uCCA8\uBD80 \uD30C\uC77C\uC774 \uBAA8\uB450 \uD3EC\uD568\uB418\uC9C0 \uC54A\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
            organization: "\uAC04\uB2E8\uD55C \uAD6C\uC131: \uD30C\uC77C\uC740 attachments/provider/category/ \uD615\uC2DD\uC73C\uB85C \uAD6C\uC131\uB429\uB2C8\uB2E4 (\uC608: attachments/chatgpt/images/).",
            sync_tip: "\uB3D9\uAE30\uD654 \uD301: \uB300\uC6A9\uB7C9 \uD30C\uC77C \uC5C5\uB85C\uB4DC\uB97C \uBC29\uC9C0\uD558\uB824\uBA74 \uCCA8\uBD80 \uD30C\uC77C \uD3F4\uB354\uB97C \uB3D9\uAE30\uD654\uC5D0\uC11C \uC81C\uC678\uD558\uB294 \uAC83\uC744 \uAD8C\uC7A5\uD569\uB2C8\uB2E4.",
            tip: "\u{1F4A1} \uD301: '\uCCA8\uBD80 \uD30C\uC77C \uC138\uBD80 \uC815\uBCF4 \uD45C\uC2DC'\uB97C \uD65C\uC131\uD654\uD558\uBA74 \uAC00\uC838\uC624\uAE30 \uC911 \uCC3E\uC740 \uD30C\uC77C, \uC5C6\uB294 \uD30C\uC77C, \uC2E4\uD328\uD55C \uD30C\uC77C\uC744 \uC815\uD655\uD558\uAC8C \uD655\uC778\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
          }
        },
        migrations: {
          section_title: "\uB9C8\uC774\uADF8\uB808\uC774\uC158",
          description_manual: "\uC218\uB3D9 \uC791\uC5C5: \uD3B8\uB9AC\uD55C \uC2DC\uAC04\uC5D0 \uC2E4\uD589\uD560 \uC218 \uC788\uB294 \uC120\uD0DD\uC801 \uC5C5\uADF8\uB808\uC774\uB4DC \uC791\uC5C5\uC785\uB2C8\uB2E4.",
          description_automatic: "\uC790\uB3D9 \uC791\uC5C5(\uC608: \uC774\uC804 \uB370\uC774\uD130 \uC81C\uAC70)\uC740 \uC5C5\uADF8\uB808\uC774\uB4DC \uC911 \uC790\uB3D9\uC73C\uB85C \uC2E4\uD589\uB418\uBA70 \uC5EC\uAE30\uC5D0 \uD45C\uC2DC\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          version_header: "\uBC84\uC804 {{version}}",
          no_migrations: {
            title: "\uC218\uB3D9 \uC791\uC5C5\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
            desc: "\uBAA8\uB4E0 \uC5C5\uADF8\uB808\uC774\uB4DC \uC791\uC5C5\uC774 \uC790\uB3D9\uC73C\uB85C \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4."
          },
          operation_completed_suffix: " \u2705 \uC644\uB8CC\uB428",
          buttons: {
            completed: "\u2705 \uC644\uB8CC\uB428",
            cannot_run: "\uC2E4\uD589 \uBD88\uAC00",
            run: "\uC2E4\uD589",
            running: "\uC2E4\uD589 \uC911..."
          },
          tooltips: {
            completed: "\uC774 \uC791\uC5C5\uC740 \uC774\uBBF8 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
            cannot_run: "\uC774 \uC791\uC5C5\uC758 \uC804\uC81C \uC870\uAC74\uC774 \uCDA9\uC871\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4",
            run: "{{operation_name}} \uC2E4\uD589"
          },
          error_loading: "\uB9C8\uC774\uADF8\uB808\uC774\uC158 \uB85C\uB4DC \uC624\uB958:"
        },
        support: {
          section_title: "\u{1F49D} \uC9C0\uC6D0 \uBC0F \uB3C4\uC6C0\uB9D0",
          resources: {
            name: "\u{1F4DA} \uB9AC\uC18C\uC2A4",
            desc: "\uBB38\uC11C, \uB9B4\uB9AC\uC2A4 \uB178\uD2B8, \uCEE4\uBBA4\uB2C8\uD2F0 \uB9C1\uD06C",
            documentation: "\u{1F4D6} \uBB38\uC11C",
            release_notes: "\u{1F4DD} \uB9B4\uB9AC\uC2A4 \uB178\uD2B8",
            issues: "\u{1F41B} \uBB38\uC81C \uBCF4\uACE0",
            forum: "\u{1F4AC} \uD3EC\uB7FC"
          }
        }
      },
      upgrade: {
        progress_modal: {
          starting: "\uC2DC\uC791 \uC911...",
          progress_label: "\uC9C4\uD589\uB960: {{percentage}}%",
          step_label: "\uB2E8\uACC4 {{current}}/{{total}}",
          complete_label: "\uC644\uB8CC",
          complete_message: "\uC131\uACF5\uC801\uC73C\uB85C \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
          error_message: "\uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4"
        },
        multi_operation_modal: {
          progress_label: "\uC9C4\uD589\uB960: {{completed}}/{{total}}\uAC1C \uC791\uC5C5",
          progress_with_failures: "\uC9C4\uD589\uB960: {{completed}}/{{total}}\uAC1C \uC791\uC5C5 ({{failed}}\uAC1C \uC2E4\uD328)",
          all_completed: "\uCD1D {{total}}\uAC1C \uC791\uC5C5\uC774 \uBAA8\uB450 \uC131\uACF5\uC801\uC73C\uB85C \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
          mark_complete_default: "\uBAA8\uB4E0 \uC791\uC5C5\uC774 \uC131\uACF5\uC801\uC73C\uB85C \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
          buttons: {
            complete: "\uC644\uB8CC",
            close: "\uB2EB\uAE30"
          }
        },
        modal_130: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          migration_section: {
            title: "\u{1F504} \uB9C8\uC774\uADF8\uB808\uC774\uC158 \uD544\uC694",
            message: "\uB370\uC774\uD130\uB97C v1.3.0\uC73C\uB85C \uC5C5\uADF8\uB808\uC774\uB4DC\uD558\uAE30 \uC704\uD574 \uB2E4\uC74C \uC791\uC5C5\uC774 \uC790\uB3D9\uC73C\uB85C \uC2E4\uD589\uB429\uB2C8\uB2E4:",
            tasks: {
              folder_settings: "\u2713 \uD3F4\uB354 \uC124\uC815\uC744 \uC0C8 \uAD6C\uC870\uB85C \uB9C8\uC774\uADF8\uB808\uC774\uC158",
              timestamps: "\u2713 \uD0C0\uC784\uC2A4\uD0EC\uD504\uB97C ISO 8601 \uD615\uC2DD\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8",
              aliases: "\u2713 frontmatter \uBCC4\uCE6D \uC218\uC815",
              reports: "\u2713 \uBCF4\uACE0\uC11C \uD3F4\uB354\uB97C \uC62C\uBC14\uB978 \uC704\uCE58\uB85C \uC774\uB3D9",
              artifacts: "\u2713 \uC544\uD2F0\uD329\uD2B8 \uBA54\uD0C0\uB370\uC774\uD130 \uC5C5\uB370\uC774\uD2B8"
            },
            estimate: "\uBA87 \uCD08\uAC00 \uC18C\uC694\uB429\uB2C8\uB2E4."
          },
          buttons: {
            run_migration: "\u{1F680} \uB9C8\uC774\uADF8\uB808\uC774\uC158 \uC791\uC5C5 \uC2E4\uD589"
          }
        },
        complete_modal: {
          title: "\u2705 \uC5C5\uADF8\uB808\uC774\uB4DC \uC644\uB8CC - v{{version}}",
          buttons: {
            got_it: "\uC54C\uACA0\uC5B4\uC694!"
          }
        },
        new_version_modal: {
          title: "\u{1F389} Nexus AI Chat Importer {{version}}",
          buttons: {
            got_it: "\uC54C\uACA0\uC5B4\uC694!"
          }
        }
      },
      folder_migration: {
        title: "\uAE30\uC874 \uD30C\uC77C\uC744 \uC774\uB3D9\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
        message_intro: "{{folder_type}} \uD3F4\uB354 \uC704\uCE58\uB97C \uBCC0\uACBD\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4:",
        path_from: "\uC774\uC804 \uC704\uCE58: {{path}}",
        path_to: "\uC0C8 \uC704\uCE58: {{path}}",
        question: "\uAE30\uC874 \uD30C\uC77C\uC744 \uC0C8 \uC704\uCE58\uB85C \uC774\uB3D9\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
        link_updates: {
          title: "\u{1F517} \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8:",
          attachments_text: "\uCCA8\uBD80 \uD30C\uC77C\uC744 \uC774\uB3D9\uD558\uBA74 \uD574\uB2F9 \uD30C\uC77C\uC744 \uCC38\uC870\uD558\uB294 \uBAA8\uB4E0 \uB300\uD654 \uB178\uD2B8\uB3C4 \uC5C5\uB370\uC774\uD2B8\uB429\uB2C8\uB2E4.",
          conversations_text: "\uB300\uD654\uB97C \uC774\uB3D9\uD558\uBA74 \uD574\uB2F9 \uB300\uD654\uB97C \uCC38\uC870\uD558\uB294 \uBAA8\uB4E0 \uBCF4\uACE0\uC11C\uC640 \uCCA8\uBD80 \uD30C\uC77C\uB3C4 \uC5C5\uB370\uC774\uD2B8\uB429\uB2C8\uB2E4.",
          estimated_time_seconds: "\uC608\uC0C1 \uC2DC\uAC04: \uC57D {{seconds}}\uCD08",
          estimated_time_minutes: "\uC608\uC0C1 \uC2DC\uAC04: \uC57D {{minutes}}\uBD84"
        },
        warning: {
          title: "\u26A0\uFE0F \uC911\uC694:",
          text: "'\uC544\uB2C8\uC694'\uB97C \uC120\uD0DD\uD558\uBA74 \uAE30\uC874 \uD30C\uC77C\uC774 \uC774\uC804 \uC704\uCE58\uC5D0 \uADF8\uB300\uB85C \uB0A8\uC544 \uD5A5\uD6C4 \uC5C5\uB370\uC774\uD2B8\uC5D0 \uC601\uD5A5\uC744 \uBC1B\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4."
        },
        buttons: {
          cancel: "\uCDE8\uC18C",
          keep: "\uC544\uB2C8\uC694, \uC774\uC804 \uC704\uCE58\uC5D0 \uD30C\uC77C \uC720\uC9C0",
          move: "\uC608, \uD30C\uC77C \uC774\uB3D9",
          move_with_links: "\uC608, \uD30C\uC77C \uC774\uB3D9 \uBC0F \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8"
        },
        progress: {
          title_moving: "{{folder_type}} \uC774\uB3D9 \uBC0F \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC911",
          step_moving_title: "\uD30C\uC77C \uC774\uB3D9 \uC911...",
          step_moving_detail: "{{old_path}}\uC5D0\uC11C {{new_path}}\uB85C \uC774\uB3D9 \uC911",
          step_moving_count: "{{current}} / {{total}}\uAC1C \uD30C\uC77C \uCC98\uB9AC\uB428",
          step_moved_title: "\uD30C\uC77C \uC774\uB3D9 \uC644\uB8CC",
          step_moved_detail: "{{moved}}\uAC1C \uD30C\uC77C \uC774\uB3D9\uB428, {{skipped}}\uAC1C \uAC74\uB108\uB700. \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC900\uBE44 \uC911...",
          step_updating_attachment_links: "\uCCA8\uBD80 \uD30C\uC77C \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC911...",
          step_updating_conversation_links: "\uB300\uD654 \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC911...",
          step_updating_report_links: "\uBCF4\uACE0\uC11C\uC758 \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC911...",
          step_updating_artifact_links: "\uC544\uD2F0\uD329\uD2B8\uC758 \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC911...",
          complete_message: "{{moved}}\uAC1C \uD30C\uC77C \uC774\uB3D9\uB428. {{links}}\uAC1C \uB9C1\uD06C\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4"
        },
        result_dialog: {
          title: "\uD3F4\uB354 \uB9C8\uC774\uADF8\uB808\uC774\uC158 \uACB0\uACFC",
          summary_title: "\uB9C8\uC774\uADF8\uB808\uC774\uC158 \uC694\uC57D",
          moved: "\u2705 \uC131\uACF5\uC801\uC73C\uB85C \uC774\uB3D9\uB428: {{count}}\uAC1C \uD30C\uC77C",
          skipped: "\u26A0\uFE0F \uAC74\uB108\uB700 (\uC774\uBBF8 \uC874\uC7AC): {{count}}\uAC1C \uD30C\uC77C",
          errors: "\u274C \uC624\uB958: {{count}}\uAC1C \uD30C\uC77C",
          explanation: "\uB300\uC0C1 \uC704\uCE58\uC5D0 \uC774\uBBF8 \uC874\uC7AC\uD558\uB294 \uD30C\uC77C\uC740 \uB370\uC774\uD130\uB97C \uBCF4\uD638\uD558\uAE30 \uC704\uD574 \uB36E\uC5B4\uC4F0\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.",
          error_details_title: "\uC624\uB958 \uC138\uBD80 \uC815\uBCF4:"
        },
        error_target_not_empty: {
          title: "\uB300\uC0C1 \uD3F4\uB354\uAC00 \uBE44\uC5B4 \uC788\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
          message: '\uD3F4\uB354 "{{path}}"\uC5D0 \uC774\uBBF8 \uD30C\uC77C\uC774 \uC788\uC2B5\uB2C8\uB2E4.\n\n\uD3F4\uB354 \uC704\uCE58\uB97C \uBCC0\uACBD\uD558\uB824\uBA74:\n\u2022 Obsidian\uC5D0\uC11C \uAE30\uC874 \uD30C\uC77C\uC744 \uC218\uB3D9\uC73C\uB85C \uC774\uB3D9\uD558\uAC70\uB098\n\u2022 \uBE44\uC5B4 \uC788\uB294 \uD3F4\uB354\uB97C \uC120\uD0DD\uD558\uAC70\uB098 \uC0C8 \uD3F4\uB354\uB97C \uB9CC\uB4DC\uC138\uC694'
        },
        error_migration_failed: {
          title: "\uB9C8\uC774\uADF8\uB808\uC774\uC158 \uC2E4\uD328",
          message_move: "\uD30C\uC77C \uC774\uB3D9 \uC2E4\uD328: {{error}}",
          message_links: "\uD30C\uC77C \uC774\uB3D9 \uB610\uB294 \uB9C1\uD06C \uC5C5\uB370\uC774\uD2B8 \uC2E4\uD328: {{error}}"
        }
      },
      folder_browser: {
        title: "\uD3F4\uB354 \uC120\uD0DD",
        vault_root: "\uBCF4\uAD00\uD568 \uB8E8\uD2B8 (/)",
        buttons: {
          create_new_folder: "\uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30",
          cancel: "\uCDE8\uC18C",
          select: "\uC120\uD0DD"
        },
        create_folder_dialog: {
          title: "\uC0C8 \uD3F4\uB354 \uB9CC\uB4E4\uAE30",
          folder_name_label: "\uD3F4\uB354 \uC774\uB984:",
          buttons: {
            cancel: "\uCDE8\uC18C",
            create: "\uB9CC\uB4E4\uAE30"
          }
        },
        notices: {
          select_parent_first: "\u26A0\uFE0F \uBA3C\uC800 \uC0C1\uC704 \uD3F4\uB354\uB97C \uC120\uD0DD\uD558\uC138\uC694",
          invalid_name: "\u274C \uC798\uBABB\uB41C \uD3F4\uB354 \uC774\uB984: \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uB294 \uBB38\uC790\uAC00 \uD3EC\uD568\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4",
          already_exists: "\u274C \uD3F4\uB354\uAC00 \uC774\uBBF8 \uC874\uC7AC\uD569\uB2C8\uB2E4",
          invalid_location: "\u274C {{error}}",
          created_success: "\u2705 \uD3F4\uB354\uB97C \uB9CC\uB4E4\uC5C8\uC2B5\uB2C8\uB2E4: {{name}}",
          create_failed: "\u274C \uD3F4\uB354 \uB9CC\uB4E4\uAE30 \uC2E4\uD328: {{error}}",
          select_first: "\u26A0\uFE0F \uBA3C\uC800 \uD3F4\uB354\uB97C \uC120\uD0DD\uD558\uC138\uC694"
        }
      },
      configure_folder_dialog: {
        title: "\u{1F389} Nexus AI Chat Importer v1.3.0",
        description: "\uBC84\uC804 1.3.0\uC5D0\uC11C\uB294 \uBCF4\uACE0\uC11C \uD3F4\uB354\uB97C \uC9C0\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uAE30\uC874 \uBCF4\uACE0\uC11C\uB294 {{folder}}\uB85C \uC774\uB3D9\uB418\uBA70, \uC544\uB798\uC5D0\uC11C \uC6D0\uD558\uB294 \uD3F4\uB354\uB97C \uC120\uD0DD\uD560 \uC218\uB3C4 \uC788\uC2B5\uB2C8\uB2E4.",
        note: "\uCC38\uACE0: \uC774 \uD3F4\uB354\uB294 \uB300\uD654 \uB610\uB294 \uCCA8\uBD80 \uD30C\uC77C \uD3F4\uB354 \uC548\uC5D0 \uC788\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
        report_folder_label: "\u{1F4CA} \uBCF4\uACE0\uC11C \uD3F4\uB354",
        report_folder_placeholder: "Nexus Reports",
        buttons: {
          browse: "\uCC3E\uC544\uBCF4\uAE30",
          proceed: "\uC9C4\uD589"
        },
        error_invalid_folder: {
          title: "\uC798\uBABB\uB41C \uD3F4\uB354 \uC704\uCE58",
          message: "{{error}}"
        }
      },
      welcome: {
        title: "Nexus AI Chat Importer {{version}}",
        icon: "\u{1F389}",
        heading: "Nexus AI Chat Importer\uB97C \uC124\uCE58\uD574 \uC8FC\uC154\uC11C \uAC10\uC0AC\uD569\uB2C8\uB2E4!",
        description: "ChatGPT, Claude, Le Chat\uC758 \uB300\uD654\uB97C Obsidian \uBCF4\uAD00\uD568\uC5D0\uC11C \uBC14\uB85C \uAC00\uC838\uC624\uACE0 \uAD00\uB9AC\uD558\uC138\uC694.",
        resources_title: "\uB9AC\uC18C\uC2A4",
        resources: {
          documentation: {
            title: "\uBB38\uC11C",
            description: "\uD50C\uB7EC\uADF8\uC778 \uC0AC\uC6A9\uBC95 \uC54C\uC544\uBCF4\uAE30"
          },
          release_notes: {
            title: "\uB9B4\uB9AC\uC2A4 \uB178\uD2B8",
            description: "\uC774\uBC88 \uBC84\uC804\uC758 \uC0C8\uB85C\uC6B4 \uAE30\uB2A5"
          },
          report_issues: {
            title: "\uBB38\uC81C \uBCF4\uACE0",
            description: "\uBC84\uADF8\uB97C \uBC1C\uACAC\uD558\uC168\uB098\uC694? \uC54C\uB824\uC8FC\uC138\uC694"
          },
          community_forum: {
            title: "\uCEE4\uBBA4\uB2C8\uD2F0 \uD3EC\uB7FC",
            description: "\uD1A0\uB860\uC5D0 \uCC38\uC5EC\uD558\uAE30"
          }
        },
        buttons: {
          get_started: "\uC2DC\uC791\uD558\uAE30"
        }
      },
      notices: {
        import_analyzing: "{{count}}\uAC1C \uD30C\uC77C\uC5D0\uC11C \uB300\uD654\uB97C \uBD84\uC11D\uD558\uB294 \uC911...",
        import_no_new: "\uC0C8\uB85C\uC6B4 \uB300\uD654\uB098 \uC5C5\uB370\uC774\uD2B8\uB41C \uB300\uD654\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4. \uBAA8\uB4E0 \uB300\uD654\uAC00 \uC774\uBBF8 \uCD5C\uC2E0 \uC0C1\uD0DC\uC785\uB2C8\uB2E4.",
        import_starting: "{{count}}\uAC1C \uB300\uD654\uB97C \uAC00\uC838\uC624\uB294 \uC911 (\uC2E0\uADDC {{new}}\uAC1C, \uC5C5\uB370\uC774\uD2B8\uB428 {{updated}}\uAC1C)...",
        import_starting_selected: "{{files}}\uAC1C \uD30C\uC77C\uC5D0\uC11C \uC120\uD0DD\uD55C {{count}}\uAC1C \uB300\uD654\uB97C \uAC00\uC838\uC624\uB294 \uC911...",
        import_completed_fallback: "\uAC00\uC838\uC624\uAE30 \uC644\uB8CC. {{created}}\uAC1C \uC0DD\uC131\uB428, {{updated}}\uAC1C \uC5C5\uB370\uC774\uD2B8\uB428.",
        import_error: "\uAC00\uC838\uC624\uB294 \uC911 \uC624\uB958 \uBC1C\uC0DD: {{error}}",
        import_error_analyzing: "\uB300\uD654 \uBD84\uC11D \uC911 \uC624\uB958 \uBC1C\uC0DD: {{error}}",
        import_error_file: "{{filename}} \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uC790\uC138\uD55C \uB0B4\uC6A9\uC740 \uCF58\uC194\uC744 \uD655\uC778\uD558\uC138\uC694.",
        import_no_selected: "\uAC00\uC838\uC62C \uB300\uD654\uAC00 \uC120\uD0DD\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.",
        import_no_zip_gemini: "Gemini Takeout ZIP \uD30C\uC77C\uC744 \uD558\uB098 \uC774\uC0C1 \uC120\uD0DD\uD558\uC138\uC694 (\uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8\uC758 JSON \uC778\uB371\uC2A4\uB294 \uC120\uD0DD \uC0AC\uD56D).",
        import_no_zip: "ZIP \uB0B4\uBCF4\uB0B4\uAE30 \uD30C\uC77C\uC744 \uD558\uB098 \uC774\uC0C1 \uC120\uD0DD\uD558\uC138\uC694.",
        import_gemini_json_failed: "Gemini \uC778\uB371\uC2A4 JSON\uC744 \uC77D\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4. \uC778\uB371\uC2A4 \uC5C6\uC774 \uACC4\uC18D \uC9C4\uD589\uD569\uB2C8\uB2E4.",
        report_failed: "\uB85C\uADF8 \uD30C\uC77C\uC744 \uB9CC\uB4E4\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4. \uC790\uC138\uD55C \uB0B4\uC6A9\uC740 \uCF58\uC194\uC744 \uD655\uC778\uD558\uC138\uC694.",
        attachment_map_failed: "\uCCA8\uBD80 \uD30C\uC77C \uB9F5\uC744 \uB9CC\uB4E4\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4. \uC790\uC138\uD55C \uB0B4\uC6A9\uC740 \uCF58\uC194\uC744 \uD655\uC778\uD558\uC138\uC694.",
        ribbon_tooltip: "Nexus AI Chat Importer - \uC0C8 \uD30C\uC77C \uAC00\uC838\uC624\uAE30"
      },
      commands: {
        import_conversations: {
          name: "AI \uB300\uD654 \uAC00\uC838\uC624\uAE30"
        }
      },
      support_box: {
        header: "\uC774 \uD50C\uB7EC\uADF8\uC778 \uD6C4\uC6D0\uD558\uAE30",
        header_highlight: "\uC774 \uD50C\uB7EC\uADF8\uC778 \uD6C4\uC6D0\uD558\uAE30",
        default_message_emphasis: "\uC800\uB294 \uC2E4\uC9C1 \uC0C1\uD0DC\uC5D0\uC11C \uAC74\uAC15 \uBB38\uC81C\uB97C \uACAA\uC73C\uBA74\uC11C\uB3C4 Nexus \uD504\uB85C\uC81D\uD2B8\uC5D0 \uD480\uD0C0\uC784\uC73C\uB85C \uC784\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4.",
        default_message: "\uC774 \uD50C\uB7EC\uADF8\uC778\uC774 \uB3C4\uC6C0\uC774 \uB41C\uB2E4\uBA74, \uD6C4\uC6D0\uC740 \uC800\uC5D0\uAC8C \uD070 \uD798\uC774 \uB418\uACE0 \uD504\uB85C\uC81D\uD2B8\uB97C \uC9C0\uC18D\uD558\uB294 \uB370 \uD070 \uB3C4\uC6C0\uC774 \uB429\uB2C8\uB2E4.",
        reality_check: "\uAC10\uC0AC\uD569\uB2C8\uB2E4! \uC774 \uD50C\uB7EC\uADF8\uC778\uB4E4\uC5D0\uB294 \uC218\uCC9C \uC2DC\uAC04\uC758 \uC791\uC5C5\uC774 \uB2F4\uACA8 \uC788\uC73C\uBA70, \uD6C4\uC6D0 \uD558\uB098\uD558\uB098\uAC00 \uC9C0\uC18D\uC801\uC778 \uAC74\uAC15 \uBB38\uC81C\uB97C \uC548\uACE0\uB3C4 \uAC1C\uC120\uC744 \uC774\uC5B4\uB098\uAC00\uB294 \uC800\uC5D0\uAC8C \uD798\uC774 \uB429\uB2C8\uB2E4. \uC774 \uD50C\uB7EC\uADF8\uC778\uC774 \uC0B6\uC744 \uD3B8\uB9AC\uD558\uAC8C \uD574\uC900\uB2E4\uBA74 \uD6C4\uC6D0\uC744 \uACE0\uB824\uD574 \uC8FC\uC138\uC694.",
        button_alt: "\uB0B4 \uC791\uC5C5 \uD6C4\uC6D0\uD558\uAE30"
      }
    };
  }
});

// src/i18n/index.ts
function initLocale() {
  const lang = window.moment.locale();
  _locale = locales[lang] ? lang : "en";
}
function t(key, vars) {
  var _a, _b;
  const keys = key.split(".");
  const resolve = /* @__PURE__ */ __name((obj) => keys.reduce((o, k) => o && typeof o === "object" ? o[k] : void 0, obj), "resolve");
  let str = (_b = (_a = resolve(locales[_locale])) != null ? _a : resolve(locales["en"])) != null ? _b : key;
  if (vars) {
    for (const [k, v] of Object.entries(vars)) {
      str = str.split(`{{${k}}}`).join(v);
    }
  }
  return str;
}
var locales, _locale;
var init_i18n = __esm({
  "src/i18n/index.ts"() {
    "use strict";
    init_en();
    init_fr();
    init_de();
    init_es();
    init_it();
    init_ru();
    init_zh();
    init_ja();
    init_pt();
    init_ko();
    locales = {
      en: en_default,
      fr: fr_default,
      de: de_default,
      es: es_default,
      it: it_default,
      ru: ru_default,
      zh: zh_default,
      ja: ja_default,
      pt: pt_default,
      ko: ko_default
    };
    _locale = "en";
    __name(initLocale, "initLocale");
    __name(t, "t");
  }
});

// src/config/constants.ts
var DEFAULT_SETTINGS, GITHUB, PROVIDER_URLS, MESSAGE_TIMESTAMP_FORMATS;
var init_constants = __esm({
  "src/config/constants.ts"() {
    "use strict";
    DEFAULT_SETTINGS = {
      // ========================================
      // 📁 FOLDER STRUCTURE
      // ========================================
      conversationFolder: "Nexus/Conversations",
      reportFolder: "Nexus/Reports",
      attachmentFolder: "Nexus/Attachments",
      // ========================================
      // 🎨 DISPLAY OPTIONS
      // ========================================
      addDatePrefix: false,
      dateFormat: "YYYY-MM-DD",
      // Message timestamp format
      useCustomMessageTimestampFormat: false,
      messageTimestampFormat: "locale",
      // ========================================
      // 🔧 INTERNAL SETTINGS
      // ========================================
      lastConversationsPerPage: 50,
      // ========================================
      // 🔄 MIGRATION FLAGS
      // ========================================
      hasShownUpgradeNotice: false,
      hasSeenClaude132UpgradeNotice: false,
      hasCompletedUpgrade: false,
      currentVersion: "0.0.0",
      previousVersion: "0.0.0"
    };
    GITHUB = {
      RAW_BASE: "https://raw.githubusercontent.com/Superkikim/nexus-ai-chat-importer",
      REPO_BASE: "https://github.com/Superkikim/nexus-ai-chat-importer"
    };
    PROVIDER_URLS = {
      CHATGPT: {
        BASE: "https://chatgpt.com",
        CHAT: (id) => `https://chatgpt.com/c/${id}`
      },
      CLAUDE: {
        BASE: "https://claude.ai",
        CHAT: (id) => `https://claude.ai/chat/${id}`
      },
      LECHAT: {
        BASE: "https://chat.mistral.ai",
        CHAT: (id) => `https://chat.mistral.ai/chat/${id}`
      }
    };
    MESSAGE_TIMESTAMP_FORMATS = {
      locale: {
        label: "Auto (Obsidian Language)",
        description: "Follows Obsidian language setting",
        dateFormat: "L",
        // moment.js locale-aware
        timeFormat: "LTS",
        // moment.js locale-aware
        separator: " at "
      },
      iso: {
        label: "YYYY-MM-DD HH:mm:ss (Universal)",
        description: "YYYY-MM-DD HH:mm:ss - Sortable, unambiguous",
        dateFormat: "YYYY-MM-DD",
        timeFormat: "HH:mm:ss",
        separator: " "
      },
      us: {
        label: "MM/DD/YYYY h:mm:ss AM/PM (US)",
        description: "MM/DD/YYYY h:mm:ss AM/PM",
        dateFormat: "MM/DD/YYYY",
        timeFormat: "h:mm:ss A",
        separator: " at "
      },
      eu: {
        label: "DD/MM/YYYY HH:mm:ss (Europe)",
        description: "DD/MM/YYYY HH:mm:ss",
        dateFormat: "DD/MM/YYYY",
        timeFormat: "HH:mm:ss",
        separator: " at "
      },
      de: {
        label: "DD.MM.YYYY HH:mm:ss (German/Swiss)",
        description: "DD.MM.YYYY HH:mm:ss",
        dateFormat: "DD.MM.YYYY",
        timeFormat: "HH:mm:ss",
        separator: " "
      },
      jp: {
        label: "YYYY/MM/DD HH:mm:ss (Japanese)",
        description: "YYYY/MM/DD HH:mm:ss",
        dateFormat: "YYYY/MM/DD",
        timeFormat: "HH:mm:ss",
        separator: " "
      }
    };
  }
});

// src/ui/components/support-box.ts
function createSupportBox(container, message) {
  const supportBox = container.createDiv("nexus-support-box");
  const header = supportBox.createDiv("nexus-support-header");
  header.innerHTML = `<span class="nexus-support-header-highlight">${t("support_box.header_highlight")}</span>`;
  const messageEl = supportBox.createDiv("nexus-support-message");
  if (message) {
    const paragraphs = message.split("\n\n");
    messageEl.innerHTML = paragraphs.map((p) => {
      const hasStats = /\d{1,3}[',]\d{3}|\$\d+/.test(p);
      if (hasStats) {
        return `<p><span class="nexus-support-message-emphasis">${p}</span></p>`;
      }
      return `<p>${p}</p>`;
    }).join("");
  } else {
    messageEl.innerHTML = `
            <p><span class="nexus-support-message-emphasis">${t("support_box.default_message_emphasis")}</span></p>
            <p>${t("support_box.default_message")}</p>
        `;
  }
  const realityCheck = supportBox.createDiv("nexus-support-reality-check");
  realityCheck.innerHTML = t("support_box.reality_check");
  const locale = window.moment.locale();
  const supported = ["fr", "de", "es", "it", "ru", "zh", "ja", "pt", "ko"];
  const supportUrl = supported.includes(locale) ? `https://nexus-prod.dev/${locale}/nexus-ai-chat-importer/support` : "https://nexus-prod.dev/nexus-ai-chat-importer/support";
  const buttonContainer = supportBox.createDiv("nexus-support-button-container");
  buttonContainer.innerHTML = `
        <a href="${supportUrl}" target="_blank" class="nexus-support-link">
            ${t("support_box.button_alt")}
        </a>
    `;
}
var init_support_box = __esm({
  "src/ui/components/support-box.ts"() {
    "use strict";
    init_i18n();
    __name(createSupportBox, "createSupportBox");
  }
});

// src/dialogs/folder-tree-browser-modal.ts
var import_obsidian3, FolderTreeBrowserModal;
var init_folder_tree_browser_modal = __esm({
  "src/dialogs/folder-tree-browser-modal.ts"() {
    "use strict";
    import_obsidian3 = require("obsidian");
    init_i18n();
    FolderTreeBrowserModal = class extends import_obsidian3.Modal {
      // Track folders created during this session
      constructor(app, onSubmit, initialPath, validatePath) {
        super(app);
        this.selectedFolder = null;
        this.expandedFolders = /* @__PURE__ */ new Set();
        this.createdFolders = /* @__PURE__ */ new Set();
        this.onSubmit = onSubmit;
        this.validatePath = validatePath;
        if (initialPath) {
          const folder = this.app.vault.getAbstractFileByPath(initialPath);
          if (folder instanceof import_obsidian3.TFolder) {
            this.selectedFolder = folder;
            let current = folder.parent;
            while (current && current.path !== "/") {
              this.expandedFolders.add(current.path);
              current = current.parent;
            }
            this.expandedFolders.add(folder.path);
          }
        }
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h3", { text: t("folder_browser.title") });
        this.treeContainer = contentEl.createDiv({ cls: "nexus-folder-tree-container" });
        this.treeContainer.style.maxHeight = "400px";
        this.treeContainer.style.overflowY = "auto";
        this.treeContainer.style.marginBottom = "20px";
        this.treeContainer.style.border = "1px solid var(--background-modifier-border)";
        this.treeContainer.style.borderRadius = "4px";
        this.treeContainer.style.padding = "8px";
        this.renderTree();
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.gap = "8px";
        buttonContainer.style.justifyContent = "flex-end";
        const createButton = buttonContainer.createEl("button", { text: t("folder_browser.buttons.create_new_folder") });
        createButton.addEventListener("click", () => this.handleCreateFolder());
        const cancelButton = buttonContainer.createEl("button", { text: t("folder_browser.buttons.cancel") });
        cancelButton.addEventListener("click", () => this.handleCancel());
        const selectButton = buttonContainer.createEl("button", {
          text: t("folder_browser.buttons.select"),
          cls: "mod-cta"
        });
        selectButton.addEventListener("click", () => this.handleSelect());
      }
      renderTree() {
        this.treeContainer.empty();
        const root = this.app.vault.getRoot();
        const rootItem = this.treeContainer.createDiv({ cls: "nexus-tree-item" });
        rootItem.style.display = "flex";
        rootItem.style.alignItems = "center";
        rootItem.style.padding = "4px 8px";
        rootItem.style.cursor = "pointer";
        rootItem.style.borderRadius = "4px";
        if (this.selectedFolder === root) {
          rootItem.style.backgroundColor = "var(--background-modifier-hover)";
        }
        const rootIcon = rootItem.createSpan({ text: "\u{1F4C1} " });
        const rootLabel = rootItem.createSpan({ text: t("folder_browser.vault_root") });
        rootLabel.style.fontWeight = "bold";
        rootItem.addEventListener("click", (e) => {
          e.stopPropagation();
          this.handleFolderClick(root);
        });
        this.renderFolderChildren(root, 0);
      }
      renderFolderChildren(folder, depth) {
        const children = folder.children.filter((child) => child instanceof import_obsidian3.TFolder).sort((a, b) => a.name.localeCompare(b.name));
        for (const child of children) {
          this.renderFolder(child, depth + 1);
        }
      }
      renderFolder(folder, depth) {
        var _a;
        const isExpanded = this.expandedFolders.has(folder.path);
        const isSelected = ((_a = this.selectedFolder) == null ? void 0 : _a.path) === folder.path;
        const hasChildren = folder.children.some((c) => c instanceof import_obsidian3.TFolder);
        const item = this.treeContainer.createDiv({ cls: "nexus-tree-item" });
        item.style.display = "flex";
        item.style.alignItems = "center";
        item.style.padding = "4px 8px";
        item.style.paddingLeft = `${depth * 20 + 8}px`;
        item.style.cursor = "pointer";
        item.style.borderRadius = "4px";
        if (isSelected) {
          item.style.backgroundColor = "var(--background-modifier-hover)";
          item.style.fontWeight = "bold";
        }
        const expandIcon = item.createSpan();
        expandIcon.style.width = "16px";
        expandIcon.style.marginRight = "4px";
        if (hasChildren) {
          expandIcon.setText(isExpanded ? "\u25BC" : "\u25B6");
        } else {
          expandIcon.setText(" ");
        }
        item.createSpan({ text: "\u{1F4C1} " });
        item.createSpan({ text: folder.name });
        item.addEventListener("click", (e) => {
          e.stopPropagation();
          this.handleFolderClick(folder);
        });
        item.addEventListener("mouseenter", () => {
          if (!isSelected) {
            item.style.backgroundColor = "var(--background-modifier-hover-light)";
          }
        });
        item.addEventListener("mouseleave", () => {
          if (!isSelected) {
            item.style.backgroundColor = "";
          }
        });
        if (isExpanded && hasChildren) {
          this.renderFolderChildren(folder, depth);
        }
      }
      handleFolderClick(folder) {
        var _a;
        const wasExpanded = this.expandedFolders.has(folder.path);
        if (((_a = this.selectedFolder) == null ? void 0 : _a.path) === folder.path) {
          if (wasExpanded) {
            this.expandedFolders.delete(folder.path);
            this.collapseAllChildren(folder);
          } else {
            this.expandedFolders.add(folder.path);
          }
        } else {
          if (folder.parent) {
            const siblings = folder.parent.children.filter((c) => c instanceof import_obsidian3.TFolder);
            for (const sibling of siblings) {
              if (sibling.path !== folder.path) {
                this.expandedFolders.delete(sibling.path);
                this.collapseAllChildren(sibling);
              }
            }
          }
          this.selectedFolder = folder;
          this.expandedFolders.add(folder.path);
        }
        this.renderTree();
      }
      collapseAllChildren(folder) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian3.TFolder) {
            this.expandedFolders.delete(child.path);
            this.collapseAllChildren(child);
          }
        }
      }
      async handleCreateFolder() {
        var _a;
        if (!this.selectedFolder) {
          new import_obsidian3.Notice(t("folder_browser.notices.select_parent_first"));
          return;
        }
        const folderName = await this.promptForFolderName();
        if (!folderName) {
          return;
        }
        if (folderName.includes("/") || folderName.includes("\\") || folderName.includes(":") || folderName.includes("*") || folderName.includes("?") || folderName.includes('"') || folderName.includes("<") || folderName.includes(">") || folderName.includes("|")) {
          new import_obsidian3.Notice(t("folder_browser.notices.invalid_name"));
          return;
        }
        const parentPath = this.selectedFolder.path === "/" ? "" : this.selectedFolder.path;
        const newFolderPath = parentPath ? `${parentPath}/${folderName}` : folderName;
        const exists = this.app.vault.getAbstractFileByPath(newFolderPath);
        if (exists) {
          new import_obsidian3.Notice(t("folder_browser.notices.already_exists"));
          return;
        }
        if (this.validatePath) {
          const validation = this.validatePath(newFolderPath);
          if (!validation.valid) {
            new import_obsidian3.Notice(t("folder_browser.notices.invalid_location", { error: (_a = validation.error) != null ? _a : "Invalid folder location" }));
            return;
          }
        }
        try {
          await this.app.vault.createFolder(newFolderPath);
          this.createdFolders.add(newFolderPath);
          new import_obsidian3.Notice(t("folder_browser.notices.created_success", { name: folderName }));
          this.expandedFolders.add(this.selectedFolder.path);
          const newFolder = this.app.vault.getAbstractFileByPath(newFolderPath);
          if (newFolder instanceof import_obsidian3.TFolder) {
            this.selectedFolder = newFolder;
            this.expandedFolders.add(newFolder.path);
          }
          this.renderTree();
        } catch (error) {
          new import_obsidian3.Notice(t("folder_browser.notices.create_failed", { error: error.message }));
        }
      }
      promptForFolderName() {
        return new Promise((resolve) => {
          const modal = new import_obsidian3.Modal(this.app);
          modal.titleEl.setText(t("folder_browser.create_folder_dialog.title"));
          const inputContainer = modal.contentEl.createDiv();
          inputContainer.style.marginBottom = "20px";
          inputContainer.createEl("label", { text: t("folder_browser.create_folder_dialog.folder_name_label") });
          const input = inputContainer.createEl("input", { type: "text" });
          input.style.width = "100%";
          input.style.marginTop = "8px";
          const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
          const cancelButton = buttonContainer.createEl("button", { text: t("folder_browser.create_folder_dialog.buttons.cancel") });
          cancelButton.addEventListener("click", () => {
            modal.close();
            resolve(null);
          });
          const createButton = buttonContainer.createEl("button", {
            text: t("folder_browser.create_folder_dialog.buttons.create"),
            cls: "mod-cta"
          });
          createButton.addEventListener("click", () => {
            const value = input.value.trim();
            modal.close();
            resolve(value || null);
          });
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              const value = input.value.trim();
              modal.close();
              resolve(value || null);
            } else if (e.key === "Escape") {
              modal.close();
              resolve(null);
            }
          });
          modal.open();
          input.focus();
        });
      }
      handleSelect() {
        var _a;
        if (!this.selectedFolder) {
          new import_obsidian3.Notice(t("folder_browser.notices.select_first"));
          return;
        }
        const path = this.selectedFolder.path === "/" ? "" : this.selectedFolder.path;
        if (this.validatePath) {
          const validation = this.validatePath(path);
          if (!validation.valid) {
            new import_obsidian3.Notice(t("folder_browser.notices.invalid_location", { error: (_a = validation.error) != null ? _a : "Invalid folder location" }));
            return;
          }
        }
        this.createdFolders.clear();
        this.onSubmit(path);
        this.close();
      }
      async handleCancel() {
        await this.cleanupCreatedFolders();
        this.close();
      }
      async cleanupCreatedFolders() {
        const sortedFolders = Array.from(this.createdFolders).sort((a, b) => {
          const depthA = a.split("/").length;
          const depthB = b.split("/").length;
          return depthB - depthA;
        });
        for (const folderPath of sortedFolders) {
          try {
            const folder = this.app.vault.getAbstractFileByPath(folderPath);
            if (folder instanceof import_obsidian3.TFolder && folder.children.length === 0) {
              await this.app.vault.delete(folder);
            }
          } catch (error) {
          }
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    __name(FolderTreeBrowserModal, "FolderTreeBrowserModal");
  }
});

// src/utils/folder-validation.ts
function isPathInsidePath(pathToCheck, existingPath) {
  if (!pathToCheck || !existingPath) {
    return false;
  }
  const normalizedCheck = pathToCheck.replace(/\/$/, "");
  const normalizedExisting = existingPath.replace(/\/$/, "");
  if (normalizedCheck === normalizedExisting) {
    return false;
  }
  return normalizedCheck.startsWith(normalizedExisting + "/");
}
function validateFolderNesting(folderType, newPath, conversationFolder, reportFolder, attachmentFolder) {
  const normalizedNewPath = newPath.trim().replace(/\/$/, "");
  if (!normalizedNewPath) {
    return {
      valid: false,
      error: "Folder path cannot be empty"
    };
  }
  switch (folderType) {
    case "conversationFolder":
      if (isPathInsidePath(normalizedNewPath, reportFolder)) {
        return {
          valid: false,
          error: `Conversation folder cannot be inside the Report folder (${reportFolder})`
        };
      }
      if (isPathInsidePath(normalizedNewPath, attachmentFolder)) {
        return {
          valid: false,
          error: `Conversation folder cannot be inside the Attachment folder (${attachmentFolder})`
        };
      }
      break;
    case "reportFolder":
      if (isPathInsidePath(normalizedNewPath, conversationFolder)) {
        return {
          valid: false,
          error: `Report folder cannot be inside the Conversation folder (${conversationFolder})`
        };
      }
      if (isPathInsidePath(normalizedNewPath, attachmentFolder)) {
        return {
          valid: false,
          error: `Report folder cannot be inside the Attachment folder (${attachmentFolder})`
        };
      }
      break;
    case "attachmentFolder":
      if (isPathInsidePath(normalizedNewPath, conversationFolder)) {
        return {
          valid: false,
          error: `Attachment folder cannot be inside the Conversation folder (${conversationFolder})`
        };
      }
      if (isPathInsidePath(normalizedNewPath, reportFolder)) {
        return {
          valid: false,
          error: `Attachment folder cannot be inside the Report folder (${reportFolder})`
        };
      }
      break;
  }
  return { valid: true };
}
var init_folder_validation = __esm({
  "src/utils/folder-validation.ts"() {
    "use strict";
    __name(isPathInsidePath, "isPathInsidePath");
    __name(validateFolderNesting, "validateFolderNesting");
  }
});

// src/logger.ts
var Logger, logger;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    Logger = class {
      debug(message, details) {
        console.debug(message, details || "");
      }
      info(message, details) {
        console.log(message);
      }
      warn(message, details) {
        console.warn(message);
      }
      error(message, details) {
        if (details !== void 0) {
          console.error(message, details);
        } else {
          console.error(message);
        }
      }
    };
    __name(Logger, "Logger");
    logger = new Logger();
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  addPrefix: () => addPrefix,
  checkConversationLink: () => checkConversationLink,
  compareTimestampsIgnoringSeconds: () => compareTimestampsIgnoringSeconds,
  createDatePrefix: () => createDatePrefix,
  doesFilePathExist: () => doesFilePathExist,
  ensureFolderExists: () => ensureFolderExists,
  formatMessageTimestamp: () => formatMessageTimestamp,
  formatTimestamp: () => formatTimestamp,
  formatTitle: () => formatTitle,
  generateConversationFileName: () => generateConversationFileName,
  generateFileName: () => generateFileName,
  generateSafeAlias: () => generateSafeAlias,
  generateUniqueFileName: () => generateUniqueFileName,
  generateYearMonthFolder: () => generateYearMonthFolder,
  getFileHash: () => getFileHash,
  isCustomError: () => isCustomError,
  isNexusRelated: () => isNexusRelated,
  isValidMessage: () => isValidMessage,
  moveAndMergeFolders: () => moveAndMergeFolders,
  truncateToMinute: () => truncateToMinute
});
function truncateToMinute(unixTime) {
  return Math.floor(unixTime / 60) * 60;
}
function compareTimestampsIgnoringSeconds(time1, time2) {
  return truncateToMinute(time1) - truncateToMinute(time2);
}
function formatMessageTimestamp(unixTime, customFormat) {
  const date = moment(unixTime * 1e3);
  if (!customFormat || customFormat === "locale") {
    return `${date.format("L")} at ${date.format("LTS")}`;
  }
  const format = MESSAGE_TIMESTAMP_FORMATS[customFormat];
  return `${date.format(format.dateFormat)}${format.separator}${date.format(format.timeFormat)}`;
}
function formatTimestamp(unixTime, format) {
  const date = moment(unixTime * 1e3);
  switch (format) {
    case "prefix":
      return date.format("YYYYMMDD");
    case "date":
      return date.format("L");
    case "time":
      return date.format("LTS");
  }
}
function generateYearMonthFolder(unixTime) {
  const date = new Date(unixTime * 1e3);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  return `${year}/${month}`;
}
function formatTitle(title) {
  return title.trim() || "Untitled";
}
function generateFileName(title) {
  let fileName = formatTitle(title).normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[<>:"\/\\|?*\n\r]+/g, "").replace(/\.{2,}/g, ".").trim();
  fileName = fileName.replace(/^[^\w\d\s]+/, "");
  fileName = fileName.replace(/\s+/g, " ").trim();
  if (!fileName || fileName.length === 0) {
    fileName = "Untitled";
  }
  if (fileName.startsWith(".")) {
    fileName = fileName.substring(1);
  }
  if (!fileName || fileName.length === 0) {
    fileName = "Untitled";
  }
  return fileName;
}
function addPrefix(filename, timeStamp, dateFormat) {
  const prefix = createDatePrefix(timeStamp, dateFormat);
  if (prefix) {
    filename = `${prefix} - ${filename}`;
  }
  return filename;
}
function createDatePrefix(timeStamp, dateFormat) {
  const date = new Date(timeStamp * 1e3);
  let prefix = "";
  if (dateFormat === "YYYY-MM-DD") {
    prefix = date.toISOString().split("T")[0];
  } else if (dateFormat === "YYYYMMDD") {
    prefix = date.toISOString().split("T")[0].replace(/-/g, "");
  }
  return prefix;
}
async function generateUniqueFileName(filePath, vaultAdapter) {
  let uniqueFileName = filePath;
  const baseName = filePath.replace(/\.md$/, "");
  let counter = 1;
  while (await vaultAdapter.exists(uniqueFileName)) {
    uniqueFileName = `${baseName} (${counter++}).md`;
  }
  return uniqueFileName;
}
async function doesFilePathExist(filePath, vault) {
  const file = vault.getAbstractFileByPath(filePath);
  return file !== null;
}
async function getFileHash(file) {
  if (!file.path) {
    return `mobile:${file.name}:${file.size}:${file.lastModified}`;
  }
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function generateConversationFileName(chatTitle, createTime, addDatePrefix, dateFormat) {
  const date = new Date(createTime * 1e3);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  let fileName = generateFileName(chatTitle);
  if (addDatePrefix) {
    const day = String(date.getDate()).padStart(2, "0");
    let prefix = "";
    if (dateFormat === "YYYY-MM-DD") {
      prefix = `${year}-${month}-${day}`;
    } else if (dateFormat === "YYYYMMDD") {
      prefix = `${year}${month}${day}`;
    }
    fileName = `${prefix} - ${fileName}`;
  }
  return fileName;
}
function generateSafeAlias(title) {
  if (!title || typeof title !== "string") {
    return "Untitled";
  }
  const startsWithYamlSpecial = title.startsWith("#") || title.startsWith("&") || title.startsWith("*") || title.startsWith("!") || title.startsWith("|") || title.startsWith(">") || title.startsWith("%") || title.startsWith("@") || title.startsWith("`");
  let cleanName = title.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[<>\/\\|?*\n\r]+/g, "").replace(/\.{2,}/g, ".").trim();
  cleanName = cleanName.replace(/^[^\w\d\s"']+/, "");
  cleanName = cleanName.replace(/\s+/g, " ").trim();
  if (!cleanName || cleanName.length === 0) {
    cleanName = "Untitled";
  }
  if (cleanName.startsWith(".")) {
    cleanName = cleanName.substring(1);
  }
  if (!cleanName || cleanName.length === 0) {
    cleanName = "Untitled";
  }
  const needsQuotes = (
    // YAML reserved words
    /^(true|false|null|yes|no|on|off|\d+|\d*\.\d+)$/i.test(cleanName) || // Contains quotes
    cleanName.includes('"') || // Contains colon (CRITICAL: prevents YAML key-value interpretation)
    cleanName.includes(":") || // Contains square brackets or curly braces (YAML flow collections)
    cleanName.includes("[") || cleanName.includes("]") || cleanName.includes("{") || cleanName.includes("}") || // Started with YAML special characters (before sanitization)
    startsWithYamlSpecial || // Contains newlines or tabs (safety check)
    cleanName.includes("\n") || cleanName.includes("\r") || cleanName.includes("	")
  );
  if (needsQuotes) {
    return `'${cleanName.replace(/'/g, "''")}'`;
  }
  return cleanName;
}
function isValidMessage(message) {
  return message && typeof message === "object" && message.content && typeof message.content === "object" && Array.isArray(message.content.parts) && message.content.parts.length > 0 && message.content.parts.some(
    (part) => {
      if (typeof part === "string" && part.trim() !== "") {
        return true;
      }
      if (typeof part === "object" && part !== null) {
        if (part.content_type === "audio_transcription" && part.text && part.text.trim() !== "") {
          return true;
        }
        if (part.content_type === "text" && part.text && part.text.trim() !== "") {
          return true;
        }
        if (part.content_type === "multimodal_text" && part.text && part.text.trim() !== "") {
          return true;
        }
      }
      return false;
    }
  );
}
function isCustomError(error) {
  return error && typeof error.message === "string";
}
async function ensureFolderExists(folderPath, vault) {
  const folders = folderPath.split("/").filter((p) => p.length);
  let currentPath = "";
  for (const folder of folders) {
    currentPath += folder + "/";
    const currentFolder = vault.getAbstractFileByPath(currentPath);
    if (!currentFolder) {
      try {
        await vault.createFolder(currentPath);
      } catch (error) {
        if (error.message !== "Folder already exists.") {
          logger2.error(
            `Failed to create folder: ${currentPath}`,
            error.message
          );
          return {
            success: false,
            error: `Failed to create folder: ${currentPath}. Reason: ${error.message}`
          };
        }
      }
    }
  }
  return { success: true };
}
async function checkConversationLink(conversationId, provider = "chatgpt") {
  let url;
  switch (provider) {
    case "chatgpt":
      url = PROVIDER_URLS.CHATGPT.CHAT(conversationId);
      break;
    case "claude":
      url = PROVIDER_URLS.CLAUDE.CHAT(conversationId);
      break;
    default:
      logger2.error(`Unknown provider for link checking: ${provider}`);
      return false;
  }
  try {
    const response = await (0, import_obsidian5.requestUrl)({
      url,
      method: "HEAD"
    });
    return response.status >= 200 && response.status < 300;
  } catch (error) {
    logger2.error(`Error fetching ${url}:`, error);
    return false;
  }
}
function isNexusRelated(file, app) {
  var _a;
  const frontmatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
  return (frontmatter == null ? void 0 : frontmatter.nexus) === "nexus-ai-chat-importer";
}
async function moveAndMergeFolders(oldFolder, newPath, vault, onProgress) {
  let moved = 0;
  let skipped = 0;
  let errors = 0;
  const errorDetails = [];
  const foldersToDelete = [];
  let totalFiles = 0;
  let processedFiles = 0;
  function countFiles(folder) {
    let count = 0;
    for (const child of folder.children) {
      if (child instanceof import_obsidian4.TFolder) {
        count += countFiles(child);
      } else {
        count++;
      }
    }
    return count;
  }
  __name(countFiles, "countFiles");
  totalFiles = countFiles(oldFolder);
  async function moveRecursive(sourceFolder, destPath) {
    var _a;
    try {
      await vault.createFolder(destPath);
    } catch (error) {
      if (!((_a = error.message) == null ? void 0 : _a.includes("Folder already exists"))) {
        throw error;
      }
    }
    foldersToDelete.push(sourceFolder);
    for (const child of [...sourceFolder.children]) {
      const childNewPath = `${destPath}/${child.name}`;
      if (child instanceof import_obsidian4.TFolder) {
        await moveRecursive(child, childNewPath);
      } else {
        try {
          const exists = await vault.adapter.exists(childNewPath);
          if (exists) {
            skipped++;
            processedFiles++;
            if (onProgress) {
              onProgress(processedFiles, totalFiles);
            }
            continue;
          }
          await vault.rename(child, childNewPath);
          moved++;
          processedFiles++;
          if (onProgress) {
            onProgress(processedFiles, totalFiles);
          }
        } catch (error) {
          const errorMsg = `Failed to move ${child.path}: ${error.message || String(error)}`;
          logger2.error(`[moveAndMergeFolders] ${errorMsg}`);
          errorDetails.push(errorMsg);
          errors++;
          processedFiles++;
          if (onProgress) {
            onProgress(processedFiles, totalFiles);
          }
        }
      }
    }
  }
  __name(moveRecursive, "moveRecursive");
  try {
    await moveRecursive(oldFolder, newPath);
    for (const folder of foldersToDelete.reverse()) {
      try {
        const exists = await vault.adapter.exists(folder.path);
        if (!exists) {
          continue;
        }
        const folderContents = await vault.adapter.list(folder.path);
        const visibleFiles = folderContents.files.filter((f) => {
          const fileName = f.split("/").pop() || "";
          return !fileName.startsWith(".");
        });
        const isEmpty = visibleFiles.length === 0 && folderContents.folders.length === 0;
        if (isEmpty) {
          await vault.adapter.rmdir(folder.path, true);
        } else {
          logger2.warn(`[moveAndMergeFolders] \u26A0\uFE0F Folder not empty, skipping deletion: ${folder.path} (${visibleFiles.length} files, ${folderContents.folders.length} folders)`);
        }
      } catch (error) {
        const errorMsg = error.message || String(error);
        if (!errorMsg.includes("does not exist") && !errorMsg.includes("ENOENT")) {
          logger2.warn(`[moveAndMergeFolders] \u274C Could not delete folder ${folder.path}: ${errorMsg}`);
        }
      }
    }
    let currentFolder = oldFolder.parent;
    while (currentFolder && currentFolder.path !== "/") {
      try {
        const exists = await vault.adapter.exists(currentFolder.path);
        if (!exists) {
          break;
        }
        const folderContents = await vault.adapter.list(currentFolder.path);
        const visibleFiles = folderContents.files.filter((f) => {
          const fileName = f.split("/").pop() || "";
          return !fileName.startsWith(".");
        });
        const isEmpty = visibleFiles.length === 0 && folderContents.folders.length === 0;
        if (isEmpty) {
          await vault.adapter.rmdir(currentFolder.path, true);
          currentFolder = currentFolder.parent;
        } else {
          break;
        }
      } catch (error) {
        break;
      }
    }
    return {
      success: errors === 0,
      moved,
      skipped,
      errors,
      errorDetails: errorDetails.length > 0 ? errorDetails : void 0
    };
  } catch (error) {
    logger2.error(`Failed to merge folders:`, error);
    return {
      success: false,
      moved,
      skipped,
      errors: errors + 1,
      errorDetails: [`Critical error: ${error.message || String(error)}`]
    };
  }
}
var import_obsidian4, import_obsidian5, moment, logger2;
var init_utils = __esm({
  "src/utils.ts"() {
    "use strict";
    import_obsidian4 = require("obsidian");
    init_logger();
    import_obsidian5 = require("obsidian");
    init_constants();
    moment = window.moment;
    logger2 = new Logger();
    __name(truncateToMinute, "truncateToMinute");
    __name(compareTimestampsIgnoringSeconds, "compareTimestampsIgnoringSeconds");
    __name(formatMessageTimestamp, "formatMessageTimestamp");
    __name(formatTimestamp, "formatTimestamp");
    __name(generateYearMonthFolder, "generateYearMonthFolder");
    __name(formatTitle, "formatTitle");
    __name(generateFileName, "generateFileName");
    __name(addPrefix, "addPrefix");
    __name(createDatePrefix, "createDatePrefix");
    __name(generateUniqueFileName, "generateUniqueFileName");
    __name(doesFilePathExist, "doesFilePathExist");
    __name(getFileHash, "getFileHash");
    __name(generateConversationFileName, "generateConversationFileName");
    __name(generateSafeAlias, "generateSafeAlias");
    __name(isValidMessage, "isValidMessage");
    __name(isCustomError, "isCustomError");
    __name(ensureFolderExists, "ensureFolderExists");
    __name(checkConversationLink, "checkConversationLink");
    __name(isNexusRelated, "isNexusRelated");
    __name(moveAndMergeFolders, "moveAndMergeFolders");
  }
});

// src/services/link-update-service.ts
var link_update_service_exports = {};
__export(link_update_service_exports, {
  LinkUpdateService: () => LinkUpdateService
});
var LinkUpdateService;
var init_link_update_service = __esm({
  "src/services/link-update-service.ts"() {
    "use strict";
    LinkUpdateService = class {
      constructor(plugin) {
        this.plugin = plugin;
      }
      /**
       * Update attachment links when attachment folder path changes
       */
      async updateAttachmentLinks(oldAttachmentPath, newAttachmentPath, progressCallback) {
        const stats = {
          conversationsScanned: 0,
          reportsScanned: 0,
          attachmentLinksUpdated: 0,
          conversationLinksUpdated: 0,
          filesModified: 0,
          errors: 0
        };
        try {
          const conversationFiles = await this.getConversationFiles();
          stats.conversationsScanned = conversationFiles.length;
          progressCallback == null ? void 0 : progressCallback({
            phase: "scanning",
            current: 0,
            total: conversationFiles.length,
            detail: `Found ${conversationFiles.length} conversations to scan`
          });
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            progressCallback == null ? void 0 : progressCallback({
              phase: "updating-attachments",
              current: i,
              total: conversationFiles.length,
              detail: `Updating attachment links: ${i}/${conversationFiles.length} files processed`
            });
            for (const file of batch) {
              try {
                const result = await this.updateAttachmentLinksInFile(file, oldAttachmentPath, newAttachmentPath);
                stats.attachmentLinksUpdated += result.linksUpdated;
                if (result.fileModified) {
                  stats.filesModified++;
                }
              } catch (error) {
                stats.errors++;
                this.plugin.logger.error(`Error updating attachment links in ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          progressCallback == null ? void 0 : progressCallback({
            phase: "complete",
            current: conversationFiles.length,
            total: conversationFiles.length,
            detail: `Updated ${stats.attachmentLinksUpdated} attachment links in ${stats.filesModified} files`
          });
          return stats;
        } catch (error) {
          this.plugin.logger.error("Error updating attachment links:", error);
          progressCallback == null ? void 0 : progressCallback({
            phase: "error",
            current: 0,
            total: 0,
            detail: `Error: ${error instanceof Error ? error.message : String(error)}`
          });
          throw error;
        }
      }
      /**
       * Update conversation links when conversation folder path changes
       */
      async updateConversationLinks(oldConversationPath, newConversationPath, progressCallback) {
        const stats = {
          conversationsScanned: 0,
          reportsScanned: 0,
          attachmentLinksUpdated: 0,
          conversationLinksUpdated: 0,
          filesModified: 0,
          errors: 0
        };
        try {
          const reportFiles = await this.getReportFiles();
          const artifactFiles = await this.getClaudeArtifactFiles();
          const totalFiles = reportFiles.length + artifactFiles.length;
          stats.reportsScanned = reportFiles.length;
          progressCallback == null ? void 0 : progressCallback({
            phase: "scanning",
            current: 0,
            total: totalFiles,
            detail: `Found ${reportFiles.length} reports and ${artifactFiles.length} artifacts to scan`
          });
          const batchSize = 5;
          let processedCount = 0;
          for (let i = 0; i < reportFiles.length; i += batchSize) {
            const batch = reportFiles.slice(i, i + batchSize);
            progressCallback == null ? void 0 : progressCallback({
              phase: "updating-conversations",
              current: processedCount,
              total: totalFiles,
              detail: `Updating conversation links in reports: ${i}/${reportFiles.length} processed`
            });
            for (const file of batch) {
              try {
                const result = await this.updateConversationLinksInFile(file, oldConversationPath, newConversationPath);
                stats.conversationLinksUpdated += result.linksUpdated;
                if (result.fileModified) {
                  stats.filesModified++;
                }
              } catch (error) {
                stats.errors++;
                this.plugin.logger.error(`Error updating conversation links in ${file.path}:`, error);
              }
            }
            processedCount += batch.length;
            if (i + batchSize < reportFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          for (let i = 0; i < artifactFiles.length; i += batchSize) {
            const batch = artifactFiles.slice(i, i + batchSize);
            progressCallback == null ? void 0 : progressCallback({
              phase: "updating-artifacts",
              current: processedCount,
              total: totalFiles,
              detail: `Updating conversation links in artifacts: ${i}/${artifactFiles.length} processed`
            });
            for (const file of batch) {
              try {
                const result = await this.updateConversationLinkInArtifactFrontmatter(file, oldConversationPath, newConversationPath);
                if (result.linksUpdated > 0) {
                  stats.conversationLinksUpdated += result.linksUpdated;
                }
                if (result.fileModified) {
                  stats.filesModified++;
                }
              } catch (error) {
                stats.errors++;
                this.plugin.logger.error(`Error updating conversation link in artifact ${file.path}:`, error);
              }
            }
            processedCount += batch.length;
            if (i + batchSize < artifactFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          progressCallback == null ? void 0 : progressCallback({
            phase: "complete",
            current: totalFiles,
            total: totalFiles,
            detail: `Updated ${stats.conversationLinksUpdated} conversation links in ${stats.filesModified} files`
          });
          return stats;
        } catch (error) {
          this.plugin.logger.error("Error updating conversation links:", error);
          progressCallback == null ? void 0 : progressCallback({
            phase: "error",
            current: 0,
            total: 0,
            detail: `Error: ${error instanceof Error ? error.message : String(error)}`
          });
          throw error;
        }
      }
      /**
       * Update attachment links for multiple old→new path mappings in a single pass.
       * Reads each conversation file only ONCE and applies all replacements together.
       * Used as a fallback when Obsidian's "Automatically update internal links" is disabled.
       */
      async updateAttachmentLinksBatch(pathMappings, progressCallback, pluginVersion) {
        const stats = {
          conversationsScanned: 0,
          reportsScanned: 0,
          attachmentLinksUpdated: 0,
          conversationLinksUpdated: 0,
          filesModified: 0,
          errors: 0
        };
        if (pathMappings.length === 0) {
          return stats;
        }
        try {
          const conversationFiles = await this.getConversationFiles();
          stats.conversationsScanned = conversationFiles.length;
          progressCallback == null ? void 0 : progressCallback({
            phase: "scanning",
            current: 0,
            total: conversationFiles.length,
            detail: `Checking links: ${pathMappings.length} path(s) across ${conversationFiles.length} file(s)`
          });
          const mappingPatterns = pathMappings.map(({ oldPath, newPath }) => {
            const normalizedOld = oldPath.replace(/\/+$/, "");
            const normalizedNew = newPath.replace(/\/+$/, "");
            const escaped = this.escapeRegExp(normalizedOld);
            return {
              patterns: [
                { regex: new RegExp(`(!\\[[^\\]]*\\]\\()${escaped}(/[^)]+\\))`, "g"), replacement: `$1${normalizedNew}$2` },
                { regex: new RegExp(`(\\[[^\\]]*\\]\\()${escaped}(/[^)]+\\))`, "g"), replacement: `$1${normalizedNew}$2` },
                { regex: new RegExp(`(!\\[\\[)${escaped}(/[^\\]]+\\]\\])`, "g"), replacement: `$1${normalizedNew}$2` },
                { regex: new RegExp(`(\\[\\[)${escaped}(/[^\\]]+\\]\\])`, "g"), replacement: `$1${normalizedNew}$2` }
              ]
            };
          });
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            if (i % 50 === 0 || i + batchSize >= conversationFiles.length) {
              progressCallback == null ? void 0 : progressCallback({
                phase: "updating-attachments",
                current: i,
                total: conversationFiles.length,
                detail: `Checking links: ${i}/${conversationFiles.length} files`
              });
            }
            for (const file of batch) {
              try {
                const content = await this.plugin.app.vault.read(file);
                let updatedContent = content;
                let fileLinksUpdated = 0;
                for (const mapping of mappingPatterns) {
                  for (const { regex, replacement } of mapping.patterns) {
                    regex.lastIndex = 0;
                    const before = updatedContent;
                    updatedContent = updatedContent.replace(regex, replacement);
                    if (updatedContent !== before) {
                      regex.lastIndex = 0;
                      const matches = before.match(regex);
                      fileLinksUpdated += matches ? matches.length : 1;
                    }
                  }
                }
                stats.attachmentLinksUpdated += fileLinksUpdated;
                if (content !== updatedContent) {
                  if (pluginVersion) {
                    updatedContent = this.updatePluginVersion(updatedContent, pluginVersion);
                  }
                  await this.plugin.app.vault.modify(file, updatedContent);
                  stats.filesModified++;
                }
              } catch (error) {
                stats.errors++;
                this.plugin.logger.error(`Error updating attachment links in ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          progressCallback == null ? void 0 : progressCallback({
            phase: "complete",
            current: conversationFiles.length,
            total: conversationFiles.length,
            detail: `Fixed ${stats.attachmentLinksUpdated} stale link(s) in ${stats.filesModified} file(s)`
          });
          return stats;
        } catch (error) {
          this.plugin.logger.error("Error in batch attachment link update:", error);
          throw error;
        }
      }
      /**
       * Estimate time for link updates based on file count
       */
      async estimateUpdateTime(folderType) {
        let fileCount = 0;
        if (folderType === "attachments") {
          const conversationFiles = await this.getConversationFiles();
          fileCount = conversationFiles.length;
        } else {
          const reportFiles = await this.getReportFiles();
          fileCount = reportFiles.length;
        }
        const estimatedSeconds = Math.max(2, Math.ceil(fileCount * 0.1));
        return { fileCount, estimatedSeconds };
      }
      /**
       * Get all conversation files from the vault
       */
      async getConversationFiles() {
        const conversationFolder = this.plugin.settings.conversationFolder;
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        return allFiles.filter((file) => {
          if (!file.path.startsWith(conversationFolder))
            return false;
          const relativePath = file.path.substring(conversationFolder.length + 1);
          if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
            return false;
          }
          return true;
        });
      }
      /**
       * Get all report files from the vault
       */
      async getReportFiles() {
        const reportFolder = this.plugin.settings.reportFolder;
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        return allFiles.filter((file) => file.path.startsWith(reportFolder));
      }
      /**
       * Get all Claude artifact files from the vault
       */
      async getClaudeArtifactFiles() {
        const attachmentFolder = this.plugin.settings.attachmentFolder;
        const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        return allFiles.filter((file) => file.path.startsWith(claudeArtifactsPath));
      }
      /**
       * Update attachment links in a single file
       */
      async updateAttachmentLinksInFile(file, oldAttachmentPath, newAttachmentPath) {
        const content = await this.plugin.app.vault.read(file);
        let updatedContent = content;
        let linksUpdated = 0;
        const normalizedOldPath = oldAttachmentPath.replace(/\/+$/, "");
        const normalizedNewPath = newAttachmentPath.replace(/\/+$/, "");
        const escapedOldPath = this.escapeRegExp(normalizedOldPath);
        const imagePattern = new RegExp(`(!\\[[^\\]]*\\]\\()${escapedOldPath}(/[^)]+\\))`, "g");
        updatedContent = updatedContent.replace(imagePattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${suffix}`;
        });
        const linkPattern = new RegExp(`(\\[[^\\]]*\\]\\()${escapedOldPath}(/[^)]+\\))`, "g");
        updatedContent = updatedContent.replace(linkPattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${suffix}`;
        });
        const obsidianImagePattern = new RegExp(`(!\\[\\[)${escapedOldPath}(/[^\\]]+\\]\\])`, "g");
        updatedContent = updatedContent.replace(obsidianImagePattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${suffix}`;
        });
        const obsidianLinkPattern = new RegExp(`(\\[\\[)${escapedOldPath}(/[^\\]]+\\]\\])`, "g");
        updatedContent = updatedContent.replace(obsidianLinkPattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${suffix}`;
        });
        const fileModified = content !== updatedContent;
        if (fileModified) {
          await this.plugin.app.vault.modify(file, updatedContent);
        }
        return { linksUpdated, fileModified };
      }
      /**
       * Update conversation links in a single report file
       */
      async updateConversationLinksInFile(file, oldConversationPath, newConversationPath) {
        const content = await this.plugin.app.vault.read(file);
        let updatedContent = content;
        let linksUpdated = 0;
        const normalizedOldPath = oldConversationPath.replace(/\/+$/, "");
        const normalizedNewPath = newConversationPath.replace(/\/+$/, "");
        const escapedOldPath = this.escapeRegExp(normalizedOldPath);
        const linkWithAliasPattern = new RegExp(`(\\[\\[)${escapedOldPath}(/[^|\\]]+)(\\|[^\\]]+\\]\\])`, "g");
        updatedContent = updatedContent.replace(linkWithAliasPattern, (match, prefix, pathSuffix, aliasSuffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${pathSuffix}${aliasSuffix}`;
        });
        const simpleLinkPattern = new RegExp(`(\\[\\[)${escapedOldPath}(/[^\\]]+\\]\\])`, "g");
        updatedContent = updatedContent.replace(simpleLinkPattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${suffix}`;
        });
        const fileModified = content !== updatedContent;
        if (fileModified) {
          await this.plugin.app.vault.modify(file, updatedContent);
        }
        return { linksUpdated, fileModified };
      }
      /**
       * Update conversation links in Claude artifact (both frontmatter and body)
       */
      async updateConversationLinkInArtifactFrontmatter(file, oldConversationPath, newConversationPath) {
        const content = await this.plugin.app.vault.read(file);
        let updatedContent = content;
        let linksUpdated = 0;
        const normalizedOldPath = oldConversationPath.replace(/\/+$/, "");
        const normalizedNewPath = newConversationPath.replace(/\/+$/, "");
        const escapedOldPath = this.escapeRegExp(normalizedOldPath);
        const frontmatterLinkPattern = new RegExp(
          `(conversation_link:\\s*"\\[\\[)${escapedOldPath}(/[^\\]]+)(\\]\\]")`,
          "g"
        );
        updatedContent = updatedContent.replace(frontmatterLinkPattern, (match, prefix, pathSuffix, suffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${pathSuffix}${suffix}`;
        });
        const bodyLinkWithAliasPattern = new RegExp(
          `(\\*\\*Conversation:\\*\\*\\s*\\[\\[)${escapedOldPath}(/[^|\\]]+)(\\|[^\\]]+\\]\\])`,
          "g"
        );
        updatedContent = updatedContent.replace(bodyLinkWithAliasPattern, (match, prefix, pathSuffix, aliasSuffix) => {
          linksUpdated++;
          return `${prefix}${normalizedNewPath}${pathSuffix}${aliasSuffix}`;
        });
        const bodyLinkSimplePattern = new RegExp(
          `(\\*\\*Conversation:\\*\\*\\s*\\[\\[)${escapedOldPath}(/[^\\]]+\\]\\])`,
          "g"
        );
        updatedContent = updatedContent.replace(bodyLinkSimplePattern, (match, prefix, suffix) => {
          linksUpdated++;
          return `${prefix}${newConversationPath}${suffix}`;
        });
        const fileModified = content !== updatedContent;
        if (fileModified) {
          await this.plugin.app.vault.modify(file, updatedContent);
        }
        return { linksUpdated, fileModified };
      }
      /**
       * Update plugin_version in frontmatter
       */
      updatePluginVersion(content, version) {
        if (content.includes("plugin_version:")) {
          return content.replace(
            /^plugin_version: .*$/m,
            `plugin_version: "${version}"`
          );
        }
        return content.replace(
          /\n---\n/,
          `
plugin_version: "${version}"
---
`
        );
      }
      /**
       * Escape special regex characters
       */
      escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    };
    __name(LinkUpdateService, "LinkUpdateService");
  }
});

// src/upgrade/utils/progress-modal.ts
var progress_modal_exports = {};
__export(progress_modal_exports, {
  ProgressModal: () => UpgradeProgressModal,
  UpgradeProgressModal: () => UpgradeProgressModal
});
var import_obsidian6, UpgradeProgressModal;
var init_progress_modal = __esm({
  "src/upgrade/utils/progress-modal.ts"() {
    "use strict";
    import_obsidian6 = require("obsidian");
    init_i18n();
    UpgradeProgressModal = class extends import_obsidian6.Modal {
      constructor(app, title, totalSteps = 100) {
        super(app);
        this.currentStep = 0;
        this.title = title;
        this.totalSteps = totalSteps;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.addClass("nexus-ai-chat-importer-modal");
        this.modalTitleEl = contentEl.createEl("h2", {
          text: this.title,
          cls: "modal-title"
        });
        const contentContainer = contentEl.createDiv({ cls: "modal-content" });
        this.stepEl = contentContainer.createEl("div", { cls: "step-counter" });
        this.stepEl.style.cssText = `
            text-align: center;
            margin: 10px 0;
            font-weight: 500;
            color: var(--text-normal);
        `;
        const progressContainer = contentContainer.createDiv({ cls: "progress-container" });
        progressContainer.style.cssText = `
            background: var(--background-secondary);
            border-radius: 8px;
            padding: 4px;
            margin: 20px 0;
            border: 1px solid var(--background-modifier-border);
        `;
        this.progressBarEl = progressContainer.createDiv({ cls: "progress-bar" });
        this.progressBarEl.style.cssText = `
            background: var(--interactive-accent);
            height: 20px;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        `;
        this.statusEl = contentContainer.createEl("div", { cls: "status-text" });
        this.statusEl.style.cssText = `
            text-align: center;
            margin: 15px 0;
            font-weight: 500;
            color: var(--text-normal);
        `;
        this.detailEl = contentContainer.createEl("div", { cls: "detail-text" });
        this.detailEl.style.cssText = `
            text-align: center;
            color: var(--text-muted);
            font-size: 0.9em;
            min-height: 1.2em;
        `;
        this.updateProgress({ title: t("upgrade.progress_modal.starting"), progress: 0 });
      }
      /**
       * Update progress with step information
       */
      updateProgress(step) {
        if (step.progress !== void 0) {
          const percentage = Math.min(100, Math.max(0, step.progress));
          this.progressBarEl.style.width = `${percentage}%`;
          this.stepEl.textContent = t("upgrade.progress_modal.progress_label", { percentage: String(Math.round(percentage)) });
        } else {
          this.currentStep++;
          const percentage = Math.round(this.currentStep / this.totalSteps * 100);
          this.progressBarEl.style.width = `${percentage}%`;
          this.stepEl.textContent = t("upgrade.progress_modal.step_label", { current: String(this.currentStep), total: String(this.totalSteps) });
        }
        this.statusEl.textContent = step.title;
        this.detailEl.textContent = step.detail || "";
      }
      /**
       * Update with specific step number
       */
      updateStep(stepNumber, step) {
        this.currentStep = stepNumber;
        const percentage = Math.round(stepNumber / this.totalSteps * 100);
        this.progressBarEl.style.width = `${percentage}%`;
        this.stepEl.textContent = t("upgrade.progress_modal.step_label", { current: String(stepNumber), total: String(this.totalSteps) });
        this.statusEl.textContent = step.title;
        this.detailEl.textContent = step.detail || "";
      }
      /**
       * Show completion state
       */
      showComplete(message = t("upgrade.progress_modal.complete_message")) {
        this.progressBarEl.style.width = "100%";
        this.stepEl.textContent = t("upgrade.progress_modal.complete_label");
        this.statusEl.textContent = message;
        this.detailEl.textContent = "";
        this.progressBarEl.style.background = "var(--text-success)";
      }
      /**
       * Show error state
       */
      showError(message = t("upgrade.progress_modal.error_message")) {
        this.statusEl.textContent = message;
        this.detailEl.textContent = "";
        this.progressBarEl.style.background = "var(--text-error)";
      }
      /**
       * Close after delay
       */
      closeAfterDelay(delay = 2e3) {
        setTimeout(() => this.close(), delay);
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    __name(UpgradeProgressModal, "UpgradeProgressModal");
  }
});

// src/dialogs/enhanced-folder-migration-dialog.ts
var enhanced_folder_migration_dialog_exports = {};
__export(enhanced_folder_migration_dialog_exports, {
  EnhancedFolderMigrationDialog: () => EnhancedFolderMigrationDialog
});
var import_obsidian7, EnhancedFolderMigrationDialog;
var init_enhanced_folder_migration_dialog = __esm({
  "src/dialogs/enhanced-folder-migration-dialog.ts"() {
    "use strict";
    import_obsidian7 = require("obsidian");
    init_i18n();
    EnhancedFolderMigrationDialog = class extends import_obsidian7.Modal {
      constructor(plugin, oldPath, newPath, folderType, onComplete) {
        super(plugin.app);
        this.estimatedTime = 0;
        this.plugin = plugin;
        this.oldPath = oldPath;
        this.newPath = newPath;
        this.folderType = folderType;
        this.onComplete = onComplete;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        await this.loadEstimates();
        contentEl.createEl("h2", {
          text: t("folder_migration.title"),
          cls: "nexus-migration-title"
        });
        const messageContainer = contentEl.createDiv({ cls: "nexus-migration-message" });
        messageContainer.createEl("p", {
          text: t("folder_migration.message_intro", { folder_type: this.folderType })
        });
        const pathContainer = messageContainer.createDiv({ cls: "nexus-migration-paths" });
        pathContainer.createEl("div", {
          text: t("folder_migration.path_from", { path: this.oldPath }),
          cls: "nexus-migration-path-old"
        });
        pathContainer.createEl("div", {
          text: t("folder_migration.path_to", { path: this.newPath }),
          cls: "nexus-migration-path-new"
        });
        messageContainer.createEl("p", {
          text: t("folder_migration.question")
        });
        if (this.shouldShowLinkUpdateInfo()) {
          this.createLinkUpdateInfo(contentEl);
        }
        const warningBox = contentEl.createDiv({ cls: "nexus-migration-warning" });
        warningBox.createEl("strong", { text: t("folder_migration.warning.title") });
        warningBox.createEl("p", {
          text: t("folder_migration.warning.text")
        });
        this.createButtons(contentEl);
        this.addStyles();
      }
      async loadEstimates() {
        try {
          const { LinkUpdateService: LinkUpdateService2 } = await Promise.resolve().then(() => (init_link_update_service(), link_update_service_exports));
          const linkUpdateService = new LinkUpdateService2(this.plugin);
          if (this.folderType === "attachments") {
            const estimate = await linkUpdateService.estimateUpdateTime("attachments");
            this.estimatedTime = estimate.estimatedSeconds;
          } else if (this.folderType === "conversations") {
            const estimate = await linkUpdateService.estimateUpdateTime("conversations");
            this.estimatedTime = estimate.estimatedSeconds;
          }
        } catch (error) {
          this.plugin.logger.warn("Failed to load link update estimates:", error);
        }
      }
      shouldShowLinkUpdateInfo() {
        return this.folderType === "attachments" || this.folderType === "conversations";
      }
      createLinkUpdateInfo(contentEl) {
        const linkUpdateBox = contentEl.createDiv({ cls: "nexus-link-update-info" });
        linkUpdateBox.createEl("strong", { text: t("folder_migration.link_updates.title") });
        const infoText = linkUpdateBox.createDiv();
        if (this.folderType === "attachments") {
          infoText.createEl("p", {
            text: t("folder_migration.link_updates.attachments_text")
          });
        } else if (this.folderType === "conversations") {
          infoText.createEl("p", {
            text: t("folder_migration.link_updates.conversations_text")
          });
        }
        if (this.estimatedTime > 0) {
          const timeText = this.estimatedTime < 60 ? t("folder_migration.link_updates.estimated_time_seconds", { seconds: String(this.estimatedTime) }) : t("folder_migration.link_updates.estimated_time_minutes", { minutes: String(Math.ceil(this.estimatedTime / 60)) });
          infoText.createEl("p", {
            text: timeText,
            cls: "nexus-time-estimate"
          });
        }
      }
      createButtons(contentEl) {
        const buttonContainer = contentEl.createDiv({ cls: "nexus-migration-buttons" });
        const cancelButton = buttonContainer.createEl("button", {
          text: t("folder_migration.buttons.cancel"),
          cls: "nexus-migration-button-cancel"
        });
        cancelButton.addEventListener("click", async () => {
          this.close();
          try {
            await this.onComplete("cancel");
            new import_obsidian7.Notice(`Change cancelled. Folder setting reverted.`);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            new import_obsidian7.Notice(`Failed to revert setting: ${errorMessage}`);
          }
        });
        const keepButton = buttonContainer.createEl("button", {
          text: t("folder_migration.buttons.keep"),
          cls: "nexus-migration-button-keep"
        });
        keepButton.addEventListener("click", async () => {
          this.close();
          try {
            await this.onComplete("keep");
            new import_obsidian7.Notice(`Folder setting updated. Files remain in ${this.oldPath}`);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            new import_obsidian7.Notice(`Failed to update setting: ${errorMessage}`);
          }
        });
        const moveButton = buttonContainer.createEl("button", {
          text: this.shouldShowLinkUpdateInfo() ? t("folder_migration.buttons.move_with_links") : t("folder_migration.buttons.move"),
          cls: "mod-cta nexus-migration-button-move"
        });
        moveButton.addEventListener("click", async () => {
          this.close();
          if (this.shouldShowLinkUpdateInfo()) {
            await this.handleMoveWithLinkUpdates();
          } else {
            try {
              await this.onComplete("move");
              new import_obsidian7.Notice(`Files moved to ${this.newPath}`);
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : String(error);
              new import_obsidian7.Notice(`Failed to move files: ${errorMessage}`);
            }
          }
        });
      }
      async handleMoveWithLinkUpdates() {
        let progressModal = null;
        try {
          const [{ UpgradeProgressModal: UpgradeProgressModal2 }, { LinkUpdateService: LinkUpdateService2 }, { moveAndMergeFolders: moveAndMergeFolders2 }] = await Promise.all([
            Promise.resolve().then(() => (init_progress_modal(), progress_modal_exports)),
            Promise.resolve().then(() => (init_link_update_service(), link_update_service_exports)),
            Promise.resolve().then(() => (init_utils(), utils_exports))
          ]);
          progressModal = new UpgradeProgressModal2(
            this.app,
            t("folder_migration.progress.title_moving", { folder_type: this.folderType }),
            100
          );
          progressModal.open();
          progressModal.updateProgress({
            title: t("folder_migration.progress.step_moving_title"),
            detail: t("folder_migration.progress.step_moving_detail", { old_path: this.oldPath, new_path: this.newPath }),
            progress: 5
          });
          const oldFolder = this.app.vault.getAbstractFileByPath(this.oldPath);
          if (!oldFolder || !(oldFolder instanceof import_obsidian7.TFolder)) {
            throw new Error(`Source folder not found: ${this.oldPath}`);
          }
          const moveResult = await moveAndMergeFolders2(
            oldFolder,
            this.newPath,
            this.app.vault,
            (current, total) => {
              const percentage = 5 + Math.round(current / total * 25);
              progressModal.updateProgress({
                title: t("folder_migration.progress.step_moving_title"),
                detail: t("folder_migration.progress.step_moving_count", { current: String(current), total: String(total) }),
                progress: percentage
              });
            }
          );
          progressModal.updateProgress({
            title: t("folder_migration.progress.step_moved_title"),
            detail: t("folder_migration.progress.step_moved_detail", { moved: String(moveResult.moved), skipped: String(moveResult.skipped) }),
            progress: 30
          });
          const linkUpdateService = new LinkUpdateService2(this.plugin);
          let stats;
          if (this.folderType === "attachments") {
            stats = await linkUpdateService.updateAttachmentLinks(
              this.oldPath,
              this.newPath,
              (progress) => {
                const percentage = 30 + Math.round(progress.current / progress.total * 70);
                progressModal.updateProgress({
                  title: t("folder_migration.progress.step_updating_attachment_links"),
                  detail: progress.detail,
                  progress: percentage
                });
              }
            );
          } else if (this.folderType === "conversations") {
            stats = await linkUpdateService.updateConversationLinks(
              this.oldPath,
              this.newPath,
              (progress) => {
                const percentage = 30 + Math.round(progress.current / progress.total * 70);
                let title = t("folder_migration.progress.step_updating_conversation_links");
                if (progress.phase === "updating-conversations") {
                  title = t("folder_migration.progress.step_updating_report_links");
                } else if (progress.phase === "updating-artifacts") {
                  title = t("folder_migration.progress.step_updating_artifact_links");
                }
                progressModal.updateProgress({
                  title,
                  detail: progress.detail,
                  progress: percentage
                });
              }
            );
          }
          const linksUpdated = this.folderType === "attachments" ? (stats == null ? void 0 : stats.attachmentLinksUpdated) || 0 : (stats == null ? void 0 : stats.conversationLinksUpdated) || 0;
          progressModal.showComplete(
            t("folder_migration.progress.complete_message", { moved: String(moveResult.moved), links: String(linksUpdated) })
          );
          progressModal.closeAfterDelay(3e3);
          new import_obsidian7.Notice(`\u2705 ${moveResult.moved} files moved to ${this.newPath}. ${linksUpdated} links updated`);
          await this.onComplete("move");
        } catch (error) {
          if (progressModal) {
            progressModal.close();
          }
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.showErrorDialog(t("folder_migration.error_migration_failed.title"), t("folder_migration.error_migration_failed.message_links", { error: errorMessage }));
        }
      }
      addStyles() {
        const styleEl = document.createElement("style");
        styleEl.textContent = `
            .nexus-migration-title {
                margin-bottom: 1em;
                color: var(--text-normal);
            }

            .nexus-migration-message {
                margin-bottom: 1.5em;
                line-height: 1.6;
            }

            .nexus-migration-paths {
                background-color: var(--background-secondary);
                padding: 1em;
                margin: 1em 0;
                border-radius: 4px;
                font-family: var(--font-monospace);
                font-size: 0.9em;
            }

            .nexus-migration-path-old {
                color: var(--text-muted);
                margin-bottom: 0.5em;
            }

            .nexus-migration-path-new {
                color: var(--interactive-accent);
                font-weight: 500;
            }

            .nexus-link-update-info {
                background-color: var(--background-modifier-success-hover);
                border-left: 4px solid var(--text-success);
                padding: 1em;
                margin-bottom: 1em;
                border-radius: 4px;
            }

            .nexus-link-update-info strong {
                display: block;
                margin-bottom: 0.5em;
                color: var(--text-success);
            }

            .nexus-link-update-info p {
                margin: 0.3em 0;
                color: var(--text-normal);
            }

            .nexus-time-estimate {
                font-style: italic;
                color: var(--text-muted) !important;
                font-size: 0.9em;
            }

            .nexus-migration-warning {
                background-color: var(--background-modifier-error-hover);
                border-left: 4px solid var(--text-error);
                padding: 1em;
                margin-bottom: 1.5em;
                border-radius: 4px;
            }

            .nexus-migration-warning strong {
                display: block;
                margin-bottom: 0.5em;
                color: var(--text-error);
            }

            .nexus-migration-warning p {
                margin: 0;
                color: var(--text-normal);
            }

            .nexus-migration-buttons {
                display: flex;
                justify-content: space-between;
                gap: 10px;
            }

            .nexus-migration-buttons button {
                padding: 8px 16px;
                flex: 1;
            }

            .nexus-migration-button-cancel {
                background-color: var(--background-modifier-border);
                color: var(--text-muted);
            }

            .nexus-migration-button-keep {
                background-color: var(--background-modifier-border);
            }

            .nexus-migration-button-move {
                /* Uses mod-cta class for primary styling */
            }
        `;
        document.head.appendChild(styleEl);
      }
      showErrorDialog(title, message) {
        const modal = new import_obsidian7.Modal(this.app);
        modal.titleEl.setText(title);
        modal.contentEl.createEl("p", {
          text: message,
          cls: "nexus-error-message"
        });
        const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.marginTop = "1em";
        const okButton = buttonContainer.createEl("button", {
          text: t("common.buttons.ok"),
          cls: "mod-cta"
        });
        okButton.addEventListener("click", () => modal.close());
        modal.open();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    __name(EnhancedFolderMigrationDialog, "EnhancedFolderMigrationDialog");
  }
});

// src/dialogs.ts
function displayModal(app, title, paragraphs, note) {
  const modal = new import_obsidian13.Modal(app);
  modal.contentEl.addClass("nexus-ai-chat-importer-modal");
  const titleEl = modal.contentEl.createEl("h2", {
    text: title,
    cls: "modal-title"
  });
  const contentContainer = modal.contentEl.createDiv({ cls: "modal-content" });
  paragraphs.forEach((paragraph, paragraphIndex) => {
    const paragraphWithSpacing = paragraph + "\n\n";
    const paragraphDiv = contentContainer.createDiv({ cls: "modal-paragraph" });
    const sections = paragraphWithSpacing.split("\n\n").filter((section) => section.trim() !== "");
    sections.forEach((section, sectionIndex) => {
      const sectionDiv = paragraphDiv.createDiv({ cls: "modal-section" });
      const lines = section.split("\n").filter((line) => line.trim() !== "");
      lines.forEach((line) => {
        const lineDiv = sectionDiv.createDiv({ cls: "modal-line" });
        let htmlContent = line.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="external-link" target="_blank">$1</a>').replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>").replace(/\*([^*]+)\*/g, "<em>$1</em>");
        if (line.trim().endsWith(":") && line.trim().length < 30) {
          lineDiv.innerHTML = `<strong class="section-header">${htmlContent}</strong>`;
        } else if (line.trim().startsWith("\u2022") || line.trim().startsWith("-")) {
          lineDiv.innerHTML = htmlContent;
          lineDiv.addClass("modal-list-item");
        } else {
          lineDiv.innerHTML = htmlContent;
        }
      });
      if (sectionIndex < sections.length - 1) {
        paragraphDiv.createDiv({ cls: "modal-section-break" });
      }
    });
  });
  if (note) {
    contentContainer.createDiv({ cls: "modal-major-break" });
    const noteDiv = contentContainer.createDiv({ cls: "modal-note" });
    let noteContent = note.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="external-link" target="_blank">$1</a>').replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>").replace(/\*([^*]+)\*/g, "<em>$1</em>");
    noteDiv.innerHTML = noteContent;
  }
  return modal;
}
function addButtons(modal, type, resolve, customLabels) {
  const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
  if (type === "information") {
    const buttonLabel = (customLabels == null ? void 0 : customLabels.button1) || "Understood";
    const button = buttonContainer.createEl("button", {
      text: buttonLabel,
      cls: "mod-cta"
      // Obsidian's primary button class
    });
    button.addEventListener("click", () => {
      modal.close();
      resolve(true);
    });
  } else {
    const noLabel = (customLabels == null ? void 0 : customLabels.button2) || "No";
    const yesLabel = (customLabels == null ? void 0 : customLabels.button1) || "Yes";
    const noButton = buttonContainer.createEl("button", {
      text: noLabel,
      cls: "mod-muted"
      // Obsidian's secondary button class
    });
    noButton.addEventListener("click", () => {
      modal.close();
      resolve(false);
    });
    const yesButton = buttonContainer.createEl("button", {
      text: yesLabel,
      cls: "mod-cta"
      // Obsidian's primary button class
    });
    yesButton.addEventListener("click", () => {
      modal.close();
      resolve(true);
    });
  }
}
async function showDialog(app, type, title, paragraphs, note, customLabels) {
  return new Promise((resolve) => {
    const modal = displayModal(app, title, paragraphs, note);
    addButtons(modal, type, resolve, customLabels);
    modal.open();
  });
}
var import_obsidian13;
var init_dialogs = __esm({
  "src/dialogs.ts"() {
    "use strict";
    import_obsidian13 = require("obsidian");
    __name(displayModal, "displayModal");
    __name(addButtons, "addButtons");
    __name(showDialog, "showDialog");
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return (/* @__PURE__ */ __name(function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t2 = "function" == typeof require && require;
              if (!e2 && t2)
                return t2(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t3 = a[r][1][e3];
              return u(t3 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        __name(u, "u");
        for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }, "s"))({ 1: [function(e, t2, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t3, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t3 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t3 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t3 >> 2, s = (3 & t3) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t3, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t3 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t3, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t2, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t3, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t3, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        __name(o, "o");
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t3 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t3, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t3.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t2, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t2, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t4, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4[a])];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : function(e3, t4, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t2, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t2, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t2.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t2, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t3) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t3, this.meta = {};
        }
        __name(h, "h");
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e2) {
            t3.push({ data: e2, meta: t3.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t2, r) {
        "use strict";
        function A(e2, t3) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t3; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        __name(A, "A");
        function n(e2, t3, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t3 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t4) {
            var r3 = e3;
            return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        __name(n, "n");
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t3, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        __name(s, "s");
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t3 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t3 = this.streamFiles && !e2.file.dir;
          if (t3) {
            var r2 = n(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e2.file.dir, r2 = n(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t3)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
            this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t4, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t4, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t3 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t3.length; r2++)
            try {
              t3[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++)
            e2[t3].lock();
        }, t2.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t2, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t3) {
          var o = new n(a.streamFiles, t3, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t4) {
              h++;
              var r2 = function(e4, t5) {
                var r3 = e4 || t5, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t4.options.compression, a.compression), n2 = t4.options.compressionOptions || a.compressionOptions || {}, i = t4.dir, s = t4.date;
              t4._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t2, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t3 in this)
              "function" != typeof this[t3] && (e2[t3] = this[t3]);
            return e2;
          };
        }
        __name(n, "n");
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t3) {
          return new n().loadAsync(e2, t3);
        }, n.external = e("./external"), t2.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t2, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t3) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t3(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        __name(f, "f");
        t2.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t3 = new s(o);
            return t3.load(e3), t3;
          }).then(function(e3) {
            var t3 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t3.push(f(r2[n2]));
            return i.Promise.all(t3);
          }).then(function(e3) {
            for (var t3 = e3.shift(), r2 = t3.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t3.zipComment.length && (h.comment = t3.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t2, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t3) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t3);
        }
        __name(s, "s");
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t3 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t3.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t3.isPaused ? this.generatedError = e3 : t3.error(e3);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t2, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t3, r2) {
          i.call(this, t3), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t4) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t4);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        __name(n, "n");
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t2, r) {
        "use strict";
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t3);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t3);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t3 = new Buffer(e2);
          return t3.fill(0), t3;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t2, r) {
        "use strict";
        function s(e2, t3, r2) {
          var n2, i2 = u.getTypeOf(t3), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t3 instanceof c && 0 === t3.uncompressedSize || s2.dir || !t3 || 0 === t3.length) && (s2.base64 = false, s2.binary = true, t3 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t3 instanceof c || t3 instanceof l ? t3 : p.isNode && p.isStream(t3) ? new m(e2, t3) : u.prepareContent(e2, t3, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        __name(s, "s");
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = /* @__PURE__ */ __name(function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t3 = e2.lastIndexOf("/");
          return 0 < t3 ? e2.substring(0, t3) : "";
        }, "_"), g = /* @__PURE__ */ __name(function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, "g"), b = /* @__PURE__ */ __name(function(e2, t3) {
          return t3 = void 0 !== t3 ? t3 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t3 }), this.files[e2];
        }, "b");
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        __name(h, "h");
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t3, r2, n2;
          for (t3 in this.files)
            n2 = this.files[t3], (r2 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t3) {
            r2(e2, t3) && n2.push(t3);
          }), n2;
        }, file: function(e2, t3, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t3, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t4) {
              return !t4.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t4) {
              return t4.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t3 = b.call(this, e2), n2 = this.clone();
          return n2.root = t3.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t3 = this.filter(function(e3, t4) {
              return t4.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t3.length; n2++)
              delete this.files[t3[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t3, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t3 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t3 = new l("error")).error(e3);
          }
          return new a(t3, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t3) {
          return this.generateInternalStream(e2).accumulate(t3);
        }, generateNodeStream: function(e2, t3) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t3);
        } };
        t2.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t2, r) {
        "use strict";
        t2.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t2, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t3 = 0; t3 < this.data.length; t3++)
            e2[t3] = 255 & e2[t3];
        }
        __name(i, "i");
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t3 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t3 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t2, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        __name(i, "i");
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t3, r2 = 0;
          for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--)
            r2 = (r2 << 8) + this.byteAt(t3);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t2.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t2, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        __name(i, "i");
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t2, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        __name(i, "i");
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t2, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        __name(i, "i");
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t2, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t2.exports = function(e2) {
          var t3 = n.getTypeOf(e2);
          return n.checkSupport(t3), "string" !== t3 || i.uint8array ? "nodebuffer" === t3 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t2, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t2, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        __name(s, "s");
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t2, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        __name(s, "s");
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t2.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t2, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        __name(s, "s");
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t2, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t3.dataIsReady = true, t3.data = e3, t3.max = e3 && e3.length || 0, t3.type = n.getTypeOf(e3), t3.isPaused || t3._tickAndRepeat();
          }, function(e3) {
            t3.error(e3);
          });
        }
        __name(s, "s");
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t2, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        __name(n, "n");
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t3) {
          return this._listeners[e2].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t3) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t3);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t3) {
          return this.extraStreamInfo[e2] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t2.exports = n;
      }, {}], 29: [function(e, t2, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t3, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t4) {
              n2.push(e3), o2 && o2(t4);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t4, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t4), r3);
                    case "base64":
                      return u.encode(t4);
                    default:
                      return h.transformTo(e4, t4);
                  }
                }(s2, function(e4, t4) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t4.length; r3++)
                    s3 += t4[r3].length;
                  switch (e4) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t4.length; r3++)
                        i3.set(t4[r3], n3), n3 += t4[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t3(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        __name(l, "l");
        function f(e2, t3, r2) {
          var n2 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t3, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        __name(f, "f");
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t3) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t3.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t3, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t2.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t2, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t2, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        __name(a, "a");
        function l() {
          n.call(this, "utf-8 encode");
        }
        __name(l, "l");
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t3, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t3 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
            return t3;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t3, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t3 = r2 = 0; t3 < s2; )
              if ((n2 = e3[t3++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t3 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t3 < s2; )
                  n2 = n2 << 6 | 63 & e3[t3++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t3 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t3;
              (t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r2, this.leftOver.length);
            } else
              t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n2 = function(e3, t4) {
            var r3;
            for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t4 : 0 === r3 ? t4 : r3 + u[e3[r3]] > t4 ? r3 : t4;
          }(t3), i2 = t3;
          n2 !== t3.length && (h.uint8array ? (i2 = t3.subarray(0, n2), this.leftOver = t3.subarray(n2, t3.length)) : (i2 = t3.slice(0, n2), this.leftOver = t3.slice(n2, t3.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t2, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        __name(n, "n");
        function l(e2, t3) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t3[r2] = 255 & e2.charCodeAt(r2);
          return t3;
        }
        __name(l, "l");
        e("setimmediate"), a.newBlob = function(t3, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t3], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t3), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t3, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t3 || "nodebuffer" === t3 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t3 = "", r2 = 0; r2 < e2.length; r2++)
            t3 += String.fromCharCode(e2[r2]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t3 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t3; )
              try {
                return i.stringifyByChunk(e2, r2, t3);
              } catch (e3) {
                t3 = Math.floor(t3 / 2);
              }
          return i.stringifyByChar(e2);
        }
        __name(s, "s");
        function f(e2, t3) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t3[r2] = e2[r2];
          return t3;
        }
        __name(f, "f");
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t3) {
          if (t3 = t3 || "", !e2)
            return t3;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t3);
          return c[r2][e2](t3);
        }, a.resolve = function(e2) {
          for (var t3 = e2.split("/"), r2 = [], n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t3.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t3, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t3 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t3, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t3 || []);
          });
        }, a.inherits = function(e2, t3) {
          function r2() {
          }
          __name(r2, "r");
          r2.prototype = t3.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t3, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t3 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t3) && void 0 === r2[t3] && (r2[t3] = arguments[e2][t3]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t3, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t3(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t3 = a.getTypeOf(e3);
            return t3 ? ("arraybuffer" === t3 ? e3 = a.transformTo("uint8array", e3) : "string" === t3 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t2, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        __name(h, "h");
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t3) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t3) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t3 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t3, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t3, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t3 = this.reader.readInt(4), r2 = this.reader.readData(t3), this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t3;
          for (e2 = 0; e2 < this.files.length; e2++)
            t3 = this.files[e2], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t3 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t3 - r2;
          if (0 < n2)
            this.isSignature(t3, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t2, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t3) {
          this.options = e2, this.loadOptions = t3;
        }
        __name(l, "l");
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t3, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e3) {
            for (var t4 in h)
              if (Object.prototype.hasOwnProperty.call(h, t4) && h[t4].magic === e3)
                return h[t4];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t3, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t3 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t3), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t3, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t3 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t3] = { id: t3, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3)
              this.fileNameStr = t3;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t3 = n(e2.value);
            return 1 !== t3.readInt(1) ? null : a(this.fileName) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t3 = n(e2.value);
            return 1 !== t3.readInt(1) ? null : a(this.fileComment) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        } }, t2.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t2, r) {
        "use strict";
        function n(e2, t3, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t3, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        __name(n, "n");
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t3 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t3 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t3 = t3.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t3 = t3.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t3 = new h("error")).error(e3);
          }
          return new s(t3, r2, "");
        }, async: function(e2, t3) {
          return this.internalStream(e2).accumulate(t3);
        }, nodeStream: function(e2, t3) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e2, t3) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t2.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t2) {
        (function(t3) {
          "use strict";
          var r, n, e2 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t3.document.createTextNode("");
            s.observe(a, { characterData: true }), r = /* @__PURE__ */ __name(function() {
              a.data = i = ++i % 2;
            }, "r");
          } else if (t3.setImmediate || void 0 === t3.MessageChannel)
            r = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e3 = t3.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t3.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t3.MessageChannel();
            o.port1.onmessage = u, r = /* @__PURE__ */ __name(function() {
              o.port2.postMessage(0);
            }, "r");
          }
          var h = [];
          function u() {
            var e3, t4;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t4 = h, h = [], e3 = -1; ++e3 < r2; )
                t4[e3]();
              r2 = h.length;
            }
            n = false;
          }
          __name(u, "u");
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t2, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        __name(u, "u");
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        __name(o, "o");
        function h(e2, t3, r2) {
          this.promise = e2, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        __name(h, "h");
        function f(t3, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t3, e3);
            }
            e2 === t3 ? l.reject(t3, new TypeError("Cannot resolve promise with itself")) : l.resolve(t3, e2);
          });
        }
        __name(f, "f");
        function c(e2) {
          var t3 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t3)
            return function() {
              t3.apply(e2, arguments);
            };
        }
        __name(c, "c");
        function d(t3, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t3, e3));
          }
          __name(n2, "n");
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t3, e3));
          }
          __name(i2, "i");
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        __name(d, "d");
        function p(e2, t3) {
          var r2 = {};
          try {
            r2.value = e2(t3), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        __name(p, "p");
        (t2.exports = o).prototype.finally = function(t3) {
          if ("function" != typeof t3)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t3()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t3()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t3) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t3 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t3, this.outcome) : this.queue.push(new h(r2, e2, t3));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t3) {
          var r2 = p(c, t3);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t3;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t3);
          }
          return e2;
        }, l.reject = function(e2, t3) {
          e2.state = s, e2.outcome = t3;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t3);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t3 = new this(u);
          return l.reject(t3, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t3 = -1, o2 = new this(u);
          for (; ++t3 < n2; )
            h2(e2[t3], t3);
          return o2;
          function h2(e3, t4) {
            r2.resolve(e3).then(function(e4) {
              s2[t4] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
          __name(h2, "h");
        }, o.race = function(e2) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t3.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t2, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t2.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t2, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t3.header && a.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n2;
            if (n2 = "string" == typeof t3.dictionary ? h.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        __name(p, "p");
        function n(e2, t3) {
          var r2 = new p(t3);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        __name(n, "n");
        p.prototype.push = function(e2, t3) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, n(e2, t3);
        }, r.gzip = function(e2, t3) {
          return (t3 = t3 || {}).gzip = true, n(e2, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t2, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t3.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        __name(a, "a");
        function o(e2, t3) {
          var r2 = new a(t3);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        __name(o, "o");
        a.prototype.push = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t3 === ~~t3 ? t3 : true === t3 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, o(e2, t3);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t2, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r2 = t3.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t3) {
          return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : (e2.length = t3, e2);
        };
        var i = { arraySet: function(e2, t3, r2, n2, i2) {
          if (t3.subarray && e2.subarray)
            e2.set(t3.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t3[r2 + s2];
        }, flattenChunks: function(e2) {
          var t3, r2, n2, i2, s2, a;
          for (t3 = n2 = 0, r2 = e2.length; t3 < r2; t3++)
            n2 += e2[t3].length;
          for (a = new Uint8Array(n2), t3 = i2 = 0, r2 = e2.length; t3 < r2; t3++)
            s2 = e2[t3], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t3, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t3[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t2, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t3) {
          if (t3 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t3));
          for (var r2 = "", n2 = 0; n2 < t3; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        __name(l, "l");
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t3, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t3 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
          return t3;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t3 = new h.Buf8(e2.length), r2 = 0, n2 = t3.length; r2 < n2; r2++)
            t3[r2] = e2.charCodeAt(r2);
          return t3;
        }, r.buf2string = function(e2, t3) {
          var r2, n2, i2, s2, a = t3 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t3) {
          var r2;
          for ((t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t3 : 0 === r2 ? t3 : r2 + u[e2[r2]] > t3 ? r2 : t3;
        };
      }, { "./common": 41 }], 43: [function(e, t2, r) {
        "use strict";
        t2.exports = function(e2, t3, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t3[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t2, r) {
        "use strict";
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t2, r) {
        "use strict";
        var o = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t3[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t2, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t3) {
          return e2.msg = n[t3], t3;
        }
        __name(R, "R");
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        __name(T, "T");
        function D(e2) {
          for (var t3 = e2.length; 0 <= --t3; )
            e2[t3] = 0;
        }
        __name(D, "D");
        function F(e2) {
          var t3 = e2.state, r2 = t3.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out), e2.next_out += r2, t3.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t3.pending -= r2, 0 === t3.pending && (t3.pending_out = 0));
        }
        __name(F, "F");
        function N(e2, t3) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, F(e2.strm);
        }
        __name(N, "N");
        function U(e2, t3) {
          e2.pending_buf[e2.pending++] = t3;
        }
        __name(U, "U");
        function P(e2, t3) {
          e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
        }
        __name(P, "P");
        function L(e2, t3) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t3) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t3, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t3 = f2[t3 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        __name(L, "L");
        function j(e2) {
          var t3, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t3 = r2 = e2.hash_size; n2 = e2.head[--t3], e2.head[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t3 = r2 = f2; n2 = e2.prev[--t3], e2.prev[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        __name(j, "j");
        function Z(e2, t3) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t3 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        __name(Z, "Z");
        function W(e2, t3) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t3 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        __name(W, "W");
        function M(e2, t3, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t3, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        __name(M, "M");
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        __name(H, "H");
        function G(e2) {
          var t3;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t3 = e2.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C : E, e2.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l, u._tr_init(t3), m) : R(e2, _);
        }
        __name(G, "G");
        function K(e2) {
          var t3 = G(e2);
          return t3 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t3;
        }
        __name(K, "K");
        function Y(e2, t3, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t3 === g && (t3 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t3 < 0 || 9 < t3 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = s2, o2.method = r2, K(e2);
        }
        __name(Y, "Y");
        h = [new M(0, 0, 0, 0, function(e2, t3) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t3 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t3) {
          return Y(e2, t3, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t3) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t3, m) : _;
        }, r.deflate = function(e2, t3) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t3 || t3 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t3 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t3, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t3) <= T(r2) && t3 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t3 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t4) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t4 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t3) : 3 === n2.strategy ? function(e3, t4) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t4 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t3) : h[n2.level].func(n2, t3);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t3 ? u._tr_align(n2) : 5 !== t3 && (u._tr_stored_block(n2, 0, 0, false), 3 === t3 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t3 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state.status) !== C && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E && 666 !== t3 ? R(e2, _) : (e2.state = null, t3 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t3.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t3, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t3, l2 - r2.w_size, r2.w_size, 0), t3 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t3, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t2, r) {
        "use strict";
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t2, r) {
        "use strict";
        t2.exports = function(e2, t3) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t3 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t2, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        __name(L, "L");
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        __name(s, "s");
        function a(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state, e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n), t3.distcode = t3.distdyn = new I.Buf32(i), t3.sane = 1, t3.back = -1, N) : U;
        }
        __name(a, "a");
        function o(e2) {
          var t3;
          return e2 && e2.state ? ((t3 = e2.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a(e2)) : U;
        }
        __name(o, "o");
        function h(e2, t3) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t3 < 0 ? (r2 = 0, t3 = -t3) : (r2 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U : (null !== n2.window && n2.wbits !== t3 && (n2.window = null), n2.wrap = r2, n2.wbits = t3, o(e2))) : U;
        }
        __name(h, "h");
        function u(e2, t3) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t3)) !== N && (e2.state = null), r2) : U;
        }
        __name(u, "u");
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t3;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t3 = 0; t3 < 144; )
              e2.lens[t3++] = 8;
            for (; t3 < 256; )
              e2.lens[t3++] = 9;
            for (; t3 < 280; )
              e2.lens[t3++] = 7;
            for (; t3 < 288; )
              e2.lens[t3++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e2.lens[t3++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        __name(j, "j");
        function Z(e2, t3, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t3, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t3, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t3, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        __name(Z, "Z");
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t3)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t3)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t3)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t3)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t3) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t3 = e2.state;
          return t3.window && (t3.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t3) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t3).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t3) {
          var r2, n2 = t3.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t3, n2, 0) !== r2.check ? -3 : Z(e2, t3, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t2, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e2, t3, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t3[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t3[r2 + v] && (a[B[t3[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t3[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t2, r) {
        "use strict";
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t2, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t3 = e2.length; 0 <= --t3; )
            e2[t3] = 0;
        }
        __name(n, "n");
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t3, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t3, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        __name(D, "D");
        function F(e2, t3) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
        }
        __name(F, "F");
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        __name(N, "N");
        function U(e2, t3) {
          e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
        }
        __name(U, "U");
        function P(e2, t3, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t3 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        __name(P, "P");
        function L(e2, t3, r2) {
          P(e2, r2[2 * t3], r2[2 * t3 + 1]);
        }
        __name(L, "L");
        function j(e2, t3) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t3; )
            ;
          return r2 >>> 1;
        }
        __name(j, "j");
        function Z(e2, t3, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t3; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        __name(Z, "Z");
        function W(e2) {
          var t3;
          for (t3 = 0; t3 < l; t3++)
            e2.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f; t3++)
            e2.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c; t3++)
            e2.bl_tree[2 * t3] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        __name(W, "W");
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        __name(M, "M");
        function H(e2, t3, r2, n2) {
          var i2 = 2 * t3, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t3] <= n2[r2];
        }
        __name(H, "H");
        function G(e2, t3, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t3, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t3, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        __name(G, "G");
        function K(e2, t3, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t3) : (L(e2, (s2 = A[i2]) + u + 1, t3), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t3);
        }
        __name(K, "K");
        function Y(e2, t3) {
          var r2, n2, i2, s2 = t3.dyn_tree, a2 = t3.stat_desc.static_tree, o2 = t3.stat_desc.has_stree, h2 = t3.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t3.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t4) {
            var r3, n3, i3, s3, a3, o3, h3 = t4.dyn_tree, u3 = t4.max_code, l2 = t4.stat_desc.static_tree, f2 = t4.stat_desc.has_stree, c2 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p2 = t4.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t3), Z(s2, u2, e2.bl_count);
        }
        __name(Y, "Y");
        function X(e2, t3, r2) {
          var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t3[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t3[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        __name(X, "X");
        function V(e2, t3, r2) {
          var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t3[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        __name(V, "V");
        n(T);
        var q = false;
        function J(e2, t3, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending), e3.pending += r3;
          }(e2, t3, r2, true);
        }
        __name(J, "J");
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t3, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t3 = 0; t3 <= g; t3++)
              s2[t3] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t3, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t4, r3 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t4])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t4 = 32; t4 < u; t4++)
              if (0 !== e3.dyn_ltree[2 * t4])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t4;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t4 = c - 1; 3 <= t4 && 0 === e3.bl_tree[2 * S[t4] + 1]; t4--)
              ;
            return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t3 ? J(e2, t3, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
            var i3;
            for (P(e3, t4 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t4 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t3, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t3 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t3 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t3)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t2, r) {
        "use strict";
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t2, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t3, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t4 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t4, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t3.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t4 = l.createElement("script");
                t4.onreadystatechange = function() {
                  c(e4), t4.onreadystatechange = null, s.removeChild(t4), t4 = null;
                }, s.appendChild(t4);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++)
                  t4[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t4 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            __name(f, "f");
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t4 = h[e4];
                if (t4) {
                  u = true;
                  try {
                    !function(e5) {
                      var t5 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r3[0]);
                          break;
                        case 2:
                          t5(r3[0], r3[1]);
                          break;
                        case 3:
                          t5(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t5.apply(n, r3);
                      }
                    }(t4);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            __name(c, "c");
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
            __name(d, "d");
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    __name(Pend, "Pend");
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      __name(onCb, "onCb");
      function cbListener(listener) {
        listener(self2.error);
      }
      __name(cbListener, "cbListener");
    }
    __name(pendHold, "pendHold");
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
    __name(pendGo, "pendGo");
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports.createFromBuffer = createFromBuffer;
    exports.createFromFd = createFromFd;
    exports.BufferSlicer = BufferSlicer;
    exports.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    __name(FdSlicer, "FdSlicer");
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
      __name(onCloseDone, "onCloseDone");
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    __name(ReadStream, "ReadStream");
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    __name(WriteStream, "WriteStream");
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    __name(BufferSlicer, "BufferSlicer");
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    __name(createFromBuffer, "createFromBuffer");
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
    __name(createFromFd, "createFromFd");
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    __name(ensureBuffer, "ensureBuffer");
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    __name(bufferizeInt, "bufferizeInt");
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    __name(_crc32, "_crc32");
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    __name(crc32, "crc32");
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports.open = open;
    exports.fromFd = fromFd;
    exports.fromBuffer = fromBuffer;
    exports.fromRandomAccessReader = fromRandomAccessReader;
    exports.dosDateTimeToDate = dosDateTimeToDate;
    exports.validateFileName = validateFileName;
    exports.ZipFile = ZipFile;
    exports.Entry = Entry;
    exports.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    __name(open, "open");
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    __name(fromFd, "fromFd");
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    __name(fromBuffer, "fromBuffer");
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    __name(fromRandomAccessReader, "fromRandomAccessReader");
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    __name(ZipFile, "ZipFile");
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    __name(emitErrorAndAutoClose, "emitErrorAndAutoClose");
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    __name(emitError, "emitError");
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    __name(Entry, "Entry");
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    __name(dosDateTimeToDate, "dosDateTimeToDate");
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    __name(validateFileName, "validateFileName");
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    __name(readAndAssertNoEof, "readAndAssertNoEof");
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    __name(AssertByteCountStream, "AssertByteCountStream");
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    __name(RandomAccessReader, "RandomAccessReader");
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
      __name(onCloseDone, "onCloseDone");
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    __name(RefUnrefFilter, "RefUnrefFilter");
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    __name(decodeBuffer, "decodeBuffer");
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    __name(readUInt64LE, "readUInt64LE");
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = /* @__PURE__ */ __name(function(len) {
        return Buffer.allocUnsafe(len);
      }, "newBuffer");
    } else {
      newBuffer = /* @__PURE__ */ __name(function(len) {
        return new Buffer(len);
      }, "newBuffer");
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
    __name(defaultCallback, "defaultCallback");
  }
});

// src/utils/date-parser.ts
var moment2, DateParser;
var init_date_parser = __esm({
  "src/utils/date-parser.ts"() {
    "use strict";
    init_logger();
    moment2 = window.moment;
    DateParser = class {
      /**
       * Parse a date string with automatic format detection
       * Returns Unix timestamp (seconds) or 0 if parsing fails
       * @param dateStr - Date string to parse
       * @param contextId - Optional context identifier for logging (e.g., "Artifact abc123_v1", "Conversation xyz")
       */
      static parseDate(dateStr, contextId) {
        const ctx = contextId ? `[${contextId}] ` : "";
        if (!dateStr || typeof dateStr !== "string") {
          return 0;
        }
        try {
          const isoDate = moment2(dateStr, moment2.ISO_8601, true);
          if (isoDate.isValid()) {
            return isoDate.unix();
          }
          const format = this.detectFormat(dateStr);
          if (!format) {
            logger.warn(`${ctx}parseDate - FAILED: could not detect format`);
            return 0;
          }
          const parsed = this.parseWithFormat(dateStr, format);
          if (parsed === 0) {
            logger.warn(`${ctx}parseDate - FAILED: parsing returned 0`);
          }
          return parsed;
        } catch (error) {
          logger.warn(`${ctx}parseDate - FAILED: exception:`, error);
          return 0;
        }
      }
      /**
       * Parse a date string with a forced component order (YMD/DMY/MDY)
       * Keeps other parts auto-detected from the string (separator, time format, seconds)
       */
      static parseDateWithOrder(dateStr, order) {
        if (!dateStr || typeof dateStr !== "string")
          return 0;
        const isoDate = moment2(dateStr, moment2.ISO_8601, true);
        if (isoDate.isValid())
          return isoDate.unix();
        const detected = this.detectFormat(dateStr);
        if (!detected)
          return 0;
        const forced = { ...detected, order };
        return this.parseWithFormat(dateStr, forced);
      }
      /**
       * Convert a date string to ISO 8601 with a forced component order
       */
      static convertToISO8601WithOrder(dateStr, order) {
        const unixTime = this.parseDateWithOrder(dateStr, order);
        if (unixTime === 0)
          return null;
        return new Date(unixTime * 1e3).toISOString();
      }
      /**
       * Detect date format from a single date string
       */
      static detectFormat(dateStr) {
        if (dateStr.match(/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}(:\d{2})?(\.\d{3})?Z?$/)) {
          return {
            separator: "-",
            order: "YMD",
            timeFormat: "24h",
            hasSeconds: dateStr.includes(":") && dateStr.split(":").length >= 3
          };
        }
        let separator = "/";
        if (dateStr.includes("-") && !dateStr.match(/^\d{4}-\d{2}-\d{2}/)) {
          separator = "-";
        } else if (dateStr.includes(".")) {
          separator = ".";
        } else if (dateStr.includes("/")) {
          separator = "/";
        } else {
          return null;
        }
        const hasAMPM = /\s(AM|PM)$/i.test(dateStr);
        const timeFormat = hasAMPM ? "12h" : "24h";
        const timeMatch = dateStr.match(/\s(\d{1,2}:\d{2}(?::\d{2})?(?:\s?[AP]M)?)/i);
        const timePart = timeMatch ? timeMatch[1] : "";
        const hasSeconds = timePart.split(":").length >= 3;
        const datePart = dateStr.split(/\s/)[0];
        const parts = datePart.split(separator).map((p) => parseInt(p, 10));
        if (parts.length !== 3 || parts.some(isNaN)) {
          return null;
        }
        const order = this.detectOrder(parts, separator, hasAMPM);
        return {
          separator,
          order,
          timeFormat,
          hasSeconds
        };
      }
      /**
       * Detect date component order (YMD, DMY, MDY)
       * @param parts - Date parts [first, second, third]
       * @param separator - Date separator ('/', '-', '.')
       * @param hasAMPM - Whether the time uses AM/PM format (hint for US format)
       */
      static detectOrder(parts, separator, hasAMPM) {
        const [first, second, third] = parts;
        if (first > 31) {
          return "YMD";
        }
        if (third > 31) {
          if (first > 12) {
            return "DMY";
          }
          if (second > 12) {
            return "MDY";
          }
          if (separator === ".") {
            return "DMY";
          }
          if (hasAMPM) {
            return "MDY";
          }
          return "DMY";
        }
        if (first > 12) {
          return "DMY";
        }
        if (second > 12) {
          return "MDY";
        }
        if (separator === "-") {
          return "YMD";
        } else if (separator === ".") {
          return "DMY";
        } else if (hasAMPM) {
          return "MDY";
        }
        return "DMY";
      }
      /**
       * Parse date string with detected format
       */
      static parseWithFormat(dateStr, format) {
        let datePattern;
        switch (format.order) {
          case "YMD":
            datePattern = format.separator === "-" ? "YYYY-MM-DD" : "YYYY/MM/DD";
            break;
          case "DMY":
            datePattern = format.separator === "." ? "DD.MM.YYYY" : "DD/MM/YYYY";
            break;
          case "MDY":
            datePattern = "MM/DD/YYYY";
            break;
        }
        const timePattern = format.timeFormat === "12h" ? format.hasSeconds ? "h:mm:ss A" : "h:mm A" : format.hasSeconds ? "HH:mm:ss" : "HH:mm";
        const patterns = [
          `${datePattern} ${timePattern}`,
          // Standard space
          `${datePattern}[T]${timePattern}`,
          // ISO 8601 T
          `${datePattern}[ at ]${timePattern}`
          // English "at"
        ];
        for (const pattern of patterns) {
          const date = moment2(dateStr, pattern, true);
          if (date.isValid()) {
            return date.unix();
          }
        }
        if (format.hasSeconds) {
          const timePatternNoSec = format.timeFormat === "12h" ? "h:mm A" : "HH:mm";
          const fallbackPatterns = [
            `${datePattern} ${timePatternNoSec}`,
            `${datePattern}[T]${timePatternNoSec}`,
            `${datePattern}[ at ]${timePatternNoSec}`
          ];
          for (const pattern of fallbackPatterns) {
            const date = moment2(dateStr, pattern, true);
            if (date.isValid()) {
              return date.unix();
            }
          }
        }
        return 0;
      }
      /**
       * Convert any date format to ISO 8601
       * Returns ISO 8601 string or null if parsing fails
       */
      static convertToISO8601(dateStr) {
        const unixTime = this.parseDate(dateStr);
        if (unixTime === 0) {
          logger.warn(`convertToISO8601 - parsing returned 0`);
          return null;
        }
        return new Date(unixTime * 1e3).toISOString();
      }
      /**
       * Detect format from multiple date samples (more reliable)
       * Used for batch processing (e.g., upgrade operations)
       */
      static detectFormatFromSamples(dates) {
        if (!dates || dates.length === 0) {
          return null;
        }
        for (const dateStr of dates.slice(0, 20)) {
          const format = this.detectFormat(dateStr);
          if (format) {
            const datePart = dateStr.split(/\s/)[0];
            const parts = datePart.split(format.separator).map((p) => parseInt(p, 10));
            if (parts.some((p) => p > 12)) {
              return format;
            }
          }
        }
        return this.detectFormat(dates[0]);
      }
    };
    __name(DateParser, "DateParser");
  }
});

// src/services/storage-service.ts
var StorageService;
var init_storage_service = __esm({
  "src/services/storage-service.ts"() {
    "use strict";
    init_date_parser();
    StorageService = class {
      constructor(plugin) {
        this.plugin = plugin;
        this.importedArchives = {};
        this.isDirty = false;
        this.saveTimeout = null;
      }
      async loadData() {
        try {
          const data = await this.plugin.loadData();
          this.importedArchives = (data == null ? void 0 : data.importedArchives) || {};
          this.isDirty = false;
        } catch (error) {
          this.plugin.logger.error("loadData failed:", error);
          throw error;
        }
      }
      async saveData(data) {
        try {
          await this.plugin.saveData(data);
          this.isDirty = false;
        } catch (error) {
          this.plugin.logger.error("saveData failed:", error);
          throw error;
        }
      }
      debouncedSave() {
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
        }
        this.saveTimeout = window.setTimeout(async () => {
          if (this.isDirty) {
            await this.plugin.saveSettings();
          }
        }, 1e3);
      }
      // ========================================
      // ARCHIVE TRACKING - HYBRID DETECTION (1.0.x + 1.1.0)
      // ========================================
      getImportedArchives() {
        return this.importedArchives;
      }
      /**
       * HYBRID detection: Works with both 1.0.x (filename as key) and 1.1.0 (hash as key)
       * FIXED: Handle both old format (string values) and new format (object values)
       */
      isArchiveImported(key) {
        if (this.importedArchives[key]) {
          return true;
        }
        return Object.values(this.importedArchives).some((archive) => {
          if (typeof archive === "object" && archive !== null && archive.fileName) {
            return archive.fileName === key;
          }
          return false;
        });
      }
      addImportedArchive(fileHash, fileName) {
        this.importedArchives[fileHash] = {
          fileName,
          date: new Date().toISOString()
        };
        this.isDirty = true;
        this.debouncedSave();
      }
      // ========================================
      // NEW: VAULT-BASED CONVERSATION DISCOVERY (HYBRID)
      // ========================================
      /**
       * Scan vault for existing Nexus conversations using HYBRID approach:
       * 1. Wait for cache to be clean (fast)
       * 2. Use metadataCache (optimal performance)  
       * 3. Fallback to manual parsing for problematic files
       */
      async scanExistingConversations() {
        await this.waitForCacheClean(1e3);
        const conversations = /* @__PURE__ */ new Map();
        const conversationFolder = this.plugin.settings.conversationFolder || this.plugin.settings.archiveFolder || "Nexus/Conversations";
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        const conversationFiles = allFiles.filter((file) => {
          if (!file.path.startsWith(conversationFolder))
            return false;
          const relativePath = file.path.substring(conversationFolder.length + 1);
          if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
            return false;
          }
          return true;
        });
        let processed = 0;
        let foundViaCache = 0;
        let foundViaManual = 0;
        let errors = 0;
        const batchSize = 100;
        for (let i = 0; i < conversationFiles.length; i += batchSize) {
          const batch = conversationFiles.slice(i, i + batchSize);
          for (const file of batch) {
            processed++;
            try {
              let entry = await this.parseWithCache(file);
              if (entry) {
                conversations.set(entry.conversationId, entry);
                foundViaCache++;
                continue;
              }
              entry = await this.parseConversationFileManually(file);
              if (entry) {
                conversations.set(entry.conversationId, entry);
                foundViaManual++;
              }
            } catch (error) {
              errors++;
              this.plugin.logger.warn(`Error parsing conversation file ${file.path}:`, error);
            }
          }
          if (i + batchSize < conversationFiles.length) {
            await new Promise((resolve) => setTimeout(resolve, 1));
          }
        }
        return conversations;
      }
      /**
       * Wait for metadata cache to be clean with timeout
       */
      async waitForCacheClean(maxWaitMs = 1e3) {
        const startTime = Date.now();
        const metadataCache = this.plugin.app.metadataCache;
        while (!metadataCache.isCacheClean()) {
          if (Date.now() - startTime > maxWaitMs) {
            break;
          }
          await new Promise((resolve) => setTimeout(resolve, 10));
        }
      }
      /**
       * Parse conversation using metadataCache (fast but potentially unreliable)
       */
      async parseWithCache(file) {
        var _a;
        try {
          const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if (!frontmatter) {
            this.plugin.logger.warn(`[parseWithCache] No frontmatter found for ${file.path}`);
            return null;
          }
          if (!frontmatter.nexus || frontmatter.nexus !== this.plugin.manifest.id) {
            this.plugin.logger.warn(`[parseWithCache] Wrong nexus ID for ${file.path}: ${frontmatter.nexus} vs ${this.plugin.manifest.id}`);
            return null;
          }
          if (!frontmatter.conversation_id) {
            this.plugin.logger.warn(`[parseWithCache] No conversation_id for ${file.path}`);
            return null;
          }
          const createTime = this.parseTimeString(frontmatter.create_time);
          const updateTime = this.parseTimeString(frontmatter.update_time);
          if (createTime === 0 || updateTime === 0) {
            this.plugin.logger.warn(`[parseWithCache] Failed to parse timestamps for ${file.path}: create=${frontmatter.create_time} (${createTime}), update=${frontmatter.update_time} (${updateTime})`);
            return null;
          }
          return {
            conversationId: frontmatter.conversation_id,
            provider: frontmatter.provider || "unknown",
            path: file.path,
            updateTime,
            create_time: createTime,
            update_time: updateTime
          };
        } catch (error) {
          this.plugin.logger.warn(`[parseWithCache] Exception parsing ${file.path}:`, error);
          return null;
        }
      }
      /**
       * Parse single conversation file manually (robust fallback)
       */
      async parseConversationFileManually(file) {
        try {
          const content = await this.plugin.app.vault.read(file);
          const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
          if (!frontmatterMatch) {
            return null;
          }
          const frontmatterContent = frontmatterMatch[1];
          const frontmatterData = {};
          const lines = frontmatterContent.split("\n");
          for (const line of lines) {
            const colonIndex = line.indexOf(":");
            if (colonIndex > 0) {
              const key = line.substring(0, colonIndex).trim();
              let value = line.substring(colonIndex + 1).trim();
              if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
                value = value.slice(1, -1);
              }
              frontmatterData[key] = value;
            }
          }
          const nexusId = this.plugin.manifest.id;
          if (frontmatterData.nexus !== nexusId) {
            return null;
          }
          if (!frontmatterData.conversation_id) {
            return null;
          }
          const createTime = this.parseTimeString(frontmatterData.create_time);
          const updateTime = this.parseTimeString(frontmatterData.update_time);
          return {
            conversationId: frontmatterData.conversation_id,
            provider: frontmatterData.provider || "unknown",
            path: file.path,
            updateTime,
            create_time: createTime,
            update_time: updateTime
          };
        } catch (error) {
          this.plugin.logger.error(`Error manually parsing ${file.path}:`, error);
          return null;
        }
      }
      /**
       * Parse time string from frontmatter (handle multiple formats)
       * Supports all formats: ISO 8601, US, EU, DE, JP, and locale-based
       * Uses intelligent format detection from DateParser utility
       */
      parseTimeString(timeStr) {
        const result = DateParser.parseDate(timeStr);
        if (result === 0) {
          this.plugin.logger.warn(`[parseTimeString] Failed to parse: "${timeStr}"`);
        }
        return result;
      }
      /**
       * Fast check if a specific conversation exists
       */
      async conversationExists(conversationId) {
        const conversations = await this.scanExistingConversations();
        return conversations.has(conversationId);
      }
      /**
       * Get conversation entry by ID (single lookup)
       */
      async getConversationById(conversationId) {
        const conversations = await this.scanExistingConversations();
        return conversations.get(conversationId) || null;
      }
      /**
       * Get conversations by provider (for reporting/stats)
       */
      async getConversationsByProvider(provider) {
        const allConversations = await this.scanExistingConversations();
        return Array.from(allConversations.values()).filter((entry) => entry.provider === provider);
      }
      // ========================================
      // LEGACY SUPPORT & CLEANUP
      // ========================================
      async resetCatalogs() {
        try {
          this.importedArchives = {};
          this.isDirty = false;
          if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
            this.saveTimeout = null;
          }
          await this.plugin.saveData({
            settings: this.plugin.settings
            // Note: No conversation catalog to reset - it's now vault-based
          });
        } catch (error) {
          this.plugin.logger.error("resetCatalogs failed:", error);
        }
      }
      // Statistics for debugging
      getStats() {
        return {
          totalArchives: Object.keys(this.importedArchives).length,
          isDirty: this.isDirty,
          hasPendingSave: this.saveTimeout !== null,
          catalogMethod: "vault-based-hybrid",
          trackingMethod: "hybrid-hash-filename"
        };
      }
      async forceSave() {
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
          this.saveTimeout = null;
        }
        if (this.isDirty) {
          await this.plugin.saveSettings();
        }
      }
    };
    __name(StorageService, "StorageService");
  }
});

// src/upgrade/utils/version-utils.ts
var VersionUtils;
var init_version_utils = __esm({
  "src/upgrade/utils/version-utils.ts"() {
    "use strict";
    VersionUtils = class {
      /**
       * Parse version string into components
       */
      static parseVersion(version) {
        const parts = version.split(".").map(Number);
        return {
          major: parts[0] || 0,
          minor: parts[1] || 0,
          patch: parts[2] || 0,
          original: version
        };
      }
      /**
       * Compare two versions
       * Returns: -1 (v1 < v2), 0 (v1 = v2), 1 (v1 > v2)
       */
      static compareVersions(version1, version2) {
        const v1 = this.parseVersion(version1);
        const v2 = this.parseVersion(version2);
        if (v1.major !== v2.major)
          return v1.major - v2.major;
        if (v1.minor !== v2.minor)
          return v1.minor - v2.minor;
        return v1.patch - v2.patch;
      }
      /**
       * Check if version is in range [min, max]
       */
      static isInRange(version, minVersion, maxVersion) {
        const isAboveMin = this.compareVersions(version, minVersion) >= 0;
        if (!maxVersion)
          return isAboveMin;
        const isBelowMax = this.compareVersions(version, maxVersion) <= 0;
        return isAboveMin && isBelowMax;
      }
      /**
       * Check if migration should run based on version range
       */
      static shouldRunMigration(fromVersion, toVersion, migrationFromVersion, migrationToVersion) {
        const userFrom = this.parseVersion(fromVersion);
        const userTo = this.parseVersion(toVersion);
        const migrationFrom = this.parseVersion(migrationFromVersion);
        const migrationTo = migrationToVersion ? this.parseVersion(migrationToVersion) : userTo;
        const wasInRange = this.compareVersions(fromVersion, migrationFromVersion) >= 0;
        const isUpgradingTo = this.compareVersions(toVersion, migrationTo.original) >= 0;
        return wasInRange && isUpgradingTo;
      }
      /**
       * Get all versions between two versions (for sequential migrations)
       */
      static getVersionsInRange(fromVersion, toVersion, availableVersions) {
        return availableVersions.filter(
          (v) => this.compareVersions(v, fromVersion) > 0 && this.compareVersions(v, toVersion) <= 0
        ).sort((a, b) => this.compareVersions(a, b));
      }
      /**
       * Format version for display
       */
      static formatVersion(version) {
        const parsed = this.parseVersion(version);
        return `v${parsed.major}.${parsed.minor}.${parsed.patch}`;
      }
    };
    __name(VersionUtils, "VersionUtils");
  }
});

// src/upgrade/upgrade-interface.ts
var logger3, UpgradeOperation, VersionUpgrade;
var init_upgrade_interface = __esm({
  "src/upgrade/upgrade-interface.ts"() {
    "use strict";
    init_version_utils();
    init_dialogs();
    init_logger();
    logger3 = new Logger();
    UpgradeOperation = class {
      /**
       * Check if operation can run (prerequisites)
       */
      async canRun(context) {
        return true;
      }
      /**
       * Verify operation completed successfully
       */
      async verify(context) {
        return true;
      }
    };
    __name(UpgradeOperation, "UpgradeOperation");
    VersionUpgrade = class {
      /**
       * Check if this upgrade should run for the version range
       */
      shouldRun(fromVersion, toVersion) {
        return VersionUtils.compareVersions(toVersion, this.version) >= 0 && VersionUtils.compareVersions(fromVersion, this.version) < 0;
      }
      /**
       * Execute all automatic operations
       */
      async executeAutomaticOperations(context) {
        const results = [];
        let allSuccess = true;
        for (const operation of this.automaticOperations) {
          try {
            if (await this.isOperationCompleted(operation.id, context)) {
              results.push({
                operationId: operation.id,
                result: { success: true, message: "Already completed" }
              });
              continue;
            }
            if (!await operation.canRun(context)) {
              results.push({
                operationId: operation.id,
                result: { success: false, message: "Prerequisites not met" }
              });
              allSuccess = false;
              continue;
            }
            const result = await operation.execute(context);
            results.push({ operationId: operation.id, result });
            if (result.success) {
              await this.markOperationCompleted(operation.id, context);
            } else {
              allSuccess = false;
            }
          } catch (error) {
            const errorResult = {
              success: false,
              message: `Operation failed: ${error}`,
              details: { error: String(error) }
            };
            results.push({ operationId: operation.id, result: errorResult });
            allSuccess = false;
          }
        }
        return { success: allSuccess, results };
      }
      /**
       * Show manual operations dialog and execute selected ones
       */
      async showManualOperationsDialog(context) {
        const availableOperations = [];
        for (const operation of this.manualOperations) {
          if (!await this.isOperationCompleted(operation.id, context) && await operation.canRun(context)) {
            availableOperations.push(operation);
          }
        }
        if (availableOperations.length === 0) {
          return { success: true, results: [] };
        }
        const paragraphs = [
          `**Version ${this.version} Manual Operations**`,
          "The following optional operations are available:",
          "",
          ...availableOperations.map((op) => `\u2022 **${op.name}**: ${op.description}`)
        ];
        const shouldExecute = await showDialog(
          context.plugin.app,
          "confirmation",
          `Optional Operations - v${this.version}`,
          paragraphs,
          "These operations are optional and can be run later from Settings \u2192 Migrations",
          { button1: "Run All Now", button2: "Skip (Run Later)" }
        );
        const results = [];
        if (shouldExecute) {
          for (const operation of availableOperations) {
            try {
              const result = await operation.execute(context);
              results.push({ operationId: operation.id, result });
              if (result.success) {
                await this.markOperationCompleted(operation.id, context);
              }
            } catch (error) {
              const errorResult = {
                success: false,
                message: `Operation failed: ${error}`,
                details: { error: String(error) }
              };
              results.push({ operationId: operation.id, result: errorResult });
            }
          }
        }
        return {
          success: results.every((r) => r.result.success),
          results
        };
      }
      /**
       * Get manual operations status for settings UI
       */
      async getManualOperationsStatus(context) {
        const status = [];
        for (const operation of this.manualOperations) {
          const completed = await this.isOperationCompleted(operation.id, context);
          const canRun = !completed && await operation.canRun(context);
          status.push({
            operation,
            completed,
            canRun
          });
        }
        return status;
      }
      /**
       * Execute single manual operation (from settings)
       */
      async executeManualOperation(operationId, context) {
        const operation = this.manualOperations.find((op) => op.id === operationId);
        if (!operation) {
          return { success: false, message: "Operation not found" };
        }
        if (await this.isOperationCompleted(operation.id, context)) {
          return { success: true, message: "Already completed" };
        }
        if (!await operation.canRun(context)) {
          return { success: false, message: "Prerequisites not met" };
        }
        try {
          const result = await operation.execute(context);
          if (result.success) {
            await this.markOperationCompleted(operation.id, context);
          }
          return result;
        } catch (error) {
          return {
            success: false,
            message: `Operation failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if operation was completed using structured upgrade history
       */
      async isOperationCompleted(operationId, context) {
        var _a, _b, _c;
        const data = await context.plugin.loadData();
        const operationKey = `operation_${this.version.replace(/\./g, "_")}_${operationId}`;
        return ((_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedOperations) == null ? void 0 : _b[operationKey]) == null ? void 0 : _c.completed) || false;
      }
      /**
       * Mark operation as completed using structured upgrade history
       */
      async markOperationCompleted(operationId, context) {
        const data = await context.plugin.loadData() || {};
        if (!data.upgradeHistory) {
          data.upgradeHistory = {
            completedUpgrades: {},
            completedOperations: {}
          };
        }
        const operationKey = `operation_${this.version.replace(/\./g, "_")}_${operationId}`;
        data.upgradeHistory.completedOperations[operationKey] = {
          operationId,
          version: this.version,
          date: new Date().toISOString(),
          completed: true
        };
        await context.plugin.saveData(data);
      }
    };
    __name(VersionUpgrade, "VersionUpgrade");
  }
});

// src/upgrade/versions/upgrade-1.1.0.ts
var upgrade_1_1_0_exports = {};
__export(upgrade_1_1_0_exports, {
  Upgrade110: () => Upgrade110
});
var DeleteCatalogOperation, CleanMetadataOperation, Upgrade110;
var init_upgrade_1_1_0 = __esm({
  "src/upgrade/versions/upgrade-1.1.0.ts"() {
    "use strict";
    init_upgrade_interface();
    init_logger();
    DeleteCatalogOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "delete-catalog";
        this.name = "Delete Old Catalog";
        this.description = "Remove legacy conversation catalog data";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const data = await context.plugin.loadData();
          const catalog = data == null ? void 0 : data.conversationCatalog;
          const hasData = catalog && typeof catalog === "object" && Object.keys(catalog).length > 0;
          if (catalog) {
          }
          return hasData;
        } catch (error) {
          logger.error(`DeleteCatalog.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const data = await context.plugin.loadData();
          const catalog = (data == null ? void 0 : data.conversationCatalog) || {};
          const catalogSize = Object.keys(catalog).length;
          if (catalogSize === 0) {
            return {
              success: true,
              message: "No legacy catalog found to delete"
            };
          }
          const existingImportedArchives = data == null ? void 0 : data.importedArchives;
          const cleanedData = {
            settings: data.settings || context.plugin.settings,
            // CRITICAL FIX: Force preservation of importedArchives
            importedArchives: existingImportedArchives || {},
            upgradeHistory: data.upgradeHistory || {
              completedUpgrades: {},
              completedOperations: {}
            },
            // Remove conversationCatalog - key change
            catalogDeletionDate: new Date().toISOString(),
            catalogDeletionStats: { entriesDeleted: catalogSize }
          };
          await context.plugin.saveData(cleanedData);
          const verifyData = await context.plugin.loadData();
          const verifyArchives = (verifyData == null ? void 0 : verifyData.importedArchives) || {};
          if (Object.keys(verifyArchives).length === 0 && Object.keys(existingImportedArchives || {}).length > 0) {
            logger.error(`DeleteCatalog: CRITICAL - importedArchives were lost during save!`);
            return {
              success: false,
              message: `Critical error: importedArchives were lost during migration`,
              details: {
                beforeCount: Object.keys(existingImportedArchives || {}).length,
                afterCount: Object.keys(verifyArchives).length
              }
            };
          }
          return {
            success: true,
            message: `Legacy catalog deleted: ${catalogSize} entries removed, ${Object.keys(verifyArchives).length} imported archives preserved`,
            details: { entriesDeleted: catalogSize, archivesPreserved: Object.keys(verifyArchives).length }
          };
        } catch (error) {
          logger.error(`DeleteCatalog.execute failed:`, error);
          return {
            success: false,
            message: `Failed to delete legacy catalog: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        try {
          const data = await context.plugin.loadData();
          const hasNoCatalog = !(data == null ? void 0 : data.conversationCatalog);
          const hasImportedArchives = (data == null ? void 0 : data.importedArchives) && Object.keys(data.importedArchives).length > 0;
          return hasNoCatalog;
        } catch (error) {
          logger.error(`DeleteCatalog.verify failed:`, error);
          return false;
        }
      }
    };
    __name(DeleteCatalogOperation, "DeleteCatalogOperation");
    CleanMetadataOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "clean-metadata";
        this.name = "Clean & Version Metadata";
        this.description = "Remove unnecessary metadata and add plugin version to conversation notes";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          const canRun = conversationFiles.length > 0;
          return canRun;
        } catch (error) {
          logger.error(`CleanMetadata.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          if (conversationFiles.length === 0) {
            return {
              success: true,
              message: "No conversation files found to clean",
              details: { processed: 0, cleaned: 0, errors: 0 }
            };
          }
          let processed = 0;
          let cleaned = 0;
          let errors = 0;
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                const cleanedContent = this.cleanFrontmatterRobust(content, context.toVersion, file.basename);
                if (content !== cleanedContent) {
                  await context.plugin.app.vault.modify(file, cleanedContent);
                  cleaned++;
                }
              } catch (error) {
                errors++;
                logger.error(`Error cleaning metadata for ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          return {
            success: errors === 0,
            message: `Metadata cleanup completed: ${cleaned} files cleaned, ${errors} errors`,
            details: { processed, cleaned, errors }
          };
        } catch (error) {
          logger.error(`CleanMetadata.execute failed:`, error);
          return {
            success: false,
            message: `Metadata cleanup failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Clean frontmatter with robust parsing and safe alias generation
       */
      cleanFrontmatterRobust(content, pluginVersion, fileName) {
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontmatterMatch) {
          if (content.includes("nexus:") || content.includes("conversation_id:")) {
            logger.warn(`File ${fileName} appears to be Nexus but has malformed frontmatter`);
          }
          return content;
        }
        const frontmatterContent = frontmatterMatch[1];
        const restOfContent = content.substring(frontmatterMatch[0].length);
        const frontmatterData = {};
        const lines = frontmatterContent.split("\n");
        for (const line of lines) {
          const colonIndex = line.indexOf(":");
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            let value = line.substring(colonIndex + 1).trim();
            if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
              value = value.slice(1, -1);
            }
            frontmatterData[key] = value;
          }
        }
        const nexusId = "nexus-ai-chat-importer";
        if (frontmatterData.nexus !== nexusId) {
          return content;
        }
        const safeAlias = this.generateSafeAlias(fileName);
        const newFrontmatter = [];
        newFrontmatter.push(`nexus: ${nexusId}`);
        newFrontmatter.push(`plugin_version: "1.0.x"`);
        if (frontmatterData.provider) {
          newFrontmatter.push(`provider: ${frontmatterData.provider}`);
        }
        newFrontmatter.push(`aliases: ${safeAlias}`);
        if (frontmatterData.conversation_id) {
          newFrontmatter.push(`conversation_id: ${frontmatterData.conversation_id}`);
        }
        if (frontmatterData.create_time) {
          newFrontmatter.push(`create_time: ${frontmatterData.create_time}`);
        }
        if (frontmatterData.update_time) {
          newFrontmatter.push(`update_time: ${frontmatterData.update_time}`);
        }
        const cleanedFrontmatter = newFrontmatter.join("\n");
        return `---
${cleanedFrontmatter}
---${restOfContent}`;
      }
      /**
       * Generate safe alias from filename (reuse the robust filename logic)
       */
      generateSafeAlias(fileName) {
        let cleanName = fileName.replace(/^\d{8}\s*-\s*/, "").replace(/^\d{4}-\d{2}-\d{2}\s*-\s*/, "");
        cleanName = cleanName.replace(/\.md$/, "");
        cleanName = cleanName.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[<>:"\/\\|?*\n\r]+/g, "").replace(/\.{2,}/g, ".").trim();
        cleanName = cleanName.replace(/^[^\w\d\s]+/, "");
        cleanName = cleanName.replace(/\s+/g, " ").trim();
        if (!cleanName || cleanName.length === 0) {
          cleanName = "Untitled";
        }
        if (cleanName.startsWith(".")) {
          cleanName = cleanName.substring(1);
        }
        if (!cleanName || cleanName.length === 0) {
          cleanName = "Untitled";
        }
        return cleanName;
      }
      async verify(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
              if (!frontmatterMatch)
                continue;
              const frontmatterContent = frontmatterMatch[1];
              if (!frontmatterContent.includes("plugin_version:")) {
                return false;
              }
              const forbiddenFields = [
                "conversation_template_id:",
                "gizmo_id:",
                "gizmo_type:",
                "default_model_slug:",
                "is_archived:",
                "is_starred:",
                "current_node:",
                "memory_scope:"
              ];
              const hasUnwantedFields = forbiddenFields.some(
                (field) => frontmatterContent.includes(field)
              );
              if (hasUnwantedFields) {
                return false;
              }
            } catch (error) {
              logger.error(`CleanMetadata.verify error for ${file.path}:`, error);
              return false;
            }
          }
          return true;
        } catch (error) {
          logger.error(`CleanMetadata.verify failed:`, error);
          return false;
        }
      }
    };
    __name(CleanMetadataOperation, "CleanMetadataOperation");
    Upgrade110 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.1.0";
        this.automaticOperations = [
          new DeleteCatalogOperation(),
          new CleanMetadataOperation()
        ];
        this.manualOperations = [
          // No manual operations for 1.1.0 - all operations are automatic
          // Future versions can add manual operations here for truly optional tasks
        ];
      }
    };
    __name(Upgrade110, "Upgrade110");
  }
});

// src/upgrade/versions/upgrade-1.2.0.ts
var upgrade_1_2_0_exports = {};
__export(upgrade_1_2_0_exports, {
  NexusUpgradeModal: () => NexusUpgradeModal,
  Upgrade120: () => Upgrade120
});
var import_obsidian19, ConvertToCalloutsOperation, MoveReportsToProviderOperation, UpdateReportLinksOperation, MoveYearFoldersOperation, NexusUpgradeModal, OfferReimportOperation, Upgrade120;
var init_upgrade_1_2_0 = __esm({
  "src/upgrade/versions/upgrade-1.2.0.ts"() {
    "use strict";
    init_upgrade_interface();
    import_obsidian19 = require("obsidian");
    init_logger();
    ConvertToCalloutsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "convert-to-callouts";
        this.name = "Convert to Modern Callouts";
        this.description = "Transform old indentations (>, >>) to beautiful Nexus callouts";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          for (const file of conversationFiles.slice(0, 10)) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (this.hasOldIndentationFormat(content)) {
                return true;
              }
            } catch (error) {
              logger.error(`Error checking file ${file.path}:`, error);
            }
          }
          return false;
        } catch (error) {
          logger.error(`ConvertToCallouts.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          let processed = 0;
          let converted = 0;
          let errors = 0;
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                if (!this.hasOldIndentationFormat(content)) {
                  continue;
                }
                const convertedContent = this.convertIndentationsToCallouts(content);
                if (content !== convertedContent) {
                  const finalContent = this.updatePluginVersion(convertedContent, "1.2.0");
                  await context.plugin.app.vault.modify(file, finalContent);
                  converted++;
                }
              } catch (error) {
                errors++;
                logger.error(`Error converting ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          return {
            success: errors === 0,
            message: `Callout conversion completed: ${converted} files converted, ${errors} errors`,
            details: { processed, converted, errors }
          };
        } catch (error) {
          logger.error(`ConvertToCallouts.execute failed:`, error);
          return {
            success: false,
            message: `Callout conversion failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if content has old indentation format (v1.1.0)
       */
      hasOldIndentationFormat(content) {
        const oldPatterns = [
          /^### User, on .* at .*;\n>/m,
          // User messages with indentation
          /^#### Assistant, on .* at .*;\n>>/m,
          // Assistant messages with indentation
          /<div class="nexus-attachment-box">/,
          // Old attachment divs
          /<div class="nexus-artifact-box">/,
          // Old artifact divs
          />\[!note\] 📎 \*\*Attachment:\*\*/
          // Old note callouts for attachments
        ];
        return oldPatterns.some((pattern) => pattern.test(content));
      }
      /**
       * Convert old indentations to modern callouts
       */
      convertIndentationsToCallouts(content) {
        let converted = content;
        converted = converted.replace(
          /^### User, on (.*?) at (.*?);\n((?:> .*(?:\n|$))*)/gm,
          (match, date, time, quotedContent) => {
            const cleanContent = quotedContent.replace(/^> /gm, "> ");
            return `>[!nexus_user] **User** - ${date} at ${time}
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /^#### Assistant, on (.*?) at (.*?);\n((?:>> .*(?:\n|$))*)/gm,
          (match, date, time, quotedContent) => {
            const cleanContent = quotedContent.replace(/^>> /gm, "> ");
            return `>[!nexus_agent] **Assistant** - ${date} at ${time}
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /<div class="nexus-attachment-box">\s*\n\s*\*\*📎 Attachment:\*\* ([^(]+)\(([^)]+)\)([\s\S]*?)<\/div>/g,
          (match, fileName, fileType, content2) => {
            const cleanFileName = fileName.trim();
            let cleanContent = content2.trim();
            if (cleanContent.includes("**Content:**")) {
              cleanContent = cleanContent.replace(/\*\*Content:\*\*/g, "").trim();
            }
            if (cleanContent.includes("**Status:**")) {
              cleanContent = cleanContent.replace(/\*\*Status:\*\*/g, "").trim();
            }
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_attachment] **${cleanFileName}** (${fileType})
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /<div class="nexus-artifact-box">\s*([\s\S]*?)\s*<\/div>/g,
          (match, content2) => {
            let cleanContent = content2.trim();
            const titleMatch = cleanContent.match(/\*\*([^*]+)\*\*/);
            const title = titleMatch ? titleMatch[1] : "Artifact";
            cleanContent = cleanContent.replace(/\*\*[^*]+\*\*/g, "").trim();
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_artifact] **${title}**
${cleanContent}`;
          }
        );
        converted = converted.replace(
          />\[!note\] 📎 \*\*Attachment:\*\* ([^(]+)\(([^)]+)\)(.*?)(?=\n\n|\n>|\n<!--|\n---|$)/gs,
          (match, fileName, fileType, content2) => {
            const cleanFileName = fileName.trim();
            let cleanContent = content2.trim();
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_attachment] **${cleanFileName}** (${fileType})
${cleanContent}`;
          }
        );
        return converted;
      }
      /**
       * Update plugin_version in frontmatter
       */
      updatePluginVersion(content, version) {
        return content.replace(
          /^plugin_version: ".*?"$/m,
          `plugin_version: "${version}"`
        );
      }
      async verify(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (this.hasOldIndentationFormat(content)) {
                return false;
              }
              if (!content.includes('plugin_version: "1.2.0"')) {
                return false;
              }
            } catch (error) {
              logger.error(`Error verifying file ${file.path}:`, error);
              return false;
            }
          }
          return true;
        } catch (error) {
          logger.error(`ConvertToCallouts.verify failed:`, error);
          return false;
        }
      }
    };
    __name(ConvertToCalloutsOperation, "ConvertToCalloutsOperation");
    MoveReportsToProviderOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "move-reports-to-provider";
        this.name = "Organize Reports by Provider";
        this.description = "Move reports from root Reports/ folder to Reports/chatgpt/";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const reportFolder = context.plugin.settings.reportFolder;
          const reportFiles = context.plugin.app.vault.getMarkdownFiles().filter((f) => {
            if (!f.path.startsWith(reportFolder + "/"))
              return false;
            const relativePath = f.path.substring(reportFolder.length + 1);
            if (relativePath.includes("/"))
              return false;
            return f.name.includes("import report") || f.name.includes("import_");
          });
          return reportFiles.length > 0;
        } catch (error) {
          logger.error(`MoveReportsToProviderOperation.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const reportFolder = context.plugin.settings.reportFolder;
          let processed = 0;
          let moved = 0;
          let errors = 0;
          const reportFiles = context.plugin.app.vault.getMarkdownFiles().filter((f) => {
            if (!f.path.startsWith(reportFolder + "/"))
              return false;
            const relativePath = f.path.substring(reportFolder.length + 1);
            if (relativePath.includes("/"))
              return false;
            return f.name.includes("import report") || f.name.includes("import_");
          });
          const chatgptReportFolder = `${reportFolder}/chatgpt`;
          try {
            await context.plugin.app.vault.adapter.mkdir(chatgptReportFolder);
          } catch (e) {
          }
          for (const file of reportFiles) {
            try {
              processed++;
              const newPath = `${chatgptReportFolder}/${file.name}`;
              if (await context.plugin.app.vault.adapter.exists(newPath)) {
                continue;
              }
              await context.plugin.app.vault.adapter.rename(file.path, newPath);
              moved++;
            } catch (error) {
              errors++;
              logger.error(`Error moving report ${file.path}:`, error);
            }
          }
          return {
            success: errors === 0,
            message: `Reports organized: ${moved} files moved to provider structure, ${errors} errors`,
            details: { processed, moved, errors }
          };
        } catch (error) {
          logger.error(`MoveReportsToProviderOperation.execute failed:`, error);
          return {
            success: false,
            message: `Report organization failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(_context) {
        return true;
      }
    };
    __name(MoveReportsToProviderOperation, "MoveReportsToProviderOperation");
    UpdateReportLinksOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "update-report-links";
        this.name = "Update Report Links";
        this.description = "Insert 'chatgpt/' before year in report links inside reports";
        this.type = "automatic";
      }
      async canRun(_context) {
        return true;
      }
      escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      async execute(context) {
        try {
          const reportFolder = context.plugin.settings.reportFolder;
          const conversationFolder = context.plugin.settings.conversationFolder;
          const escapedArchive = this.escapeRegExp(conversationFolder);
          let processed = 0;
          let updated = 0;
          let errors = 0;
          const reportPrefixChatgpt = `${reportFolder}/chatgpt/`;
          const reportPrefixRoot = `${reportFolder}/`;
          const reportFiles = context.plugin.app.vault.getMarkdownFiles().filter((f) => {
            if (f.path.startsWith(reportPrefixChatgpt))
              return true;
            if (f.path.startsWith(reportPrefixRoot)) {
              const relativePath = f.path.substring(reportPrefixRoot.length);
              if (!relativePath.includes("/") && (f.name.includes("import report") || f.name.includes("import_"))) {
                return true;
              }
            }
            return false;
          });
          const linkPattern = new RegExp(`(\\[\\[${escapedArchive}/)(\\d{4}/\\d{2}/)`, "g");
          for (const file of reportFiles) {
            try {
              processed++;
              const content = await context.plugin.app.vault.read(file);
              const replaced = content.replace(linkPattern, "$1chatgpt/$2");
              if (replaced !== content) {
                await context.plugin.app.vault.modify(file, replaced);
                updated++;
              }
            } catch (e) {
              errors++;
              logger.error(`UpdateReportLinksOperation error in ${file.path}:`, e);
            }
          }
          return {
            success: errors === 0,
            message: `Report links updated: ${updated} files changed, ${errors} errors`,
            details: { processed, updated, errors }
          };
        } catch (error) {
          logger.error(`UpdateReportLinksOperation.execute failed:`, error);
          return {
            success: false,
            message: `Report link update failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(_context) {
        return true;
      }
    };
    __name(UpdateReportLinksOperation, "UpdateReportLinksOperation");
    MoveYearFoldersOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "move-year-folders";
        this.name = "Organize Conversations by Provider";
        this.description = "Move year folders to chatgpt provider structure";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const yearFolders = await this.findYearFolders(context, conversationFolder);
          return yearFolders.length > 0;
        } catch (error) {
          logger.error(`MoveYearFolders.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          let movedFolders = 0;
          let errors = 0;
          const yearFolders = await this.findYearFolders(context, conversationFolder);
          for (const yearFolder of yearFolders) {
            try {
              const chatgptFolder = `${conversationFolder}/chatgpt`;
              await context.plugin.app.vault.adapter.mkdir(chatgptFolder);
              const newPath = `${chatgptFolder}/${yearFolder}`;
              const oldPath = `${conversationFolder}/${yearFolder}`;
              await context.plugin.app.vault.adapter.rename(oldPath, newPath);
              movedFolders++;
            } catch (error) {
              errors++;
              logger.error(`Error moving year folder ${yearFolder}:`, error);
            }
          }
          return {
            success: errors === 0,
            message: `Conversation organization completed: ${movedFolders} year folders moved to chatgpt structure, ${errors} errors`,
            details: { movedFolders, errors }
          };
        } catch (error) {
          logger.error(`MoveYearFolders.execute failed:`, error);
          return {
            success: false,
            message: `Conversation organization failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder;
          const remainingYearFolders = await this.findYearFolders(context, conversationFolder);
          if (remainingYearFolders.length > 0) {
            return false;
          }
          return true;
        } catch (error) {
          logger.error(`MoveYearFolders.verify failed:`, error);
          return false;
        }
      }
      /**
       * Find year folders (YYYY) directly in conversation folder
       */
      async findYearFolders(context, conversationFolder) {
        try {
          const folders = await context.plugin.app.vault.adapter.list(conversationFolder);
          return folders.folders.filter((folder) => {
            const folderName = folder.split("/").pop() || "";
            return /^\d{4}$/.test(folderName) && folderName !== "chatgpt";
          }).map((folder) => folder.split("/").pop() || "");
        } catch (error) {
          return [];
        }
      }
    };
    __name(MoveYearFoldersOperation, "MoveYearFoldersOperation");
    NexusUpgradeModal = class extends import_obsidian19.Modal {
      constructor(app, plugin, version, resolve) {
        super(app);
        this.plugin = plugin;
        this.version = version;
        this.resolve = resolve;
      }
      onOpen() {
        var _a;
        const { containerEl, titleEl } = this;
        containerEl.classList.add("nexus-upgrade-modal");
        titleEl.setText(`\u{1F680} Nexus AI Chat Importer ${this.version}`);
        (_a = this.modalEl.querySelector(".modal-close-button")) == null ? void 0 : _a.remove();
        this.createForm();
      }
      async onClose() {
        this.contentEl.empty();
      }
      async createForm() {
        const upgradeLocale = window.moment.locale();
        const upgradeSupportedLocales = ["fr", "de", "es", "it", "ru", "zh", "ja", "pt", "ko"];
        const upgradeSupportUrl = upgradeSupportedLocales.includes(upgradeLocale) ? `https://nexus-prod.dev/${upgradeLocale}/nexus-ai-chat-importer/support` : "https://nexus-prod.dev/nexus-ai-chat-importer/support";
        let message = `\u{1F389} **Upgrade to v1.2.0**

Your conversations will be reorganized with provider structure and modern callouts. All links in your reports will be updated.

**\u{1F4A1} To get ALL v1.2.0 features:** Reimport your original ChatGPT ZIP files.

---

## Support My Work

[![Support my work](https://img.shields.io/badge/Support_my_work-nexus--prod.dev-FF5E5B?style=for-the-badge)](${upgradeSupportUrl})`;
        try {
          const response = await fetch("https://api.github.com/repos/Superkikim/nexus-ai-chat-importer/releases/tags/v1.2.0");
          if (response.ok) {
            const release = await response.json();
            if (release.body) {
              message = release.body;
            }
          }
        } catch (error) {
        }
        await import_obsidian19.MarkdownRenderer.render(
          this.app,
          message,
          this.contentEl,
          "",
          this.plugin
        );
        this.contentEl.createEl("div", { cls: "nexus-upgrade-buttons" }, (el) => {
          el.style.textAlign = "right";
          el.style.marginTop = "20px";
          el.style.paddingTop = "15px";
          el.style.borderTop = "1px solid var(--background-modifier-border)";
          const btnOk = el.createEl("button", {
            text: "Proceed",
            cls: "nexus-btn-primary"
          });
          btnOk.onclick = () => {
            this.close();
            this.resolve("ok");
          };
        });
      }
    };
    __name(NexusUpgradeModal, "NexusUpgradeModal");
    OfferReimportOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "offer-reimport";
        this.name = "Full Feature Reimport";
        this.description = "Optionally reimport conversations to get all v1.2.0 features (attachments, chronological order, etc.)";
        this.type = "manual";
      }
      async canRun(_context) {
        return true;
      }
      async execute(_context) {
        try {
          return {
            success: true,
            message: "Upgrade information provided to user",
            details: { action: "info_displayed" }
          };
        } catch (error) {
          logger.error(`OfferReimport.execute failed:`, error);
          return {
            success: false,
            message: `Failed to complete reimport operation: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(_context) {
        return true;
      }
    };
    __name(OfferReimportOperation, "OfferReimportOperation");
    Upgrade120 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.2.0";
        this.automaticOperations = [
          new MoveYearFoldersOperation(),
          new MoveReportsToProviderOperation(),
          new UpdateReportLinksOperation(),
          new ConvertToCalloutsOperation()
        ];
        this.manualOperations = [
          new OfferReimportOperation()
        ];
      }
    };
    __name(Upgrade120, "Upgrade120");
  }
});

// src/dialogs/configure-folder-locations-dialog.ts
var import_obsidian20, ConfigureFolderLocationsDialog;
var init_configure_folder_locations_dialog = __esm({
  "src/dialogs/configure-folder-locations-dialog.ts"() {
    "use strict";
    import_obsidian20 = require("obsidian");
    init_enhanced_folder_migration_dialog();
    init_folder_tree_browser_modal();
    init_folder_validation();
    init_utils();
    init_i18n();
    ConfigureFolderLocationsDialog = class extends import_obsidian20.Modal {
      // Track if onComplete was already called
      constructor(plugin, onComplete) {
        super(plugin.app);
        this.plugin = plugin;
        this.reportFolderInput = null;
        this.completed = false;
        this.onComplete = onComplete;
        this.originalReportFolder = plugin.settings.reportFolder || "Nexus Reports";
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", {
          text: t("configure_folder_dialog.title"),
          cls: "nexus-upgrade-title"
        });
        const messageContainer = contentEl.createDiv({ cls: "nexus-upgrade-message" });
        const descriptionEl = messageContainer.createDiv({ cls: "nexus-upgrade-description" });
        descriptionEl.createEl("p", {
          text: t("configure_folder_dialog.description", { folder: this.originalReportFolder })
        });
        descriptionEl.createEl("p", {
          text: t("configure_folder_dialog.note"),
          cls: "nexus-upgrade-note"
        });
        const folderSection = contentEl.createDiv({ cls: "nexus-upgrade-folder-section" });
        folderSection.createEl("div", {
          text: t("configure_folder_dialog.report_folder_label"),
          cls: "nexus-upgrade-folder-label"
        });
        const inputContainer = folderSection.createDiv({ cls: "nexus-upgrade-input-container" });
        this.reportFolderInput = inputContainer.createEl("input", {
          type: "text",
          placeholder: t("configure_folder_dialog.report_folder_placeholder"),
          value: this.originalReportFolder,
          cls: "nexus-upgrade-folder-input"
        });
        this.reportFolderInput.readOnly = true;
        this.reportFolderInput.style.cursor = "default";
        const browseButton = inputContainer.createEl("button", {
          text: t("configure_folder_dialog.buttons.browse"),
          cls: "mod-cta nexus-upgrade-browse-button"
        });
        browseButton.addEventListener("click", () => {
          const modal = new FolderTreeBrowserModal(
            this.plugin.app,
            (path) => {
              if (this.reportFolderInput) {
                this.reportFolderInput.value = path;
              }
            },
            this.originalReportFolder
          );
          modal.open();
        });
        const buttonContainer = contentEl.createDiv({ cls: "nexus-upgrade-button-container-centered" });
        const proceedButton = buttonContainer.createEl("button", {
          text: t("configure_folder_dialog.buttons.proceed"),
          cls: "mod-cta nexus-upgrade-proceed-button"
        });
        proceedButton.addEventListener("click", async () => {
          await this.handleSave();
        });
        this.addStyles();
      }
      async handleSave() {
        var _a;
        if (this.completed)
          return;
        if (!this.reportFolderInput) {
          this.completed = true;
          this.close();
          this.onComplete({
            conversationFolder: {
              changed: false,
              oldPath: this.plugin.settings.conversationFolder,
              newPath: this.plugin.settings.conversationFolder
            },
            reportFolder: {
              changed: false,
              oldPath: this.originalReportFolder,
              newPath: this.originalReportFolder
            },
            attachmentFolder: {
              changed: false,
              oldPath: this.plugin.settings.attachmentFolder,
              newPath: this.plugin.settings.attachmentFolder
            }
          });
          return;
        }
        const newReportFolder = this.reportFolderInput.value.trim();
        const validation = validateFolderNesting(
          "reportFolder",
          newReportFolder,
          this.plugin.settings.conversationFolder,
          this.originalReportFolder,
          // Use original to avoid self-check
          this.plugin.settings.attachmentFolder
        );
        if (!validation.valid) {
          this.showErrorDialog(t("configure_folder_dialog.error_invalid_folder.title"), t("configure_folder_dialog.error_invalid_folder.message", { error: (_a = validation.error) != null ? _a : "Invalid folder configuration" }));
          return;
        }
        const result = {
          conversationFolder: {
            changed: false,
            oldPath: this.plugin.settings.conversationFolder,
            newPath: this.plugin.settings.conversationFolder
          },
          reportFolder: {
            changed: newReportFolder !== this.originalReportFolder,
            oldPath: this.originalReportFolder,
            newPath: newReportFolder
          },
          attachmentFolder: {
            changed: false,
            oldPath: this.plugin.settings.attachmentFolder,
            newPath: this.plugin.settings.attachmentFolder
          }
        };
        this.completed = true;
        this.close();
        await this.handleFolderChange("reportFolder", result.reportFolder);
        this.onComplete(result);
      }
      async handleFolderChange(folderType, folderInfo) {
        if (!folderInfo.changed) {
          return;
        }
        const oldPath = folderInfo.oldPath;
        const newPath = folderInfo.newPath;
        const newFolder = this.plugin.app.vault.getAbstractFileByPath(newPath);
        if (newFolder && newFolder instanceof import_obsidian20.TFolder && newFolder.children.length > 0) {
          this.showErrorDialog(
            "Target Folder Not Empty",
            `The folder "${newPath}" already contains files.

To change the folder location:
\u2022 Move existing files manually in Obsidian, OR
\u2022 Choose an empty folder or create a new one`
          );
          return;
        }
        this.plugin.settings[folderType] = newPath;
        await this.plugin.saveSettings();
        const oldFolder = this.plugin.app.vault.getAbstractFileByPath(oldPath);
        if (!oldFolder || !(oldFolder instanceof import_obsidian20.TFolder) || oldFolder.children.length === 0) {
          return;
        }
        const folderTypeLabel = folderType === "conversationFolder" ? "conversations" : folderType === "reportFolder" ? "reports" : "attachments";
        await new Promise((resolve) => {
          const handleMigrationAction = /* @__PURE__ */ __name(async (action) => {
            if (action === "move") {
              try {
                const result = await moveAndMergeFolders(oldFolder, newPath, this.plugin.app.vault);
                folderInfo.filesMoved = result.moved;
                if (result.success && result.skipped === 0) {
                  new import_obsidian20.Notice(`\u2705 Files moved to ${newPath}`);
                } else {
                  this.showMergeResultDialog(result, oldPath, newPath);
                }
              } catch (error) {
                this.plugin.logger.error(`Failed to move ${folderTypeLabel} folder:`, error);
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.showErrorDialog("Migration Failed", `Failed to move files: ${errorMessage}`);
              }
            } else if (action === "cancel") {
              this.plugin.settings[folderType] = oldPath;
              await this.plugin.saveSettings();
            }
            resolve();
          }, "handleMigrationAction");
          const dialog = new EnhancedFolderMigrationDialog(
            this.plugin,
            oldPath,
            newPath,
            folderTypeLabel,
            handleMigrationAction
          );
          dialog.open();
        });
      }
      /**
       * Show dialog with merge result details when files were skipped or errors occurred
       */
      showMergeResultDialog(result, oldPath, newPath) {
        const modal = new import_obsidian20.Modal(this.plugin.app);
        modal.titleEl.setText(t("folder_migration.result_dialog.title"));
        const { contentEl } = modal;
        const summary = contentEl.createDiv({ cls: "nexus-merge-summary" });
        summary.createEl("h3", { text: t("folder_migration.result_dialog.summary_title") });
        const stats = summary.createDiv({ cls: "nexus-merge-stats" });
        stats.createEl("p", { text: t("folder_migration.result_dialog.moved", { count: String(result.moved) }) });
        if (result.skipped > 0) {
          stats.createEl("p", {
            text: t("folder_migration.result_dialog.skipped", { count: String(result.skipped) }),
            cls: "nexus-merge-warning"
          });
        }
        if (result.errors > 0) {
          stats.createEl("p", {
            text: t("folder_migration.result_dialog.errors", { count: String(result.errors) }),
            cls: "nexus-merge-error"
          });
        }
        const explanation = contentEl.createDiv({ cls: "nexus-merge-explanation" });
        explanation.createEl("p", {
          text: t("folder_migration.result_dialog.explanation")
        });
        if (result.errorDetails && result.errorDetails.length > 0) {
          const errorSection = contentEl.createDiv({ cls: "nexus-merge-errors" });
          errorSection.createEl("h4", { text: t("folder_migration.result_dialog.error_details_title") });
          const errorList = errorSection.createEl("ul");
          for (const error of result.errorDetails) {
            errorList.createEl("li", { text: error });
          }
        }
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        const closeButton = buttonContainer.createEl("button", { text: t("common.buttons.ok"), cls: "mod-cta" });
        closeButton.addEventListener("click", () => modal.close());
        const styleEl = document.createElement("style");
        styleEl.textContent = `
            .nexus-merge-summary {
                margin-bottom: 20px;
            }
            .nexus-merge-stats p {
                margin: 8px 0;
                font-size: 14px;
            }
            .nexus-merge-warning {
                color: var(--text-warning);
            }
            .nexus-merge-error {
                color: var(--text-error);
            }
            .nexus-merge-explanation {
                padding: 12px;
                background: var(--background-secondary);
                border-radius: 4px;
                margin: 16px 0;
            }
            .nexus-merge-errors {
                margin-top: 16px;
                padding: 12px;
                background: var(--background-modifier-error);
                border-radius: 4px;
            }
            .nexus-merge-errors ul {
                margin: 8px 0;
                padding-left: 20px;
            }
            .nexus-merge-errors li {
                margin: 4px 0;
                font-size: 12px;
                font-family: var(--font-monospace);
            }
        `;
        document.head.appendChild(styleEl);
        modal.open();
      }
      addStyles() {
        const styleEl = document.createElement("style");
        styleEl.textContent = `
            .nexus-upgrade-title {
                margin-bottom: 1em;
                color: var(--text-normal);
                text-align: center;
            }

            .nexus-upgrade-message {
                margin-bottom: 1.5em;
                line-height: 1.6;
            }

            .nexus-upgrade-description {
                font-size: 1.05em;
                line-height: 1.6;
                margin-bottom: 1.5em;
            }

            .nexus-upgrade-description p {
                margin: 0.8em 0;
            }

            .nexus-upgrade-note {
                font-size: 0.95em;
                color: var(--text-muted);
                font-style: italic;
            }

            .nexus-upgrade-folder-section {
                background-color: var(--background-secondary);
                padding: 1.5em;
                margin: 1em 0;
                border-radius: 8px;
            }

            .nexus-upgrade-folder-label {
                font-size: 1.1em;
                font-weight: 600;
                margin-bottom: 0.8em;
                color: var(--text-normal);
            }

            .nexus-upgrade-input-container {
                display: flex;
                gap: 0.8em;
                align-items: stretch;
                width: 100%;
            }

            .nexus-upgrade-folder-input {
                flex: 1;
                padding: 0.6em 0.8em;
                font-size: 1em;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background-color: var(--background-primary);
                color: var(--text-normal);
                min-width: 0;
            }

            .nexus-upgrade-browse-button {
                padding: 0.6em 1.2em !important;
                font-size: 1em !important;
                white-space: nowrap;
                flex-shrink: 0;
            }

            .nexus-upgrade-button-container-centered {
                display: flex;
                justify-content: center;
                margin-top: 2em;
            }

            .nexus-upgrade-proceed-button {
                padding: 12px 48px !important;
                font-size: 16px !important;
                font-weight: 600 !important;
                min-width: 200px;
            }
        `;
        document.head.appendChild(styleEl);
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
        if (!this.completed && this.onComplete) {
          this.completed = true;
          this.onComplete({
            conversationFolder: {
              changed: false,
              oldPath: this.plugin.settings.conversationFolder,
              newPath: this.plugin.settings.conversationFolder
            },
            reportFolder: {
              changed: false,
              oldPath: this.originalReportFolder,
              newPath: this.originalReportFolder
            },
            attachmentFolder: {
              changed: false,
              oldPath: this.plugin.settings.attachmentFolder,
              newPath: this.plugin.settings.attachmentFolder
            }
          });
        }
      }
      showErrorDialog(title, message) {
        const modal = new import_obsidian20.Modal(this.plugin.app);
        modal.titleEl.setText(title);
        modal.contentEl.createEl("p", {
          text: message,
          cls: "nexus-error-message"
        });
        const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.marginTop = "1em";
        const okButton = buttonContainer.createEl("button", {
          text: t("common.buttons.ok"),
          cls: "mod-cta"
        });
        okButton.addEventListener("click", () => modal.close());
        modal.open();
      }
    };
    __name(ConfigureFolderLocationsDialog, "ConfigureFolderLocationsDialog");
  }
});

// src/upgrade/versions/upgrade-1.3.0.ts
var upgrade_1_3_0_exports = {};
__export(upgrade_1_3_0_exports, {
  Upgrade130: () => Upgrade130
});
var import_obsidian21, ConvertToISO8601TimestampsOperation, FixFrontmatterAliasesOperation, MigrateToSeparateFoldersOperation, MigrateClaudeArtifactsOperation, ConfigureFolderLocationsOperation, Upgrade130;
var init_upgrade_1_3_0 = __esm({
  "src/upgrade/versions/upgrade-1.3.0.ts"() {
    "use strict";
    init_upgrade_interface();
    init_utils();
    init_date_parser();
    import_obsidian21 = require("obsidian");
    init_configure_folder_locations_dialog();
    ConvertToISO8601TimestampsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "convert-to-iso8601-timestamps";
        this.name = "Convert Timestamps to ISO 8601";
        this.description = "Converts conversation timestamps to universal ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ). This fixes parsing issues with locale-specific date formats and ensures consistent timestamps across all regions.";
        this.type = "automatic";
      }
      async canRun(context) {
        var _a;
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          const samples = [];
          let foundNonISO = false;
          for (const file of conversationFiles) {
            const fm = (_a = context.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
            if (!fm || fm.nexus !== context.plugin.manifest.id)
              continue;
            const vals = [fm.create_time, fm.update_time].filter((v) => typeof v === "string");
            for (const v of vals) {
              if (!/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}(:\d{2})?(\.\d{3})?Z?$/.test(v)) {
                samples.push(v);
                foundNonISO = true;
              }
            }
          }
          if (samples.length) {
            const format = DateParser.detectFormatFromSamples(samples);
            this.globalOrder = format == null ? void 0 : format.order;
          }
          if (foundNonISO) {
            return true;
          }
          return false;
        } catch (error) {
          console.error(`ConvertToISO8601Timestamps.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        var _a;
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          if (!this.globalOrder) {
            const samples = [];
            for (const file of conversationFiles) {
              const fm = (_a = context.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
              if (!fm || fm.nexus !== context.plugin.manifest.id)
                continue;
              const vals = [fm.create_time, fm.update_time].filter((v) => typeof v === "string");
              for (const v of vals) {
                if (!/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}(:\d{2})?(\.\d{3})?Z?$/.test(v)) {
                  samples.push(v);
                }
              }
            }
            if (samples.length) {
              const format = DateParser.detectFormatFromSamples(samples);
              this.globalOrder = format == null ? void 0 : format.order;
            }
          }
          let processed = 0;
          let converted = 0;
          let skipped = 0;
          let alreadyISO = 0;
          let failed = 0;
          let errors = 0;
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                if (!this.isNexusFile(content)) {
                  skipped++;
                  continue;
                }
                const hadNonISO = this.hasNonISOTimestamps(content);
                if (!hadNonISO) {
                  alreadyISO++;
                  continue;
                }
                const convertedContent = this.convertTimestampsToISO8601(content);
                if (content !== convertedContent) {
                  const finalContent = this.updatePluginVersion(convertedContent, "1.3.0");
                  await context.plugin.app.vault.modify(file, finalContent);
                  converted++;
                } else {
                  failed++;
                }
              } catch (error) {
                errors++;
                console.error(`Error converting timestamps in ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          const results = [];
          results.push(`**What this does:**`);
          results.push(`Converts conversation timestamps to universal ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ).`);
          results.push(`This fixes parsing issues with locale-specific date formats.`);
          results.push(``);
          results.push(`**Summary:**`);
          results.push(``);
          results.push(`- Total files scanned: ${processed}`);
          results.push(`- Already in ISO format: ${alreadyISO}`);
          results.push(`- Converted to ISO: ${converted}`);
          results.push(`- Skipped (non-Nexus): ${skipped}`);
          if (failed > 0) {
            results.push(`- Failed to convert: ${failed}`);
          }
          if (errors > 0) {
            results.push(`- Errors: ${errors}`);
          }
          return {
            success: errors === 0,
            message: `Converted ${converted} conversation(s) to ISO 8601 format.`,
            details: results
          };
        } catch (error) {
          console.error(`ConvertToISO8601Timestamps.execute failed:`, error);
          return {
            success: false,
            message: `Timestamp conversion failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if file belongs to Nexus plugin
       */
      isNexusFile(content) {
        return content.includes("nexus: nexus-ai-chat-importer");
      }
      /**
       * Check if content has non-ISO timestamps (need conversion to ISO 8601)
       * Detects any format that is not already ISO 8601
       */
      hasNonISOTimestamps(content) {
        const frontmatterMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
        if (!frontmatterMatch) {
          return false;
        }
        const frontmatter = frontmatterMatch[1];
        const hasISO = /^(create|update)_time: \d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/m.test(frontmatter);
        if (hasISO) {
          return false;
        }
        const hasNonISO = /^(create|update)_time: \d{1,4}[\/\.\-]\d{1,2}[\/\.\-]\d{2,4}/m.test(frontmatter);
        return hasNonISO;
      }
      /**
       * Convert any date format to ISO 8601 in frontmatter only
       * Supports: US, EU, DE, JP, and all locale-based formats
       * Uses intelligent DateParser for automatic format detection
       */
      convertTimestampsToISO8601(content) {
        const frontmatterMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
        if (!frontmatterMatch) {
          return content;
        }
        let frontmatter = frontmatterMatch[1];
        const restOfContent = content.substring(frontmatterMatch[0].length);
        let conversionCount = 0;
        frontmatter = frontmatter.replace(
          /^(create|update)_time: (.+)$/gm,
          (match, field, dateStr) => {
            if (/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/.test(dateStr)) {
              return match;
            }
            let isoDate = DateParser.convertToISO8601(dateStr);
            if (!isoDate && this.globalOrder) {
              isoDate = DateParser.convertToISO8601WithOrder(dateStr, this.globalOrder);
            }
            if (!isoDate) {
              console.warn(`convertTimestampsToISO8601 - FAILED to convert: ${dateStr}`);
              return match;
            }
            conversionCount++;
            return `${field}_time: ${isoDate}`;
          }
        );
        return `---
${frontmatter}
---${restOfContent}`;
      }
      /**
       * Update plugin_version in frontmatter
       */
      updatePluginVersion(content, version) {
        return content.replace(
          /^plugin_version: ".*?"$/m,
          `plugin_version: "${version}"`
        );
      }
      async verify(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (!this.isNexusFile(content)) {
                continue;
              }
              if (this.hasNonISOTimestamps(content)) {
                return false;
              }
              if (!content.includes('plugin_version: "1.3.0"')) {
                return false;
              }
            } catch (error) {
              console.error(`Error verifying file ${file.path}:`, error);
              return false;
            }
          }
          return true;
        } catch (error) {
          console.error(`ConvertToISO8601Timestamps.verify failed:`, error);
          return false;
        }
      }
    };
    __name(ConvertToISO8601TimestampsOperation, "ConvertToISO8601TimestampsOperation");
    FixFrontmatterAliasesOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "fix-frontmatter-aliases";
        this.name = "Fix Frontmatter Aliases";
        this.description = "Fixes YAML syntax errors in conversation aliases. Properly quotes titles containing special characters (colons, brackets, etc.) to prevent frontmatter parsing errors.";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          for (const file of conversationFiles.slice(0, 10)) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (!this.isNexusFile(content)) {
                continue;
              }
              if (this.hasProblematicAlias(content)) {
                return true;
              }
            } catch (error) {
              console.error(`Error checking file ${file.path}:`, error);
            }
          }
          return false;
        } catch (error) {
          console.error(`FixFrontmatterAliases.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          let processed = 0;
          let fixed = 0;
          let skipped = 0;
          let errors = 0;
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                if (!this.isNexusFile(content)) {
                  skipped++;
                  continue;
                }
                if (!this.hasProblematicAlias(content)) {
                  continue;
                }
                const fixedContent = this.fixAliases(content);
                if (content !== fixedContent) {
                  await context.plugin.app.vault.modify(file, fixedContent);
                  fixed++;
                }
              } catch (error) {
                errors++;
                console.error(`Error fixing aliases in ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          const results = [];
          results.push(`**What this does:**`);
          results.push(`Fixes YAML syntax errors in conversation aliases caused by special characters.`);
          results.push(`Properly quotes titles containing colons, brackets, etc. to prevent parsing errors.`);
          results.push(``);
          results.push(`**Summary:**`);
          results.push(``);
          results.push(`- Total files scanned: ${processed}`);
          results.push(`- Fixed: ${fixed}`);
          results.push(`- Skipped (non-Nexus): ${skipped}`);
          if (errors > 0) {
            results.push(`- Errors: ${errors}`);
          }
          return {
            success: errors === 0,
            message: `Fixed ${fixed} conversation(s) with problematic aliases.`,
            details: results
          };
        } catch (error) {
          console.error(`FixFrontmatterAliases.execute failed:`, error);
          return {
            success: false,
            message: `Alias fix failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if file belongs to Nexus plugin
       */
      isNexusFile(content) {
        return content.includes("nexus: nexus-ai-chat-importer");
      }
      /**
       * Check if content has problematic aliases (YAML special characters without proper quoting)
       */
      hasProblematicAlias(content) {
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontmatterMatch)
          return false;
        const frontmatter = frontmatterMatch[1];
        const aliasMatch = frontmatter.match(/^aliases: (.+)$/m);
        if (!aliasMatch)
          return false;
        const aliasValue = aliasMatch[1];
        if (aliasValue.startsWith("'") && aliasValue.endsWith("'")) {
          return false;
        }
        if (aliasValue.startsWith('"') && aliasValue.endsWith('"')) {
          return true;
        }
        const needsQuoting = aliasValue.includes(":") || aliasValue.includes("[") || aliasValue.includes("]") || aliasValue.includes("{") || aliasValue.includes("}") || aliasValue.includes('"') || /^(true|false|null|yes|no|on|off|\d+|\d*\.\d+)$/i.test(aliasValue) || aliasValue.startsWith("#") || aliasValue.startsWith("&") || aliasValue.startsWith("*") || aliasValue.startsWith("!") || aliasValue.startsWith("|") || aliasValue.startsWith(">") || aliasValue.startsWith("%") || aliasValue.startsWith("@") || aliasValue.startsWith("`");
        return needsQuoting;
      }
      /**
       * Fix aliases in frontmatter using generateSafeAlias
       */
      fixAliases(content) {
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontmatterMatch)
          return content;
        let frontmatter = frontmatterMatch[1];
        const restOfContent = content.substring(frontmatterMatch[0].length);
        frontmatter = frontmatter.replace(
          /^aliases: (.+)$/m,
          (_m, aliasValue) => {
            let cleanAlias = aliasValue.trim();
            if (cleanAlias.startsWith('"') && cleanAlias.endsWith('"') || cleanAlias.startsWith("'") && cleanAlias.endsWith("'")) {
              cleanAlias = cleanAlias.slice(1, -1);
            }
            cleanAlias = cleanAlias.replace(/''/g, "'");
            const safeAlias = generateSafeAlias(cleanAlias);
            return `aliases: ${safeAlias}`;
          }
        );
        return `---
${frontmatter}
---${restOfContent}`;
      }
      async verify(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(conversationFolder))
              return false;
            const relativePath = file.path.substring(conversationFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (!this.isNexusFile(content)) {
                continue;
              }
              if (this.hasProblematicAlias(content)) {
                return false;
              }
            } catch (error) {
              console.error(`Error verifying file ${file.path}:`, error);
              return false;
            }
          }
          return true;
        } catch (error) {
          console.error(`FixFrontmatterAliases.verify failed:`, error);
          return false;
        }
      }
    };
    __name(FixFrontmatterAliasesOperation, "FixFrontmatterAliasesOperation");
    MigrateToSeparateFoldersOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "migrate-to-separate-folders";
        this.name = "Implement Separate Folder Settings";
        this.description = "Creates dedicated settings for Reports folder location and moves Reports from inside Conversations to the vault root for better organization.";
        this.type = "automatic";
      }
      async canRun(context) {
        const reportFolder = context.plugin.settings.reportFolder;
        const archiveFolder = context.plugin.settings.archiveFolder || "Nexus/Conversations";
        const oldReportPath = `${archiveFolder}/Reports`;
        return !reportFolder || reportFolder === "" || reportFolder === oldReportPath;
      }
      async execute(context) {
        const results = [];
        try {
          results.push(`**What this does:**`);
          results.push(`Version 1.3.0 adds a dedicated setting for the Reports folder location.`);
          results.push(`To prevent reports from moving when you reorganize conversations, we're moving the Reports folder to the vault root.`);
          results.push(``);
          const oldArchiveFolder = context.plugin.settings.archiveFolder || "Nexus/Conversations";
          const oldReportPath = `${oldArchiveFolder}/Reports`;
          const newReportPath = "Nexus Reports";
          const oldReportFolder = context.plugin.app.vault.getAbstractFileByPath(oldReportPath);
          let reportsMoved = false;
          if (oldReportFolder && oldReportFolder instanceof import_obsidian21.TFolder) {
            try {
              const result = await moveAndMergeFolders(oldReportFolder, newReportPath, context.plugin.app.vault);
              reportsMoved = result.moved > 0;
              try {
                const stillExists = await context.plugin.app.vault.adapter.exists(oldReportPath);
                if (stillExists) {
                  const folderToDelete = context.plugin.app.vault.getAbstractFileByPath(oldReportPath);
                  if (folderToDelete && folderToDelete instanceof import_obsidian21.TFolder) {
                    await context.plugin.app.vault.delete(folderToDelete);
                  }
                }
              } catch (deleteError) {
              }
              if (result.success && result.skipped === 0) {
                results.push(`\u2705 Reports folder moved: \`${oldReportPath}\` \u2192 \`${newReportPath}\` (${result.moved} file(s))`);
              } else {
                results.push(`\u26A0\uFE0F Reports folder migration completed with warnings:`);
                results.push(`   - Successfully moved: ${result.moved} file(s)`);
                if (result.skipped > 0) {
                  results.push(`   - Skipped (already exist): ${result.skipped} file(s)`);
                }
                if (result.errors > 0) {
                  results.push(`   - Errors: ${result.errors} file(s)`);
                }
              }
            } catch (error) {
              console.error(`[MigrateReportsFolder] Failed to move Reports folder:`, error);
              context.plugin.settings.reportFolder = oldReportPath;
              results.push(`\u26A0\uFE0F Reports folder could not be moved automatically.`);
              results.push(`   Current location: \`${oldReportPath}\``);
              results.push(`   You can move it manually later in settings.`);
            }
          } else {
            results.push(`\u2139\uFE0F No existing Reports folder found. New reports will be created in \`${newReportPath}\``);
          }
          if (reportsMoved || !oldReportFolder) {
            context.plugin.settings.reportFolder = newReportPath;
          }
          await context.plugin.saveSettings();
          return {
            success: true,
            message: "Reports folder migrated successfully",
            details: results
          };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          console.error(`[MigrateReportsFolder] Failed:`, error);
          results.push(`\u274C Error: ${errorMsg}`);
          return {
            success: false,
            message: `Failed to migrate Reports folder: ${errorMsg}`,
            details: results
          };
        }
      }
      async verify(context) {
        try {
          return !!context.plugin.settings.reportFolder;
        } catch (error) {
          console.error(`MigrateReportsFolder.verify failed:`, error);
          return false;
        }
      }
    };
    __name(MigrateToSeparateFoldersOperation, "MigrateToSeparateFoldersOperation");
    MigrateClaudeArtifactsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "migrate-claude-artifacts";
        this.name = "Migrate Claude Artifacts";
        this.description = "Updates existing Claude artifacts: removes redundant header information (already in frontmatter), adds missing conversation links, and adds creation timestamps for better organization.";
        this.type = "automatic";
      }
      async canRun(context) {
        var _a;
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus AI Chat Imports/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const folder = context.plugin.app.vault.getAbstractFileByPath(claudeArtifactsPath);
          if (!folder || !(folder instanceof import_obsidian21.TFolder)) {
            return false;
          }
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const artifactFiles = allFiles.filter((file) => file.path.startsWith(claudeArtifactsPath));
          if (artifactFiles.length === 0) {
            return false;
          }
          for (const file of artifactFiles) {
            const fm = (_a = context.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
            if (!fm || fm.provider !== "claude")
              continue;
            if (!fm.create_time) {
              return true;
            }
            const content = await context.plugin.app.vault.read(file);
            if (content.includes("**Type:** Claude Artifact") || content.includes("**Command:**") || content.includes("**UUID:**")) {
              return true;
            }
          }
          return false;
        } catch (error) {
          console.error(`MigrateClaudeArtifacts.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        var _a;
        const results = [];
        let totalFiles = 0;
        let processedCount = 0;
        let skippedCount = 0;
        let updatedCount = 0;
        let errorCount = 0;
        let warningCount = 0;
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus AI Chat Imports/Attachments";
          const conversationFolder = context.plugin.settings.conversationFolder || "Nexus/Conversations";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const artifactFiles = allFiles.filter((file) => file.path.startsWith(claudeArtifactsPath));
          totalFiles = artifactFiles.length;
          results.push(`**What this does:**`);
          results.push(`Updates your existing Claude artifacts to the new format:`);
          results.push(`- Removes redundant header information (Type, Language, Command, etc.)`);
          results.push(`- Adds missing conversation links`);
          results.push(`- Adds creation timestamps for better organization`);
          results.push(``);
          results.push(`**Processing ${totalFiles} artifact file(s)...**`);
          results.push(``);
          for (const file of artifactFiles) {
            try {
              const fm = (_a = context.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
              if (!fm || fm.provider !== "claude") {
                skippedCount++;
                continue;
              }
              processedCount++;
              let content = await context.plugin.app.vault.read(file);
              let modified = false;
              let warnings = [];
              const fmMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
              if (!fmMatch) {
                errorCount++;
                results.push(`\u274C ${file.basename}: Invalid frontmatter format`);
                continue;
              }
              let frontmatter = fmMatch[1];
              let body = fmMatch[2];
              if (!fm.create_time) {
                const createTime = await this.extractArtifactCreateTime(
                  fm,
                  conversationFolder,
                  context.plugin,
                  file
                );
                if (createTime.source === "message") {
                  frontmatter += `
create_time: ${createTime.value}`;
                  modified = true;
                } else if (createTime.source === "conversation") {
                  frontmatter += `
create_time: ${createTime.value}`;
                  warnings.push(`Used conversation create_time (message not found)`);
                  warningCount++;
                  modified = true;
                } else {
                  warnings.push(`Could not determine create_time`);
                  warningCount++;
                  console.warn(`${file.basename}: TASK 1 - FAILED to determine create_time`);
                }
              } else {
              }
              const headerRegex = /\n\n\*\*Type:\*\* Claude Artifact\n\*\*Language:\*\*[^\n]*(?:\n\*\*Command:\*\*[^\n]*)?(?:\n\*\*Version:\*\*[^\n]*)?(?:\n\*\*ID:\*\*[^\n]*)?(?:\n\*\*UUID:\*\*[^\n]*)?/;
              if (headerRegex.test(body)) {
                body = body.replace(headerRegex, "");
                modified = true;
              } else {
              }
              if (!body.includes("**Conversation:**") && fm.conversation_id) {
                const conversationLink = await this.findConversationLink(
                  fm.conversation_id,
                  conversationFolder,
                  context.plugin
                );
                if (conversationLink) {
                  const titleMatch = body.match(/^# [^\n]+\n/);
                  if (titleMatch) {
                    const insertPos = titleMatch[0].length;
                    body = body.substring(0, insertPos) + `
**Conversation:** ${conversationLink}
` + body.substring(insertPos);
                    modified = true;
                  } else {
                    console.warn(`${file.basename}: TASK 3 - Could not find title to insert link after`);
                  }
                } else {
                  warnings.push(`Conversation note not found (ID: ${fm.conversation_id})`);
                  warningCount++;
                  console.warn(`${file.basename}: TASK 3 - Conversation note not found for ID ${fm.conversation_id}`);
                }
              } else if (body.includes("**Conversation:**")) {
              } else {
              }
              const needsVersionUpdate = !frontmatter.includes('plugin_version: "1.3.0"');
              if (modified || needsVersionUpdate) {
                if (frontmatter.includes("plugin_version:")) {
                  frontmatter = frontmatter.replace(
                    /^plugin_version: .*$/m,
                    `plugin_version: "1.3.0"`
                  );
                } else {
                  frontmatter += `
plugin_version: "1.3.0"`;
                }
                const newContent = `---
${frontmatter}
---
${body}`;
                await context.plugin.app.vault.modify(file, newContent);
                updatedCount++;
                if (modified) {
                } else {
                }
                if (warnings.length > 0) {
                  results.push(`\u26A0\uFE0F  ${file.basename}: ${warnings.join(", ")}`);
                }
              } else {
              }
            } catch (error) {
              errorCount++;
              console.error(`${file.basename}: \u274C ERROR:`, error);
              results.push(`\u274C ${file.basename}: ${error.message}`);
            }
          }
          results.push(``);
          results.push(`**Summary:**`);
          results.push(``);
          results.push(`- Total files found: ${totalFiles}`);
          results.push(`- Claude artifacts: ${processedCount}`);
          results.push(`- Skipped (non-Claude): ${skippedCount}`);
          results.push(`- Updated: ${updatedCount}`);
          results.push(`- Warnings: ${warningCount}`);
          results.push(`- Errors: ${errorCount}`);
          results.push(``);
          if (skippedCount > 0) {
            results.push(`*Note: ${skippedCount} file(s) were skipped because they are not Claude artifacts.*`);
          }
          return {
            success: errorCount === 0,
            message: `Migrated ${updatedCount} artifact(s) with ${warningCount} warning(s) and ${errorCount} error(s)`,
            details: results
          };
        } catch (error) {
          return {
            success: false,
            message: `Migration failed: ${error.message}`,
            details: results
          };
        }
      }
      /**
       * Extract artifact create_time from conversation note
       */
      async extractArtifactCreateTime(artifactFm, conversationFolder, plugin, artifactFile) {
        var _a, _b, _c;
        const artifactId = artifactFm.artifact_id;
        const versionNumber = artifactFm.version_number;
        const conversationId = artifactFm.conversation_id;
        const artifactRef = `${artifactId}_v${versionNumber}`;
        try {
          if (!conversationId) {
            console.warn(`Artifact ${artifactRef}: No conversation_id in frontmatter`);
            return { value: "", source: "none" };
          }
          const conversationFile = await this.findConversationFile(conversationId, conversationFolder, plugin);
          if (!conversationFile) {
            console.warn(`Artifact ${artifactRef}: Conversation file not found for ID ${conversationId}`);
            return { value: "", source: "none" };
          }
          const content = await plugin.app.vault.read(conversationFile);
          if (!artifactId || !versionNumber) {
            console.warn(`Artifact ${artifactRef}: Missing artifact_id or version_number, using conversation fallback`);
            const fm2 = (_a = plugin.app.metadataCache.getFileCache(conversationFile)) == null ? void 0 : _a.frontmatter;
            if (fm2 == null ? void 0 : fm2.create_time) {
              return { value: fm2.create_time, source: "conversation" };
            }
            return { value: "", source: "none" };
          }
          const artifactLinkPath = artifactFile.path.replace(/\.md$/, "");
          const escapedPath = artifactLinkPath.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const linkPattern = new RegExp(`\\[\\[${escapedPath}\\|View Artifact\\]\\]`, "m");
          const linkMatch = content.match(linkPattern);
          if (!linkMatch || linkMatch.index === void 0) {
            console.warn(`Artifact ${artifactRef}: Artifact link not found in conversation, using conversation fallback`);
            const fm2 = (_b = plugin.app.metadataCache.getFileCache(conversationFile)) == null ? void 0 : _b.frontmatter;
            if (fm2 == null ? void 0 : fm2.create_time) {
              return { value: fm2.create_time, source: "conversation" };
            }
            return { value: "", source: "none" };
          }
          const linkIndex = linkMatch.index;
          const textBeforeLink = content.substring(0, linkIndex);
          const contextStart = Math.max(0, linkIndex - 300);
          const contextText = content.substring(contextStart, linkIndex);
          const agentPattern = />\[!nexus_agent\] \*\*Assistant\*\* - ([^\n]+)/gm;
          let lastMatch = null;
          let match;
          let matchCount = 0;
          while ((match = agentPattern.exec(textBeforeLink)) !== null) {
            matchCount++;
            lastMatch = match;
          }
          if (lastMatch && lastMatch[1]) {
            const timestampStr = lastMatch[1];
            const timestamp = DateParser.parseDate(timestampStr, artifactRef);
            if (timestamp > 0) {
              const isoDate = new Date(timestamp * 1e3).toISOString();
              return {
                value: isoDate,
                source: "message"
              };
            } else {
              console.warn(`Artifact ${artifactRef}: \u274C Timestamp parsing FAILED (returned 0), using conversation fallback`);
              console.warn(`Artifact ${artifactRef}: Failed timestamp string was: "${timestampStr}"`);
            }
          } else {
            console.warn(`Artifact ${artifactRef}: \u274C No agent callout found before artifact link, using conversation fallback`);
            const sampleText = textBeforeLink.substring(Math.max(0, textBeforeLink.length - 500));
            console.warn(`Artifact ${artifactRef}: Last 500 chars of search text:
${sampleText}`);
          }
          const fm = (_c = plugin.app.metadataCache.getFileCache(conversationFile)) == null ? void 0 : _c.frontmatter;
          if (fm == null ? void 0 : fm.create_time) {
            return { value: fm.create_time, source: "conversation" };
          }
          console.warn(`Artifact ${artifactRef}: No create_time available`);
          return { value: "", source: "none" };
        } catch (error) {
          console.error(`Artifact ${artifactRef}: Exception during create_time extraction:`, error);
          return { value: "", source: "none" };
        }
      }
      /**
       * Find conversation file by ID
       */
      async findConversationFile(conversationId, conversationFolder, plugin) {
        var _a;
        const allFiles = plugin.app.vault.getMarkdownFiles();
        const claudePath = `${conversationFolder}/claude`;
        for (const file of allFiles) {
          if (!file.path.startsWith(claudePath))
            continue;
          const fm = (_a = plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((fm == null ? void 0 : fm.conversation_id) === conversationId) {
            return file;
          }
        }
        return null;
      }
      /**
       * Find and generate conversation link
       */
      async findConversationLink(conversationId, conversationFolder, plugin) {
        var _a;
        const conversationFile = await this.findConversationFile(conversationId, conversationFolder, plugin);
        if (!conversationFile) {
          return null;
        }
        const fm = (_a = plugin.app.metadataCache.getFileCache(conversationFile)) == null ? void 0 : _a.frontmatter;
        const title = (fm == null ? void 0 : fm.aliases) || conversationFile.basename;
        const linkPath = conversationFile.path.replace(/\.md$/, "");
        return `[[${linkPath}|${title}]]`;
      }
      async verify(context) {
        var _a;
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus AI Chat Imports/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const artifactFiles = allFiles.filter((file) => file.path.startsWith(claudeArtifactsPath));
          for (const file of artifactFiles) {
            const fm = (_a = context.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
            if ((fm == null ? void 0 : fm.provider) === "claude" && !fm.create_time) {
              return false;
            }
          }
          return true;
        } catch (error) {
          console.error(`MigrateClaudeArtifacts.verify failed:`, error);
          return false;
        }
      }
    };
    __name(MigrateClaudeArtifactsOperation, "MigrateClaudeArtifactsOperation");
    ConfigureFolderLocationsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "configure-folder-locations";
        this.name = "Configure Folder Locations";
        this.description = "Configure separate folder locations for conversations, reports, and attachments. Optionally migrate existing files to new locations.";
        this.type = "automatic";
      }
      async canRun(_context) {
        return true;
      }
      async execute(context) {
        return new Promise((resolve) => {
          const dialog = new ConfigureFolderLocationsDialog(
            context.plugin,
            async (result) => {
              const details = [];
              if (result.reportFolder.changed) {
                details.push(`\u2705 Report folder: ${result.reportFolder.oldPath} \u2192 ${result.reportFolder.newPath}`);
              } else {
                details.push(`\u2139\uFE0F  Report folder: ${result.reportFolder.newPath} (unchanged)`);
              }
              resolve({
                success: true,
                message: "Report folder location configured successfully",
                details
              });
            }
          );
          dialog.open();
        });
      }
    };
    __name(ConfigureFolderLocationsOperation, "ConfigureFolderLocationsOperation");
    Upgrade130 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.3.0";
        this.automaticOperations = [
          new MigrateToSeparateFoldersOperation(),
          new ConvertToISO8601TimestampsOperation(),
          new FixFrontmatterAliasesOperation(),
          new MigrateClaudeArtifactsOperation(),
          new ConfigureFolderLocationsOperation()
        ];
        this.manualOperations = [
          // No manual operations for this version
        ];
      }
    };
    __name(Upgrade130, "Upgrade130");
  }
});

// src/upgrade/versions/upgrade-1.4.0.ts
var upgrade_1_4_0_exports = {};
__export(upgrade_1_4_0_exports, {
  Upgrade140: () => Upgrade140
});
function updatePluginVersion(content, version) {
  if (content.includes("plugin_version:")) {
    return content.replace(
      /^plugin_version: .*$/m,
      `plugin_version: "${version}"`
    );
  }
  return content.replace(
    /\n---\n/,
    `
plugin_version: "${version}"
---
`
  );
}
var import_obsidian22, UUID_REGEX, TARGET_VERSION, RenameClaudeArtifactFoldersOperation, RestoreMissingArtifactCalloutsOperation, FixCalloutEmptyLinesOperation, Upgrade140;
var init_upgrade_1_4_0 = __esm({
  "src/upgrade/versions/upgrade-1.4.0.ts"() {
    "use strict";
    init_upgrade_interface();
    import_obsidian22 = require("obsidian");
    init_storage_service();
    init_link_update_service();
    UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    TARGET_VERSION = "1.4.0";
    __name(updatePluginVersion, "updatePluginVersion");
    RenameClaudeArtifactFoldersOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "rename-claude-artifact-folders";
        this.name = "Rename Claude Artifact Folders";
        this.description = "Renames Claude artifact folders from UUID to human-readable names matching the conversation file.";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const folder = context.plugin.app.vault.getAbstractFileByPath(claudeArtifactsPath);
          if (!folder || !(folder instanceof import_obsidian22.TFolder)) {
            return false;
          }
          for (const child of folder.children) {
            if (child instanceof import_obsidian22.TFolder && UUID_REGEX.test(child.name)) {
              return true;
            }
          }
          return false;
        } catch (error) {
          console.error(`[RenameClaudeArtifactFolders] canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        var _a, _b, _c, _d, _e, _f, _g;
        let renamedCount = 0;
        let skippedCount = 0;
        let errorCount = 0;
        const details = [];
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const artifactsFolder = context.plugin.app.vault.getAbstractFileByPath(claudeArtifactsPath);
          if (!artifactsFolder || !(artifactsFolder instanceof import_obsidian22.TFolder)) {
            return {
              success: true,
              message: "No Claude artifacts folder found, nothing to migrate."
            };
          }
          const uuidFolders = [];
          for (const child of artifactsFolder.children) {
            if (child instanceof import_obsidian22.TFolder && UUID_REGEX.test(child.name)) {
              uuidFolders.push(child);
            }
          }
          if (uuidFolders.length === 0) {
            return {
              success: true,
              message: "No UUID-named artifact folders found."
            };
          }
          (_a = context.onProgress) == null ? void 0 : _a.call(context, 0, "Scanning conversation catalog...");
          const storageService = new StorageService(context.plugin);
          const conversationMap = await storageService.scanExistingConversations();
          const total = uuidFolders.length;
          const pathMappings = [];
          for (let i = 0; i < uuidFolders.length; i++) {
            const folder = uuidFolders[i];
            const conversationId = folder.name;
            const progress = Math.round((i + 1) / total * 80);
            try {
              const entry = conversationMap.get(conversationId) || null;
              if (!entry || !entry.path) {
                skippedCount++;
                details.push(`Skipped: ${conversationId} (conversation not found in vault)`);
                (_b = context.onProgress) == null ? void 0 : _b.call(context, progress, `Skipped ${i + 1}/${total}`);
                continue;
              }
              const pathParts = entry.path.split("/");
              const fileNameWithExt = pathParts[pathParts.length - 1];
              const conversationFileName = fileNameWithExt.replace(/\.md$/, "");
              if (!conversationFileName) {
                skippedCount++;
                details.push(`Skipped: ${conversationId} (could not determine file name)`);
                (_c = context.onProgress) == null ? void 0 : _c.call(context, progress, `Skipped ${i + 1}/${total}`);
                continue;
              }
              const newFolderPath = `${claudeArtifactsPath}/${conversationFileName}`;
              const existingTarget = context.plugin.app.vault.getAbstractFileByPath(newFolderPath);
              if (existingTarget) {
                skippedCount++;
                details.push(`Skipped: ${conversationId} \u2192 "${conversationFileName}" (target folder already exists)`);
                (_d = context.onProgress) == null ? void 0 : _d.call(context, progress, `Skipped ${i + 1}/${total}`);
                continue;
              }
              const oldFolderPath = folder.path;
              (_e = context.onProgress) == null ? void 0 : _e.call(context, progress, `Renaming ${i + 1}/${total}: ${conversationFileName}`);
              await context.plugin.app.vault.rename(folder, newFolderPath);
              pathMappings.push({ oldPath: oldFolderPath, newPath: newFolderPath });
              renamedCount++;
              details.push(`Renamed: ${conversationId} \u2192 "${conversationFileName}"`);
            } catch (error) {
              errorCount++;
              const errorMsg = error instanceof Error ? error.message : String(error);
              details.push(`Error: ${conversationId} \u2014 ${errorMsg}`);
              (_f = context.onProgress) == null ? void 0 : _f.call(context, progress, `Error ${i + 1}/${total}`);
            }
          }
          if (pathMappings.length > 0) {
            (_g = context.onProgress) == null ? void 0 : _g.call(context, 80, "Verifying wikilinks...");
            const linkUpdateService = new LinkUpdateService(context.plugin);
            const linkStats = await linkUpdateService.updateAttachmentLinksBatch(pathMappings, (progress) => {
              var _a2;
              const overallProgress = 80 + Math.round(progress.current / Math.max(progress.total, 1) * 20);
              (_a2 = context.onProgress) == null ? void 0 : _a2.call(context, overallProgress, progress.detail);
            }, TARGET_VERSION);
            if (linkStats.filesModified > 0) {
              details.push(`Fixed ${linkStats.attachmentLinksUpdated} stale link(s) in ${linkStats.filesModified} file(s)`);
            }
          }
          const summary = `Renamed ${renamedCount} folder(s), skipped ${skippedCount}, errors ${errorCount}.`;
          return {
            success: errorCount === 0,
            message: summary,
            details
          };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          return {
            success: false,
            message: `Migration failed: ${errorMsg}`,
            details
          };
        }
      }
    };
    __name(RenameClaudeArtifactFoldersOperation, "RenameClaudeArtifactFoldersOperation");
    RestoreMissingArtifactCalloutsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "restore-missing-artifact-callouts";
        this.name = "Restore Missing Artifact Callouts";
        this.description = "Restores artifact links in Claude conversation notes affected by Anthropic's export format change.";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const folder = context.plugin.app.vault.getAbstractFileByPath(claudeArtifactsPath);
          return !!(folder && folder instanceof import_obsidian22.TFolder && folder.children.length > 0);
        } catch (e) {
          return false;
        }
      }
      async execute(context) {
        var _a, _b, _c;
        let restoredCount = 0;
        let skippedCount = 0;
        let errorCount = 0;
        const details = [];
        try {
          const attachmentFolder = context.plugin.settings.attachmentFolder || "Nexus/Attachments";
          const claudeArtifactsPath = `${attachmentFolder}/claude/artifacts`;
          const artifactsRoot = context.plugin.app.vault.getAbstractFileByPath(claudeArtifactsPath);
          if (!artifactsRoot || !(artifactsRoot instanceof import_obsidian22.TFolder)) {
            return { success: true, message: "No Claude artifacts folder found." };
          }
          const artifactFolders = [];
          for (const child of artifactsRoot.children) {
            if (child instanceof import_obsidian22.TFolder) {
              artifactFolders.push(child);
            }
          }
          if (artifactFolders.length === 0) {
            return { success: true, message: "No artifact folders found." };
          }
          (_a = context.onProgress) == null ? void 0 : _a.call(context, 0, "Scanning conversation catalog...");
          const storageService = new StorageService(context.plugin);
          const conversationMap = await storageService.scanExistingConversations();
          const total = artifactFolders.length;
          for (let i = 0; i < artifactFolders.length; i++) {
            const folder = artifactFolders[i];
            const progress = Math.round((i + 1) / total * 100);
            if (i % 10 === 0 || i === total - 1) {
              (_b = context.onProgress) == null ? void 0 : _b.call(context, progress, `Checking ${i + 1}/${total}: ${folder.name}`);
            }
            try {
              const artifactFiles = folder.children.filter(
                (f) => f instanceof import_obsidian22.TFile && f.extension === "md"
              );
              if (artifactFiles.length === 0) {
                continue;
              }
              const sampleContent = await context.plugin.app.vault.read(artifactFiles[0]);
              const conversationId = this.extractFrontmatterField(sampleContent, "conversation_id");
              if (!conversationId) {
                skippedCount++;
                details.push(`Skipped: ${folder.name} (no conversation_id in artifact)`);
                continue;
              }
              const entry = conversationMap.get(conversationId);
              if (!entry || !entry.path) {
                skippedCount++;
                details.push(`Skipped: ${folder.name} (conversation not found in vault)`);
                continue;
              }
              const noteFile = context.plugin.app.vault.getAbstractFileByPath(entry.path);
              if (!noteFile || !(noteFile instanceof import_obsidian22.TFile)) {
                skippedCount++;
                continue;
              }
              const noteContent = await context.plugin.app.vault.read(noteFile);
              if (noteContent.includes("nexus_artifact")) {
                skippedCount++;
                continue;
              }
              const artifactEntries = [];
              for (const artFile of artifactFiles) {
                const artContent = await context.plugin.app.vault.read(artFile);
                const artifactId = this.extractFrontmatterField(artContent, "artifact_id") || "unknown";
                const versionStr = this.extractFrontmatterField(artContent, "version_number");
                const versionNumber = versionStr ? parseInt(versionStr, 10) : 1;
                const title = this.extractArtifactTitle(artContent, artifactId);
                const filePath = artFile.path.replace(/\.md$/, "");
                artifactEntries.push({ artifactId, versionNumber, title, filePath });
              }
              artifactEntries.sort((a, b) => {
                const idCmp = a.artifactId.localeCompare(b.artifactId);
                return idCmp !== 0 ? idCmp : a.versionNumber - b.versionNumber;
              });
              const nestedCalloutLines = artifactEntries.map(
                (art) => `>>[!nexus_artifact] **${art.title}** v${art.versionNumber}
>> \u{1F3A8} [[${art.filePath}|View Artifact]]`
              );
              const section = [
                "",
                "> [!info] Restored Artifacts",
                "> Due to a change in Anthropic's Claude export format, artifact references were not included when this conversation was originally imported. The artifacts below have been restored during the v1.4.0 migration.",
                "> To get artifacts positioned inline within messages, delete this note and re-import from your Claude export ZIP.",
                ">",
                nestedCalloutLines.join("\n>\n")
              ].join("\n");
              let updatedContent = noteContent + section + "\n";
              updatedContent = updatePluginVersion(updatedContent, TARGET_VERSION);
              await context.plugin.app.vault.modify(noteFile, updatedContent);
              restoredCount++;
              details.push(`Restored ${artifactEntries.length} artifact(s): ${entry.path}`);
              (_c = context.onProgress) == null ? void 0 : _c.call(context, progress, `Restored: ${noteFile.name}`);
            } catch (error) {
              errorCount++;
              const errorMsg = error instanceof Error ? error.message : String(error);
              details.push(`Error: ${folder.name} \u2014 ${errorMsg}`);
            }
          }
          const summary = `Restored artifacts in ${restoredCount} note(s), skipped ${skippedCount}, errors ${errorCount}.`;
          return {
            success: errorCount === 0,
            message: summary,
            details
          };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          return {
            success: false,
            message: `Migration failed: ${errorMsg}`,
            details
          };
        }
      }
      extractFrontmatterField(content, field) {
        const match = content.match(new RegExp(`^${field}:\\s*"?([^"\\n]+)"?`, "m"));
        return match ? match[1].trim() : null;
      }
      extractArtifactTitle(content, fallbackId) {
        const aliasMatch = content.match(/^aliases:\s*\[([^\]]+)\]/m);
        if (aliasMatch) {
          const firstAlias = aliasMatch[1].split(",")[0].trim();
          const cleaned = firstAlias.replace(/^["']|["']$/g, "");
          if (cleaned && cleaned !== "Untitled Artifact") {
            return cleaned;
          }
        }
        return fallbackId;
      }
    };
    __name(RestoreMissingArtifactCalloutsOperation, "RestoreMissingArtifactCalloutsOperation");
    FixCalloutEmptyLinesOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "fix-callout-empty-lines";
        this.name = "Fix Callout Empty Lines";
        this.description = "Fixes nested callout rendering in conversation notes created by previous versions.";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || "Nexus/Conversations";
          const folder = context.plugin.app.vault.getAbstractFileByPath(conversationFolder);
          return !!(folder && folder instanceof import_obsidian22.TFolder);
        } catch (e) {
          return false;
        }
      }
      async execute(context) {
        var _a, _b;
        let fixedCount = 0;
        let scannedCount = 0;
        let errorCount = 0;
        const details = [];
        try {
          const conversationFolder = context.plugin.settings.conversationFolder || "Nexus/Conversations";
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((f) => f.path.startsWith(conversationFolder));
          const brokenPattern = /^>>$/gm;
          const total = conversationFiles.length;
          for (let i = 0; i < conversationFiles.length; i++) {
            const file = conversationFiles[i];
            scannedCount++;
            const progress = Math.round((i + 1) / total * 100);
            if (i % 10 === 0 || i === total - 1) {
              (_a = context.onProgress) == null ? void 0 : _a.call(context, progress, `Scanning ${i + 1}/${total}: ${file.name}`);
            }
            try {
              const content = await context.plugin.app.vault.read(file);
              if (!brokenPattern.test(content)) {
                continue;
              }
              brokenPattern.lastIndex = 0;
              let fixed = content.replace(/^>>(\n>>\[!nexus_)/gm, ">$1");
              if (fixed !== content) {
                fixed = updatePluginVersion(fixed, TARGET_VERSION);
                await context.plugin.app.vault.modify(file, fixed);
                fixedCount++;
                details.push(`Fixed: ${file.path}`);
                (_b = context.onProgress) == null ? void 0 : _b.call(context, progress, `Fixed: ${file.name}`);
              }
            } catch (error) {
              errorCount++;
              const errorMsg = error instanceof Error ? error.message : String(error);
              details.push(`Error: ${file.path} \u2014 ${errorMsg}`);
            }
          }
          const summary = `Scanned ${scannedCount} file(s), fixed ${fixedCount}, errors ${errorCount}.`;
          return {
            success: errorCount === 0,
            message: summary,
            details
          };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          return {
            success: false,
            message: `Migration failed: ${errorMsg}`,
            details
          };
        }
      }
    };
    __name(FixCalloutEmptyLinesOperation, "FixCalloutEmptyLinesOperation");
    Upgrade140 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.4.0";
        this.automaticOperations = [
          new RenameClaudeArtifactFoldersOperation(),
          new RestoreMissingArtifactCalloutsOperation(),
          new FixCalloutEmptyLinesOperation()
        ];
        this.manualOperations = [
          // No manual operations for this version
        ];
      }
    };
    __name(Upgrade140, "Upgrade140");
  }
});

// src/dialogs/upgrade-complete-modal.ts
var upgrade_complete_modal_exports = {};
__export(upgrade_complete_modal_exports, {
  UpgradeCompleteModal: () => UpgradeCompleteModal
});
var import_obsidian23, UpgradeCompleteModal;
var init_upgrade_complete_modal = __esm({
  "src/dialogs/upgrade-complete-modal.ts"() {
    "use strict";
    import_obsidian23 = require("obsidian");
    init_support_box();
    init_i18n();
    UpgradeCompleteModal = class extends import_obsidian23.Modal {
      constructor(app, plugin, version) {
        super(app);
        this.plugin = plugin;
        this.version = version;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        modalEl.classList.add("nexus-upgrade-complete-modal");
        contentEl.classList.add("nexus-ai-chat-importer-modal");
        titleEl.setText(t("upgrade.complete_modal.title", { version: this.version }));
        this.createContent();
      }
      onClose() {
        this.contentEl.empty();
      }
      async createContent() {
        const { contentEl } = this;
        createSupportBox(contentEl);
        await this.addReleaseNotes();
        this.addCloseButton();
        this.addStyles();
      }
      async addReleaseNotes() {
        let content = `## \u2728 What's New in v1.5.5

**New ChatGPT export format** \u2014 OpenAI split conversations across multiple numbered files
(\`conversations-XXX.json\`). Imports were silently failing. This version adds full support
for the new format. Older exports remain unaffected.

**Memory-safe ZIP loading** \u2014 Export archives are no longer loaded entirely into memory,
reducing the risk of RAM saturation on very large exports.

---

## v1.5.0 \u2014 UI Localization

### \u{1F30D} Full UI Localization \u2014 10 Languages

- **Automatic language detection** \u2014 the plugin UI matches your Obsidian interface language, no configuration needed
- **10 supported languages**: English, French, German, Spanish, Italian, Russian, Chinese (Simplified), Japanese, Portuguese, Korean
- **Complete coverage** \u2014 all dialogs, settings panels, progress modals, notices, and status labels are translated
- **English fallback** \u2014 any missing key falls back to English automatically

> Import reports and conversation notes remain in English \u2014 only the plugin UI is localized.

## v1.4.0 in brief

- **\u{1F916} Le Chat (Mistral AI)** \u2014 Full support with attachments, references, and citations
- **\u{1F4BB} CLI for Bulk Import** \u2014 Import from the terminal without opening Obsidian
- **\u{1F4C1} Human-readable artifact folders** \u2014 Claude artifacts stored in folders named after the conversation, not UUIDs
- **\u{1F4D0} LaTeX math** \u2014 Math equations converted to Obsidian \`$$...$$\` / \`$...$\` syntax
- **\u{1F41B} Bug fixes** \u2014 Multi-attachment callouts, Claude format changes, mobile placeholders, binary artifacts`;
        try {
          const response = await fetch(`https://raw.githubusercontent.com/Superkikim/nexus-ai-chat-importer/${this.version}/README.md`);
          if (response.ok) {
            const readme = await response.text();
            const overviewMatch = readme.match(/## Overview\s+([\s\S]*?)(?=\n## |\n# |$)/);
            if (overviewMatch && overviewMatch[1]) {
              content = overviewMatch[1].trim();
            }
          }
        } catch (error) {
        }
        const contentDiv = this.contentEl.createDiv({ cls: "nexus-upgrade-notes" });
        await import_obsidian23.MarkdownRenderer.render(
          this.app,
          content,
          contentDiv,
          "",
          this.plugin
        );
      }
      addCloseButton() {
        const buttonContainer = this.contentEl.createDiv({ cls: "nexus-upgrade-button-container" });
        const button = buttonContainer.createEl("button", {
          text: t("upgrade.complete_modal.buttons.got_it"),
          cls: "mod-cta nexus-upgrade-button"
        });
        button.addEventListener("click", () => {
          this.close();
        });
      }
      addStyles() {
        const style = document.createElement("style");
        style.textContent = `
            /* Modal sizing */
            .nexus-upgrade-complete-modal .modal {
                max-height: 85vh;
            }

            .nexus-upgrade-complete-modal .modal-content {
                padding: 20px 24px;
                overflow-y: auto;
                max-height: calc(85vh - 100px);
            }

            /* Release notes content */
            .nexus-upgrade-notes {
                padding: 0 1em;
                margin-bottom: 2em;
            }

            .nexus-upgrade-notes h2 {
                color: var(--text-accent);
                margin-top: 1.5em;
                margin-bottom: 0.8em;
                border-bottom: 2px solid var(--background-modifier-border);
                padding-bottom: 0.3em;
            }

            .nexus-upgrade-notes h2:first-child {
                margin-top: 0;
            }

            .nexus-upgrade-notes ul {
                margin-left: 1.5em;
                line-height: 1.8;
            }

            .nexus-upgrade-notes li {
                margin: 0.5em 0;
            }

            /* Close button */
            .nexus-upgrade-button-container {
                text-align: center;
                padding: 1.5em 0;
                border-top: 1px solid var(--background-modifier-border);
                margin-top: 1em;
            }

            .nexus-upgrade-button {
                padding: 0.8em 3em;
                font-size: 1.1em;
                font-weight: 600;
                border-radius: 8px;
            }
        `;
        document.head.appendChild(style);
      }
    };
    __name(UpgradeCompleteModal, "UpgradeCompleteModal");
  }
});

// src/dialogs/upgrade-modal-1.3.0.ts
var upgrade_modal_1_3_0_exports = {};
__export(upgrade_modal_1_3_0_exports, {
  NexusUpgradeModal130: () => NexusUpgradeModal130
});
var import_obsidian24, NexusUpgradeModal130;
var init_upgrade_modal_1_3_0 = __esm({
  "src/dialogs/upgrade-modal-1.3.0.ts"() {
    "use strict";
    import_obsidian24 = require("obsidian");
    init_support_box();
    init_i18n();
    NexusUpgradeModal130 = class extends import_obsidian24.Modal {
      constructor(app, plugin, version, resolve) {
        super(app);
        this.hasResolved = false;
        this.plugin = plugin;
        this.version = version;
        this.resolve = resolve;
      }
      onOpen() {
        var _a;
        const { containerEl, titleEl, modalEl } = this;
        modalEl.classList.add("nexus-upgrade-modal-130");
        titleEl.setText(t("upgrade.modal_130.title", { version: this.version }));
        (_a = this.modalEl.querySelector(".modal-close-button")) == null ? void 0 : _a.remove();
        this.createForm();
      }
      onClose() {
        if (!this.hasResolved) {
          this.resolve("cancel");
        }
        this.contentEl.empty();
      }
      async createForm() {
        createSupportBox(this.contentEl);
        this.addMigrationSection();
        this.addMigrationButton();
        let message = `## \u2728 What's New in v1.3.0

- **\u{1F3AF} Selective Conversation Import**: Interactive dialog to choose which conversations to import
- **\u{1F4CA} Enhanced Reports**: Per-file statistics with detailed breakdown
- **\u{1F5C2}\uFE0F Flexible Folders**: Separate settings for conversations, attachments, and reports
- **\u{1F30D} International Support**: ISO 8601 timestamps work with all locales
- **\u{1F41B} 26 Bug Fixes**: Improved stability and reliability

---

### \u{1F4A1} Tip

Try the new **selective import** feature on your next import - you'll love the control it gives you!`;
        try {
          const response = await fetch("https://api.github.com/repos/Superkikim/nexus-ai-chat-importer/releases/tags/v1.3.0");
          if (response.ok) {
            const release = await response.json();
            if (release.body) {
              message = release.body;
            }
          }
        } catch (error) {
        }
        const contentDiv = this.contentEl.createDiv({ cls: "nexus-upgrade-content" });
        await import_obsidian24.MarkdownRenderer.render(
          this.app,
          message,
          contentDiv,
          "",
          this.plugin
        );
        this.addStyles();
      }
      addMigrationSection() {
        const migrationSection = this.contentEl.createDiv({ cls: "nexus-migration-section" });
        const header = migrationSection.createDiv({ cls: "nexus-migration-header" });
        header.innerHTML = `
            <div class="nexus-migration-title">
                ${t("upgrade.modal_130.migration_section.title")}
            </div>
        `;
        const message = migrationSection.createDiv({ cls: "nexus-migration-message" });
        message.innerHTML = `
            <p>${t("upgrade.modal_130.migration_section.message")}</p>
        `;
        const taskList = migrationSection.createDiv({ cls: "nexus-migration-tasks" });
        taskList.innerHTML = `
            <ul>
                <li>${t("upgrade.modal_130.migration_section.tasks.folder_settings")}</li>
                <li>${t("upgrade.modal_130.migration_section.tasks.timestamps")}</li>
                <li>${t("upgrade.modal_130.migration_section.tasks.aliases")}</li>
                <li>${t("upgrade.modal_130.migration_section.tasks.reports")}</li>
                <li>${t("upgrade.modal_130.migration_section.tasks.artifacts")}</li>
            </ul>
        `;
        const estimate = migrationSection.createDiv({ cls: "nexus-migration-estimate" });
        estimate.innerHTML = `
            <p><em>${t("upgrade.modal_130.migration_section.estimate")}</em></p>
        `;
      }
      addMigrationButton() {
        const buttonContainer = this.contentEl.createDiv({ cls: "nexus-migration-button-container" });
        const migrationButton = buttonContainer.createEl("button", {
          text: t("upgrade.modal_130.buttons.run_migration"),
          cls: "mod-cta nexus-migration-button"
        });
        migrationButton.onclick = () => {
          this.hasResolved = true;
          this.resolve("ok");
          this.close();
        };
      }
      addStyles() {
        const styleEl = document.createElement("style");
        styleEl.textContent = `
            .modal.nexus-upgrade-modal-130 {
                max-width: 1050px !important;
                width: 1050px !important;
            }

            .nexus-upgrade-content {
                margin-bottom: 20px;
                line-height: 1.6;
            }

            /* Migration Section Styles */
            .nexus-migration-section {
                background: var(--background-secondary);
                border: 2px solid var(--interactive-accent);
                border-radius: 12px;
                padding: 24px;
                margin: 24px 0;
            }

            .nexus-migration-header {
                margin-bottom: 16px;
            }

            .nexus-migration-title {
                font-size: 1.3em;
                text-align: center;
                color: var(--text-normal);
            }

            .nexus-migration-title strong {
                color: var(--interactive-accent);
            }

            .nexus-migration-message {
                text-align: center;
                margin-bottom: 16px;
                color: var(--text-muted);
            }

            .nexus-migration-tasks {
                margin: 16px 0;
            }

            .nexus-migration-tasks ul {
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .nexus-migration-tasks li {
                padding: 8px 0;
                font-size: 0.95em;
                color: var(--text-normal);
            }

            .nexus-migration-estimate {
                text-align: center;
                margin-top: 16px;
                color: var(--text-muted);
                font-size: 0.9em;
            }

            /* Migration Button Styles */
            .nexus-migration-button-container {
                text-align: center;
                margin: 32px 0;
            }

            .nexus-migration-button {
                padding: 16px 48px !important;
                font-size: 1.2em !important;
                font-weight: 700 !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
                transition: all 0.2s ease !important;
            }

            .nexus-migration-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2) !important;
            }
        `;
        document.head.appendChild(styleEl);
      }
    };
    __name(NexusUpgradeModal130, "NexusUpgradeModal130");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NexusAiChatImporterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian32 = require("obsidian");
init_i18n();
init_constants();

// src/ui/settings-tab.ts
var import_obsidian11 = require("obsidian");

// src/ui/settings/support-section.ts
var import_obsidian = require("obsidian");

// src/ui/settings/base-settings-section.ts
var BaseSettingsSection = class {
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Section order (lower = higher up)
     */
    this.order = 100;
  }
  /**
   * Set redraw callback from main settings tab
   */
  setRedrawCallback(callback) {
    this.redrawCallback = callback;
  }
  /**
   * Trigger redraw of entire settings tab
   */
  redraw() {
    if (this.redrawCallback) {
      this.redrawCallback();
    }
  }
};
__name(BaseSettingsSection, "BaseSettingsSection");

// src/ui/settings/support-section.ts
init_support_box();
init_i18n();
var SupportSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.order = 5;
  }
  get title() {
    return t("settings.support.section_title");
  }
  render(containerEl) {
    const supportContainer = containerEl.createDiv({ cls: "nexus-support-section" });
    createSupportBox(supportContainer);
    new import_obsidian.Setting(supportContainer).setName(t("settings.support.resources.name")).setDesc(t("settings.support.resources.desc")).addButton(
      (button) => button.setButtonText(t("settings.support.resources.documentation")).onClick(() => {
        const locale = window.moment.locale();
        const supported = ["fr", "de", "es", "it", "ru", "zh", "ja", "pt", "ko"];
        const docUrl = supported.includes(locale) ? `https://nexus-prod.dev/${locale}/nexus-ai-chat-importer` : "https://nexus-prod.dev/nexus-ai-chat-importer";
        window.open(docUrl, "_blank");
      })
    ).addButton(
      (button) => button.setButtonText(t("settings.support.resources.release_notes")).onClick(() => {
        window.open("https://github.com/Superkikim/nexus-ai-chat-importer/blob/master/RELEASE_NOTES.md", "_blank");
      })
    ).addButton(
      (button) => button.setButtonText(t("settings.support.resources.issues")).onClick(() => {
        window.open("https://github.com/superkikim/nexus-ai-chat-importer/issues", "_blank");
      })
    ).addButton(
      (button) => button.setButtonText(t("settings.support.resources.forum")).onClick(() => {
        window.open("https://forum.obsidian.md/t/plugin-nexus-ai-chat-importer-import-chatgpt-and-claude-conversations-to-your-vault/71664", "_blank");
      })
    );
  }
};
__name(SupportSection, "SupportSection");

// src/ui/settings/folder-settings-section.ts
var import_obsidian8 = require("obsidian");

// src/dialogs/folder-migration-dialog.ts
var import_obsidian2 = require("obsidian");
init_i18n();
var FolderMigrationDialog = class extends import_obsidian2.Modal {
  constructor(plugin, oldPath, newPath, folderType, onComplete) {
    super(plugin.app);
    this.oldPath = oldPath;
    this.newPath = newPath;
    this.folderType = folderType;
    this.onComplete = onComplete;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: t("folder_migration.title"),
      cls: "nexus-migration-title"
    });
    const messageContainer = contentEl.createDiv({ cls: "nexus-migration-message" });
    messageContainer.createEl("p", {
      text: t("folder_migration.message_intro", { folder_type: this.folderType })
    });
    const pathContainer = messageContainer.createDiv({ cls: "nexus-migration-paths" });
    pathContainer.createEl("div", {
      text: t("folder_migration.path_from", { path: this.oldPath }),
      cls: "nexus-migration-path-old"
    });
    pathContainer.createEl("div", {
      text: t("folder_migration.path_to", { path: this.newPath }),
      cls: "nexus-migration-path-new"
    });
    messageContainer.createEl("p", {
      text: t("folder_migration.question")
    });
    const warningBox = contentEl.createDiv({ cls: "nexus-migration-warning" });
    warningBox.createEl("strong", { text: t("folder_migration.warning.title") });
    warningBox.createEl("p", {
      text: t("folder_migration.warning.text")
    });
    const buttonContainer = contentEl.createDiv({ cls: "nexus-migration-buttons" });
    const cancelButton = buttonContainer.createEl("button", {
      text: t("folder_migration.buttons.cancel"),
      cls: "nexus-migration-button-cancel"
    });
    cancelButton.addEventListener("click", async () => {
      this.close();
      try {
        await this.onComplete("cancel");
        new import_obsidian2.Notice(`Change cancelled. Folder setting reverted.`);
      } catch (error) {
        new import_obsidian2.Notice(`Failed to revert setting: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    const keepButton = buttonContainer.createEl("button", {
      text: t("folder_migration.buttons.keep"),
      cls: "nexus-migration-button-keep"
    });
    keepButton.addEventListener("click", async () => {
      this.close();
      try {
        await this.onComplete("keep");
        new import_obsidian2.Notice(`Folder setting updated. Files remain in ${this.oldPath}`);
      } catch (error) {
        new import_obsidian2.Notice(`Failed to update setting: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    const moveButton = buttonContainer.createEl("button", {
      text: t("folder_migration.buttons.move"),
      cls: "mod-cta nexus-migration-button-move"
    });
    moveButton.addEventListener("click", async () => {
      this.close();
      try {
        await this.onComplete("move");
        new import_obsidian2.Notice(`Files moved to ${this.newPath}`);
      } catch (error) {
        new import_obsidian2.Notice(`Failed to move files: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    this.addStyles();
  }
  addStyles() {
    const styleEl = document.createElement("style");
    styleEl.textContent = `
            .nexus-migration-title {
                margin-bottom: 1em;
                color: var(--text-normal);
            }

            .nexus-migration-message {
                margin-bottom: 1.5em;
                line-height: 1.6;
            }

            .nexus-migration-paths {
                background-color: var(--background-secondary);
                padding: 1em;
                margin: 1em 0;
                border-radius: 4px;
                font-family: var(--font-monospace);
                font-size: 0.9em;
            }

            .nexus-migration-path-old {
                color: var(--text-muted);
                margin-bottom: 0.5em;
            }

            .nexus-migration-path-new {
                color: var(--interactive-accent);
                font-weight: 500;
            }

            .nexus-migration-warning {
                background-color: var(--background-modifier-error-hover);
                border-left: 4px solid var(--text-error);
                padding: 1em;
                margin-bottom: 1.5em;
                border-radius: 4px;
            }

            .nexus-migration-warning strong {
                display: block;
                margin-bottom: 0.5em;
                color: var(--text-error);
            }

            .nexus-migration-warning p {
                margin: 0;
                color: var(--text-normal);
            }

            .nexus-migration-buttons {
                display: flex;
                justify-content: space-between;
                gap: 10px;
            }

            .nexus-migration-buttons button {
                padding: 8px 16px;
                flex: 1;
            }

            .nexus-migration-button-cancel {
                background-color: var(--background-modifier-border);
                color: var(--text-muted);
            }

            .nexus-migration-button-keep {
                background-color: var(--background-modifier-border);
            }

            .nexus-migration-button-move {
                /* Uses mod-cta class for primary styling */
            }
        `;
    document.head.appendChild(styleEl);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(FolderMigrationDialog, "FolderMigrationDialog");

// src/ui/settings/folder-settings-section.ts
init_folder_tree_browser_modal();
init_folder_validation();
init_utils();
init_i18n();
var FolderSettingsSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.order = 10;
  }
  get title() {
    return t("settings.folders.section_title");
  }
  render(containerEl) {
    let conversationFolderTextComponent;
    new import_obsidian8.Setting(containerEl).setName(t("settings.folders.conversation_folder.name")).setDesc(t("settings.folders.conversation_folder.desc")).addText((text) => {
      conversationFolderTextComponent = text;
      text.setPlaceholder(t("settings.folders.conversation_folder.placeholder")).setValue(this.plugin.settings.conversationFolder);
      text.inputEl.addClass("nexus-folder-path-input");
      text.inputEl.addClass("nexus-conversation-folder-input");
      text.inputEl.readOnly = true;
      text.inputEl.style.cursor = "default";
    }).addButton((button) => {
      button.setButtonText(t("common.buttons.browse")).setTooltip(t("settings.folders.conversation_folder.browse_tooltip")).onClick(async () => {
        const modal = new FolderTreeBrowserModal(
          this.plugin.app,
          async (path) => {
            if (conversationFolderTextComponent) {
              conversationFolderTextComponent.setValue(path);
              await this.handleFolderChange("conversationFolder", path, "conversations", conversationFolderTextComponent);
            }
          },
          this.plugin.settings.conversationFolder,
          (path) => validateFolderNesting(
            "conversationFolder",
            path,
            this.plugin.settings.conversationFolder,
            this.plugin.settings.reportFolder,
            this.plugin.settings.attachmentFolder
          )
        );
        modal.open();
      });
    });
    let reportFolderTextComponent;
    new import_obsidian8.Setting(containerEl).setName(t("settings.folders.reports_folder.name")).setDesc(t("settings.folders.reports_folder.desc")).addText((text) => {
      reportFolderTextComponent = text;
      text.setPlaceholder(t("settings.folders.reports_folder.placeholder")).setValue(this.plugin.settings.reportFolder);
      text.inputEl.addClass("nexus-folder-path-input");
      text.inputEl.addClass("nexus-report-folder-input");
      text.inputEl.readOnly = true;
      text.inputEl.style.cursor = "default";
    }).addButton((button) => {
      button.setButtonText(t("common.buttons.browse")).setTooltip(t("settings.folders.reports_folder.browse_tooltip")).onClick(async () => {
        const modal = new FolderTreeBrowserModal(
          this.plugin.app,
          async (path) => {
            if (reportFolderTextComponent) {
              reportFolderTextComponent.setValue(path);
              await this.handleFolderChange("reportFolder", path, "reports", reportFolderTextComponent);
            }
          },
          this.plugin.settings.reportFolder,
          (path) => validateFolderNesting(
            "reportFolder",
            path,
            this.plugin.settings.conversationFolder,
            this.plugin.settings.reportFolder,
            this.plugin.settings.attachmentFolder
          )
        );
        modal.open();
      });
    });
    let attachmentFolderTextComponent;
    new import_obsidian8.Setting(containerEl).setName(t("settings.folders.attachment_folder.name")).setDesc(t("settings.folders.attachment_folder.desc")).addText((text) => {
      attachmentFolderTextComponent = text;
      text.setPlaceholder(t("settings.folders.attachment_folder.placeholder")).setValue(this.plugin.settings.attachmentFolder);
      text.inputEl.addClass("nexus-folder-path-input");
      text.inputEl.addClass("nexus-attachment-folder-input");
      text.inputEl.readOnly = true;
      text.inputEl.style.cursor = "default";
    }).addButton((button) => {
      button.setButtonText(t("common.buttons.browse")).setTooltip(t("settings.folders.attachment_folder.browse_tooltip")).onClick(async () => {
        const modal = new FolderTreeBrowserModal(
          this.plugin.app,
          async (path) => {
            if (attachmentFolderTextComponent) {
              attachmentFolderTextComponent.setValue(path);
              await this.handleFolderChange("attachmentFolder", path, "attachments", attachmentFolderTextComponent);
            }
          },
          this.plugin.settings.attachmentFolder,
          (path) => validateFolderNesting(
            "attachmentFolder",
            path,
            this.plugin.settings.conversationFolder,
            this.plugin.settings.reportFolder,
            this.plugin.settings.attachmentFolder
          )
        );
        modal.open();
      });
    });
  }
  async handleFolderChange(settingKey, newPath, folderType, textComponent) {
    var _a;
    const oldPath = this.plugin.settings[settingKey];
    if (oldPath === newPath) {
      return;
    }
    const validation = validateFolderNesting(
      settingKey,
      newPath,
      this.plugin.settings.conversationFolder,
      this.plugin.settings.reportFolder,
      this.plugin.settings.attachmentFolder
    );
    if (!validation.valid) {
      this.showErrorDialog(t("configure_folder_dialog.error_invalid_folder.title"), t("configure_folder_dialog.error_invalid_folder.message", { error: (_a = validation.error) != null ? _a : "Invalid folder configuration" }));
      textComponent.setValue(oldPath);
      return;
    }
    const oldFolder = this.plugin.app.vault.getAbstractFileByPath(oldPath);
    if (!oldFolder || !(oldFolder instanceof import_obsidian8.TFolder)) {
      this.plugin.settings[settingKey] = newPath;
      await this.plugin.saveSettings();
      return;
    }
    const hasContent = oldFolder.children.length > 0;
    if (!hasContent) {
      this.plugin.settings[settingKey] = newPath;
      await this.plugin.saveSettings();
      return;
    }
    const newFolder = this.plugin.app.vault.getAbstractFileByPath(newPath);
    if (newFolder && newFolder instanceof import_obsidian8.TFolder && newFolder.children.length > 0) {
      this.showErrorDialog(
        t("folder_migration.error_target_not_empty.title"),
        t("folder_migration.error_target_not_empty.message", { path: newPath })
      );
      textComponent.setValue(oldPath);
      return;
    }
    const useEnhancedDialog = settingKey === "attachmentFolder" || settingKey === "conversationFolder";
    if (useEnhancedDialog) {
      Promise.resolve().then(() => (init_enhanced_folder_migration_dialog(), enhanced_folder_migration_dialog_exports)).then(({ EnhancedFolderMigrationDialog: EnhancedFolderMigrationDialog2 }) => {
        const dialog = new EnhancedFolderMigrationDialog2(
          this.plugin,
          oldPath,
          newPath,
          folderType,
          async (action) => {
            await this.handleMigrationAction(action, oldPath, newPath, oldFolder, settingKey, textComponent);
          }
        );
        dialog.open();
      }).catch((error) => {
        this.plugin.logger.error("Failed to load enhanced dialog:", error);
        const dialog = new FolderMigrationDialog(
          this.plugin,
          oldPath,
          newPath,
          folderType,
          async (action) => {
            await this.handleMigrationAction(action, oldPath, newPath, oldFolder, settingKey, textComponent);
          }
        );
        dialog.open();
      });
    } else {
      const dialog = new FolderMigrationDialog(
        this.plugin,
        oldPath,
        newPath,
        folderType,
        async (action) => {
          await this.handleMigrationAction(action, oldPath, newPath, oldFolder, settingKey, textComponent);
        }
      );
      dialog.open();
    }
  }
  /**
   * Handle migration action (extracted for reuse between dialog types)
   */
  async handleMigrationAction(action, oldPath, newPath, oldFolder, settingKey, textComponent) {
    if (action === "cancel") {
      textComponent.setValue(oldPath);
      return;
    }
    if (action === "move") {
      try {
        const result = await moveAndMergeFolders(oldFolder, newPath, this.plugin.app.vault);
        if (settingKey === "conversationFolder" || settingKey === "attachmentFolder") {
          await this.updateLinksAfterMove(settingKey, oldPath, newPath);
        }
        if (result.success && result.skipped === 0) {
          new import_obsidian8.Notice(`\u2705 Files moved to ${newPath}`);
        } else {
          this.showMergeResultDialog(result, oldPath, newPath);
        }
      } catch (error) {
        this.plugin.logger.error(`[FolderSettings] Migration failed:`, error);
        this.showErrorDialog(t("folder_migration.error_migration_failed.title"), t("folder_migration.error_migration_failed.message_move", { error: error.message }));
        throw error;
      }
    }
    this.plugin.settings[settingKey] = newPath;
    await this.plugin.saveSettings();
  }
  /**
   * Update links after moving conversations or attachments
   */
  async updateLinksAfterMove(settingKey, oldPath, newPath) {
    try {
      const { LinkUpdateService: LinkUpdateService2 } = await Promise.resolve().then(() => (init_link_update_service(), link_update_service_exports));
      const linkUpdateService = new LinkUpdateService2(this.plugin);
      if (settingKey === "conversationFolder") {
        await linkUpdateService.updateConversationLinks(oldPath, newPath);
      } else if (settingKey === "attachmentFolder") {
        await linkUpdateService.updateAttachmentLinks(oldPath, newPath);
      }
    } catch (error) {
      this.plugin.logger.error(`[FolderSettings] Failed to update links:`, error);
      new import_obsidian8.Notice(`\u26A0\uFE0F Files moved but some links may not have been updated`);
    }
  }
  /**
   * Show dialog with merge result details when files were skipped or errors occurred
   */
  showMergeResultDialog(result, _oldPath, _newPath) {
    const modal = new import_obsidian8.Modal(this.plugin.app);
    modal.titleEl.setText(t("folder_migration.result_dialog.title"));
    const { contentEl } = modal;
    const summary = contentEl.createDiv({ cls: "nexus-merge-summary" });
    summary.createEl("h3", { text: t("folder_migration.result_dialog.summary_title") });
    const stats = summary.createDiv({ cls: "nexus-merge-stats" });
    stats.createEl("p", { text: t("folder_migration.result_dialog.moved", { count: String(result.moved) }) });
    if (result.skipped > 0) {
      stats.createEl("p", {
        text: t("folder_migration.result_dialog.skipped", { count: String(result.skipped) }),
        cls: "nexus-merge-warning"
      });
    }
    if (result.errors > 0) {
      stats.createEl("p", {
        text: t("folder_migration.result_dialog.errors", { count: String(result.errors) }),
        cls: "nexus-merge-error"
      });
    }
    const explanation = contentEl.createDiv({ cls: "nexus-merge-explanation" });
    explanation.createEl("p", {
      text: t("folder_migration.result_dialog.explanation")
    });
    if (result.errorDetails && result.errorDetails.length > 0) {
      const errorSection = contentEl.createDiv({ cls: "nexus-merge-errors" });
      errorSection.createEl("h4", { text: t("folder_migration.result_dialog.error_details_title") });
      const errorList = errorSection.createEl("ul");
      for (const error of result.errorDetails) {
        errorList.createEl("li", { text: error });
      }
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeButton = buttonContainer.createEl("button", { text: t("common.buttons.ok"), cls: "mod-cta" });
    closeButton.addEventListener("click", () => modal.close());
    const styleEl = document.createElement("style");
    styleEl.textContent = `
            .nexus-merge-summary {
                margin-bottom: 20px;
            }
            .nexus-merge-stats p {
                margin: 8px 0;
                font-size: 14px;
            }
            .nexus-merge-warning {
                color: var(--text-warning);
            }
            .nexus-merge-error {
                color: var(--text-error);
            }
            .nexus-merge-explanation {
                padding: 12px;
                background: var(--background-secondary);
                border-radius: 4px;
                margin: 16px 0;
            }
            .nexus-merge-errors {
                margin-top: 16px;
                padding: 12px;
                background: var(--background-modifier-error);
                border-radius: 4px;
            }
            .nexus-merge-errors ul {
                margin: 8px 0;
                padding-left: 20px;
            }
            .nexus-merge-errors li {
                margin: 4px 0;
                font-size: 12px;
                font-family: var(--font-monospace);
            }
        `;
    document.head.appendChild(styleEl);
    modal.open();
  }
  showErrorDialog(title, message) {
    const modal = new import_obsidian8.Modal(this.plugin.app);
    modal.titleEl.setText(title);
    modal.contentEl.createEl("p", {
      text: message,
      cls: "nexus-error-message"
    });
    const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "1em";
    const okButton = buttonContainer.createEl("button", {
      text: t("common.buttons.ok"),
      cls: "mod-cta"
    });
    okButton.addEventListener("click", () => modal.close());
    modal.open();
  }
};
__name(FolderSettingsSection, "FolderSettingsSection");

// src/ui/settings/display-settings-section.ts
var import_obsidian9 = require("obsidian");
init_i18n();
var DisplaySettingsSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.order = 20;
  }
  get title() {
    return t("settings.display.section_title");
  }
  render(containerEl) {
    const sectionContainer = containerEl.createDiv({ cls: "nexus-date-prefix-section" });
    const setting = new import_obsidian9.Setting(sectionContainer).setName(t("settings.display.add_date_prefix.name")).setDesc(t("settings.display.add_date_prefix.desc"));
    if (this.plugin.settings.addDatePrefix) {
      setting.controlEl.createSpan({
        text: t("settings.display.add_date_prefix.format_label"),
        cls: "date-format-label"
      });
      setting.addDropdown(
        (dropdown) => dropdown.addOption("YYYY-MM-DD", "YYYY-MM-DD").addOption("YYYYMMDD", "YYYYMMDD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
          if (value === "YYYY-MM-DD" || value === "YYYYMMDD") {
            this.plugin.settings.dateFormat = value;
            await this.plugin.saveSettings();
          }
        })
      );
    }
    setting.addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.addDatePrefix).onChange(async (value) => {
        this.plugin.settings.addDatePrefix = value;
        await this.plugin.saveSettings();
        this.redraw();
      })
    );
  }
};
__name(DisplaySettingsSection, "DisplaySettingsSection");

// src/ui/settings/message-date-format-section.ts
var import_obsidian10 = require("obsidian");
init_constants();
init_utils();
init_i18n();
var MessageDateFormatSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.order = 21;
  }
  get title() {
    return t("settings.timestamps.section_title");
  }
  render(containerEl) {
    const sectionContainer = containerEl.createDiv({ cls: "nexus-message-date-section" });
    new import_obsidian10.Setting(sectionContainer).setName(t("settings.timestamps.custom_format.name")).setDesc(t("settings.timestamps.custom_format.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useCustomMessageTimestampFormat).onChange(async (value) => {
        this.plugin.settings.useCustomMessageTimestampFormat = value;
        await this.plugin.saveSettings();
        this.redraw();
      })
    );
    if (this.plugin.settings.useCustomMessageTimestampFormat) {
      new import_obsidian10.Setting(sectionContainer).setName(t("settings.timestamps.timestamp_format.name")).setDesc(t("settings.timestamps.timestamp_format.desc")).addDropdown((dropdown) => {
        Object.entries(MESSAGE_TIMESTAMP_FORMATS).forEach(([key, config]) => {
          dropdown.addOption(key, config.label);
        });
        dropdown.setValue(this.plugin.settings.messageTimestampFormat).onChange(async (value) => {
          this.plugin.settings.messageTimestampFormat = value;
          await this.plugin.saveSettings();
          this.updateTimestampPreview(previewContainer, value);
        });
      });
      const previewContainer = sectionContainer.createDiv({ cls: "nexus-timestamp-preview" });
      this.updateTimestampPreview(previewContainer, this.plugin.settings.messageTimestampFormat);
    }
  }
  /**
   * Update timestamp format preview
   */
  updateTimestampPreview(container, format) {
    const now = Date.now() / 1e3;
    const preview = formatMessageTimestamp(now, format);
    container.empty();
    const previewLine = container.createDiv({ cls: "nexus-preview-line" });
    previewLine.createEl("strong", { text: t("settings.timestamps.preview_label") });
    previewLine.createEl("code", { text: preview, cls: "nexus-preview-code" });
    const config = MESSAGE_TIMESTAMP_FORMATS[format];
    if (config) {
      container.createEl("div", {
        text: config.description,
        cls: "nexus-format-description"
      });
    }
  }
};
__name(MessageDateFormatSection, "MessageDateFormatSection");

// src/ui/settings-tab.ts
var NexusAiChatImporterPluginSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.sections = [];
    this.initializeSections();
  }
  initializeSections() {
    this.sections = [
      new SupportSection(this.plugin),
      new FolderSettingsSection(this.plugin),
      new DisplaySettingsSection(this.plugin),
      new MessageDateFormatSection(this.plugin)
    ].sort((a, b) => a.order - b.order);
    this.sections.forEach((section) => {
      section.setRedrawCallback(() => this.display());
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderSections(containerEl);
  }
  async renderSections(containerEl) {
    for (const section of this.sections) {
      if (section.title) {
        containerEl.createEl("h2", { text: section.title });
      }
      await section.render(containerEl);
    }
  }
};
__name(NexusAiChatImporterPluginSettingTab, "NexusAiChatImporterPluginSettingTab");

// src/commands/command-registry.ts
init_i18n();
var CommandRegistry = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "nexus-ai-chat-importer-select-zip",
      name: t("commands.import_conversations.name"),
      callback: () => {
        this.plugin.showProviderSelectionDialog();
      }
    });
  }
};
__name(CommandRegistry, "CommandRegistry");

// src/events/event-handlers.ts
var import_obsidian12 = require("obsidian");
var EventHandlers = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerEvents() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", async (file) => {
        if (file instanceof import_obsidian12.TFile) {
          await this.plugin.getFileService().handleConversationFileDeletion(file);
        }
      })
    );
  }
  cleanup() {
  }
};
__name(EventHandlers, "EventHandlers");

// src/services/import-service.ts
var import_obsidian17 = require("obsidian");
init_utils();
init_dialogs();

// src/models/import-report.ts
init_utils();
var ImportReport = class {
  constructor() {
    this.fileSections = /* @__PURE__ */ new Map();
    this.currentFileName = "";
    this.globalErrors = [];
    this.providerSpecificColumnHeader = "Attachments";
    this.operationStartTime = Date.now();
  }
  // Custom format for report dates
  /**
   * Start a new file section for multi-file imports
   */
  startFileSection(fileName) {
    this.currentFileName = fileName;
    if (!this.fileSections.has(fileName)) {
      this.fileSections.set(fileName, {
        fileName,
        created: [],
        updated: [],
        skipped: [],
        failed: [],
        counters: {
          totalConversationsProcessed: 0,
          totalNewConversationsSuccessfullyImported: 0,
          totalConversationsActuallyUpdated: 0,
          totalNonEmptyMessagesAdded: 0
        }
      });
    }
  }
  /**
   * Set counters for the current file section
   */
  setFileCounters(counters) {
    const section = this.getCurrentSection();
    if (section) {
      section.counters = counters;
    }
  }
  getCurrentSection() {
    return this.fileSections.get(this.currentFileName);
  }
  setProviderSpecificColumnHeader(header) {
    this.providerSpecificColumnHeader = header;
  }
  setCustomTimestampFormat(format) {
    this.customTimestampFormat = format;
  }
  /**
   * Legacy method for backward compatibility (single file imports)
   */
  addSummary(zipFileName, counters) {
    this.startFileSection(zipFileName);
    this.setFileCounters(counters);
  }
  getTotalAttachmentStats() {
    const total = { total: 0, found: 0, missing: 0, failed: 0 };
    this.fileSections.forEach((section) => {
      [...section.created, ...section.updated].forEach((entry) => {
        if (entry.attachmentStats) {
          total.total += entry.attachmentStats.total;
          total.found += entry.attachmentStats.found;
          total.missing += entry.attachmentStats.missing;
          total.failed += entry.attachmentStats.failed;
        }
        if (entry.providerSpecificCount) {
          total.total += entry.providerSpecificCount;
          total.found += entry.providerSpecificCount;
        }
      });
    });
    return total;
  }
  getFileSectionAttachmentStats(section) {
    const total = { total: 0, found: 0, missing: 0, failed: 0 };
    [...section.created, ...section.updated].forEach((entry) => {
      if (entry.attachmentStats) {
        total.total += entry.attachmentStats.total;
        total.found += entry.attachmentStats.found;
        total.missing += entry.attachmentStats.missing;
        total.failed += entry.attachmentStats.failed;
      }
      if (entry.providerSpecificCount) {
        total.total += entry.providerSpecificCount;
        total.found += entry.providerSpecificCount;
      }
    });
    return total;
  }
  getGlobalStats() {
    let created = 0;
    let updated = 0;
    let skipped = 0;
    let failed = 0;
    let totalProcessed = 0;
    let newMessages = 0;
    this.fileSections.forEach((section) => {
      created += section.created.length;
      updated += section.updated.length;
      skipped += section.skipped.length;
      failed += section.failed.length;
      totalProcessed += section.counters.totalConversationsProcessed;
      newMessages += section.counters.totalNonEmptyMessagesAdded;
    });
    return { created, updated, skipped, failed, totalProcessed, newMessages };
  }
  addCreated(title, filePath, createTime, updateTime, messageCount, attachmentStats, providerSpecificCount) {
    const section = this.getCurrentSection();
    if (section) {
      section.created.push({ title, filePath, createTime, updateTime, messageCount, attachmentStats, providerSpecificCount, sourceFile: this.currentFileName });
    }
  }
  addUpdated(title, filePath, createTime, updateTime, newMessageCount, attachmentStats, providerSpecificCount) {
    const section = this.getCurrentSection();
    if (section) {
      section.updated.push({ title, filePath, createTime, updateTime, newMessageCount, attachmentStats, providerSpecificCount, sourceFile: this.currentFileName });
    }
  }
  addSkipped(title, filePath, createTime, updateTime, messageCount, reason, attachmentStats, providerSpecificCount) {
    const section = this.getCurrentSection();
    if (section) {
      section.skipped.push({ title, filePath, createTime, updateTime, messageCount, reason, attachmentStats, providerSpecificCount, sourceFile: this.currentFileName });
    }
  }
  addFailed(title, filePath, createTime, updateTime, errorMessage) {
    const section = this.getCurrentSection();
    if (section) {
      section.failed.push({ title, filePath, createTime, updateTime, errorMessage, sourceFile: this.currentFileName });
    }
  }
  addError(message, details) {
    this.globalErrors.push({ message, details });
  }
  generateReportContent(allFiles, processedFiles, skippedFiles, analysisInfo, fileStats, isSelectiveImport) {
    let content = "# Nexus AI Chat Importer Report\n\n";
    content += this.generateGlobalSummary(allFiles, processedFiles, skippedFiles, analysisInfo, fileStats, isSelectiveImport) + "\n\n";
    if (skippedFiles && skippedFiles.length > 0) {
      content += this.generateSkippedFilesSection(skippedFiles, isSelectiveImport) + "\n\n";
    }
    const fileNames = Array.from(this.fileSections.keys());
    if (fileNames.length === 0) {
      content += "## Result\n\n";
      content += "No conversations were imported. All conversations are already up to date.\n\n";
    } else if (fileNames.length === 1) {
      const section = this.fileSections.get(fileNames[0]);
      content += this.generateFileContent(section, false);
    } else {
      content += "---\n\n";
      content += "## Processed Files\n\n";
      fileNames.forEach((fileName, index) => {
        const section = this.fileSections.get(fileName);
        content += `### File ${index + 1}: ${fileName}

`;
        content += this.generateFileSummary(section) + "\n\n";
        content += this.generateFileContent(section, true);
        if (index < fileNames.length - 1) {
          content += "\n";
        }
      });
    }
    if (this.globalErrors.length > 0) {
      content += `---

`;
      content += this.generateErrorTable();
    }
    return content;
  }
  generateSkippedFilesSection(skippedFiles, isSelectiveImport) {
    const title = isSelectiveImport ? "\u23ED\uFE0F Skipped Files (No Selected Conversations)" : "\u23ED\uFE0F Skipped Files (Already Up to Date)";
    const explanation = isSelectiveImport ? "Files not processed because they contain no selected conversations" : "Files analyzed but not processed because all conversations are already up to date";
    let section = `> [!note]- ${title}
`;
    section += `> ${explanation}
`;
    section += `> 
`;
    section += `> **Total:** ${skippedFiles.length} files
`;
    section += `> 
`;
    section += `> <details>
`;
    section += `> <summary>View file list</summary>
`;
    section += `> 
`;
    skippedFiles.forEach((fileName) => {
      section += `> - \`${fileName}\`
`;
    });
    section += `> 
`;
    section += `> </details>
`;
    return section;
  }
  generateGlobalSummary(allFiles, processedFiles, skippedFiles, analysisInfo, fileStats, isSelectiveImport) {
    const stats = this.getGlobalStats();
    const totalAttachments = this.getTotalAttachmentStats();
    const fileCount = this.fileSections.size;
    const totalFilesAnalyzed = allFiles ? allFiles.length : fileCount;
    const filesSkipped = skippedFiles ? skippedFiles.length : 0;
    let summary = `## \u{1F4CA} Import Summary

`;
    if (allFiles && allFiles.length > 0) {
      summary += `### \u{1F4E6} Files Analyzed

`;
      summary += `| File | Conversations | Duplicates | Skipped | Selected | Created | Updated |
`;
      summary += `|:---|---:|---:|---:|---:|---:|---:|
`;
      const fileInfos = [];
      allFiles.forEach((file) => {
        fileInfos.push({
          name: file.name,
          file
        });
      });
      fileInfos.sort((a, b) => {
        var _a, _b;
        const timeA = ((_a = a.file) == null ? void 0 : _a.lastModified) || 0;
        const timeB = ((_b = b.file) == null ? void 0 : _b.lastModified) || 0;
        return timeA - timeB;
      });
      fileInfos.forEach((info) => {
        const stats2 = fileStats == null ? void 0 : fileStats.get(info.name);
        const section = this.fileSections.get(info.name);
        if (stats2) {
          const created = (section == null ? void 0 : section.created.length) || 0;
          const updated = (section == null ? void 0 : section.updated.length) || 0;
          const skipped = stats2.skippedConversations || 0;
          summary += `| \`${info.name}\` | ${stats2.totalConversations} | ${stats2.duplicates} | ${skipped} | ${stats2.selectedForImport} | ${created} | ${updated} |
`;
        } else {
          summary += `| \`${info.name}\` | - | - | - | - | 0 | 0 |
`;
        }
      });
      summary += `
`;
    }
    if (analysisInfo && !isSelectiveImport) {
      summary += `> [!info]- \u{1F50D} Global Statistics
`;
      summary += `> 
`;
      summary += `> | Metric | Count |
`;
      summary += `> |:---|---:|
`;
      summary += `> | Total Conversations Found | ${analysisInfo.totalConversationsFound || 0} |
`;
      summary += `> | Unique Conversations | ${analysisInfo.uniqueConversationsKept || 0} |
`;
      if (analysisInfo.duplicatesRemoved > 0) {
        summary += `> | Duplicates Removed | ${analysisInfo.duplicatesRemoved} |
`;
      }
      summary += `> | New | ${analysisInfo.conversationsNew || 0} |
`;
      summary += `> | Updated | ${analysisInfo.conversationsUpdated || 0} |
`;
      summary += `> | Skipped | ${analysisInfo.conversationsIgnored || 0} |
`;
      summary += `
`;
    }
    summary += `### \u{1F4E5} Import Summary

`;
    summary += `| Category | Count |
`;
    summary += `|:---|---:|
`;
    summary += `| **Total Imported** | **${stats.created + stats.updated}** |
`;
    summary += `| \u2728 Created | ${stats.created} |
`;
    summary += `| \u{1F504} Updated | ${stats.updated}`;
    if (stats.newMessages > 0) {
      summary += ` (${stats.newMessages} new messages)`;
    }
    summary += ` |
`;
    if (stats.skipped > 0) {
      summary += `| \u23ED\uFE0F Skipped (unchanged) | ${stats.skipped} |
`;
    }
    if (stats.failed > 0) {
      summary += `| \u274C Failed | ${stats.failed} |
`;
    }
    if (this.globalErrors.length > 0) {
      summary += `| \u26A0\uFE0F Errors | ${this.globalErrors.length} |
`;
    }
    if (totalAttachments.total > 0) {
      const attachmentIcon = totalAttachments.found === totalAttachments.total ? "\u2705" : totalAttachments.found === 0 ? "\u274C" : "\u26A0\uFE0F";
      summary += `| ${attachmentIcon} Attachments | ${totalAttachments.found}/${totalAttachments.total} |
`;
      if (totalAttachments.missing > 0 || totalAttachments.failed > 0) {
        summary += `| \u2514\u2500 Missing | ${totalAttachments.missing} |
`;
        summary += `| \u2514\u2500 Failed | ${totalAttachments.failed} |
`;
      }
    }
    return summary;
  }
  generateFileSummary(section) {
    const attachmentStats = this.getFileSectionAttachmentStats(section);
    const attachmentSummary = attachmentStats.total > 0 ? `
- **Attachments**: ${attachmentStats.found}/${attachmentStats.total} extracted` : "";
    return `### Statistics
- **Created**: ${section.created.length}
- **Updated**: ${section.updated.length} (${section.counters.totalNonEmptyMessagesAdded} new messages)
- **Skipped**: ${section.skipped.length}
- **Failed**: ${section.failed.length}${attachmentSummary}`;
  }
  generateFileContent(section, isMultiFile) {
    let content = "";
    if (section.created.length > 0) {
      content += this.generateCreatedTable(section.created, isMultiFile);
    }
    if (section.updated.length > 0) {
      content += this.generateUpdatedTable(section.updated, isMultiFile);
    }
    if (section.failed.length > 0) {
      content += this.generateFailedTable(section.failed, isMultiFile);
    }
    return content;
  }
  generateCreatedTable(entries, isMultiFile) {
    const header = isMultiFile ? "### \u2728 Created Notes" : "## \u2728 Created Notes";
    let table = `${header}

`;
    table += `| | Title | Created | Messages | ${this.providerSpecificColumnHeader} |
`;
    table += "|:---:|:---|:---:|:---:|:---:|\n";
    const sortedEntries = [...entries].sort((a, b) => {
      return a.createTime - b.createTime;
    });
    sortedEntries.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      const titleLink = `[[${entry.filePath}\\|${sanitizedTitle}]]`;
      const providerSpecificValue = entry.providerSpecificCount || 0;
      const createDate = formatMessageTimestamp(entry.createTime, this.customTimestampFormat);
      const providerSpecificDisplay = providerSpecificValue > 0 ? `\u2705 ${providerSpecificValue}` : providerSpecificValue;
      table += `| \u2728 | ${titleLink} | ${createDate} | ${entry.messageCount || 0} | ${providerSpecificDisplay} |
`;
    });
    return table + "\n\n";
  }
  generateUpdatedTable(entries, isMultiFile) {
    const header = isMultiFile ? "### \u{1F504} Updated Notes" : "## \u{1F504} Updated Notes";
    let table = `${header}

`;
    table += `| | Title | Updated | New Messages | New ${this.providerSpecificColumnHeader} |
`;
    table += "|:---:|:---|:---:|:---:|:---:|\n";
    const sortedEntries = [...entries].sort((a, b) => {
      return a.updateTime - b.updateTime;
    });
    sortedEntries.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      const titleLink = `[[${entry.filePath}\\|${sanitizedTitle}]]`;
      const providerSpecificValue = entry.providerSpecificCount || 0;
      const updateDate = formatMessageTimestamp(entry.updateTime, this.customTimestampFormat);
      const providerSpecificDisplay = providerSpecificValue > 0 ? `\u2705 ${providerSpecificValue}` : providerSpecificValue;
      table += `| \u{1F504} | ${titleLink} | ${updateDate} | ${entry.newMessageCount || 0} | ${providerSpecificDisplay} |
`;
    });
    return table + "\n\n";
  }
  generateFailedTable(entries, isMultiFile) {
    const header = isMultiFile ? "### \u{1F6AB} Failed Imports" : "## \u{1F6AB} Failed Imports";
    let table = `${header}

`;
    table += "| | Title | Date | Error |\n";
    table += "|:---:|:---|:---:|:---|\n";
    const sortedEntries = [...entries].sort((a, b) => {
      return a.createTime - b.createTime;
    });
    sortedEntries.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      const createDate = formatMessageTimestamp(entry.createTime, this.customTimestampFormat);
      table += `| \u{1F6AB} | ${sanitizedTitle} | ${createDate} | ${entry.errorMessage || "Unknown error"} |
`;
    });
    return table + "\n\n";
  }
  generateErrorTable() {
    let table = `## \u26A0\uFE0F Global Errors

`;
    table += "| | Error | Details |\n";
    table += "|:---:|:---|:---|\n";
    this.globalErrors.forEach((entry) => {
      table += `| \u26A0\uFE0F | ${entry.message} | ${entry.details} |
`;
    });
    return table + "\n\n";
  }
  formatAttachmentStatus(stats) {
    if (!stats || stats.total === 0) {
      return "0";
    }
    const { total, found, missing, failed } = stats;
    if (found === total) {
      return `\u2705 ${found}`;
    } else if (found === 0) {
      return `\u274C 0/${total}`;
    } else {
      return `\u26A0\uFE0F ${found}/${total}`;
    }
  }
  hasErrors() {
    let hasFailed = false;
    this.fileSections.forEach((section) => {
      if (section.failed.length > 0) {
        hasFailed = true;
      }
    });
    return hasFailed || this.globalErrors.length > 0;
  }
  getCreatedCount() {
    let count = 0;
    this.fileSections.forEach((section) => {
      count += section.created.length;
    });
    return count;
  }
  getUpdatedCount() {
    let count = 0;
    this.fileSections.forEach((section) => {
      count += section.updated.length;
    });
    return count;
  }
  getSkippedCount() {
    let count = 0;
    this.fileSections.forEach((section) => {
      count += section.skipped.length;
    });
    return count;
  }
  getFailedCount() {
    let count = 0;
    this.fileSections.forEach((section) => {
      count += section.failed.length;
    });
    return count;
  }
  /**
   * Store file analysis stats for duplicate counting
   */
  setFileStats(fileStats) {
    this.fileStats = fileStats;
  }
  /**
   * Store analysis info for completion stats
   */
  setAnalysisInfo(analysisInfo) {
    this.analysisInfo = analysisInfo;
  }
  /**
   * Calculate total duplicates from file stats
   */
  getTotalDuplicates() {
    if (!this.fileStats)
      return 0;
    let totalDuplicates = 0;
    this.fileStats.forEach((stats) => {
      totalDuplicates += stats.duplicates || 0;
    });
    return totalDuplicates;
  }
  /**
   * Get statistics for the completion dialog
   */
  getCompletionStats() {
    var _a, _b, _c, _d, _e, _f;
    const globalStats = this.getGlobalStats();
    const attachmentStats = this.getTotalAttachmentStats();
    const totalConversations = (_b = (_a = this.analysisInfo) == null ? void 0 : _a.uniqueConversationsKept) != null ? _b : globalStats.totalProcessed;
    const duplicates = (_d = (_c = this.analysisInfo) == null ? void 0 : _c.duplicatesRemoved) != null ? _d : this.getTotalDuplicates();
    const skipped = (_f = (_e = this.analysisInfo) == null ? void 0 : _e.conversationsIgnored) != null ? _f : globalStats.skipped;
    return {
      totalFiles: this.fileSections.size,
      totalConversations,
      duplicates,
      created: globalStats.created,
      updated: globalStats.updated,
      skipped,
      failed: globalStats.failed,
      attachmentsFound: attachmentStats.found,
      attachmentsTotal: attachmentStats.total,
      attachmentsMissing: attachmentStats.missing,
      attachmentsFailed: attachmentStats.failed
    };
  }
  /**
   * Get list of processed file names
   */
  getProcessedFileNames() {
    return Array.from(this.fileSections.keys());
  }
};
__name(ImportReport, "ImportReport");

// src/services/conversation-processor.ts
var import_obsidian15 = require("obsidian");

// src/formatters/message-formatter.ts
init_utils();

// src/utils/file-utils.ts
function formatFileSize(bytes) {
  const sizes = ["Bytes", "KB", "MB", "GB"];
  if (bytes === 0)
    return "0 Bytes";
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + " " + sizes[i];
}
__name(formatFileSize, "formatFileSize");
function isImageFile(attachment) {
  let fileName;
  let fileType;
  if (typeof attachment === "string") {
    fileName = attachment;
    fileType = void 0;
  } else {
    fileName = attachment.fileName;
    fileType = attachment.fileType;
  }
  if (fileType == null ? void 0 : fileType.startsWith("image/")) {
    return true;
  }
  const lowerFileName = fileName.toLowerCase();
  const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".bmp", ".tiff"];
  return imageExtensions.some((ext) => lowerFileName.endsWith(ext));
}
__name(isImageFile, "isImageFile");
function isTextFile(fileName) {
  const textExtensions = [".txt", ".md", ".json", ".csv", ".xml", ".html", ".css", ".js", ".ts", ".py", ".java", ".cpp", ".c", ".h"];
  return textExtensions.some((ext) => fileName.toLowerCase().endsWith(ext));
}
__name(isTextFile, "isTextFile");
function getFileExtension(fileName) {
  const lastDot = fileName.lastIndexOf(".");
  if (lastDot === -1)
    return "";
  return fileName.substring(lastDot + 1).toLowerCase();
}
__name(getFileExtension, "getFileExtension");
function detectFileFormat(fileContent) {
  if (fileContent.length < 4) {
    return { extension: null, mimeType: null };
  }
  const header = Array.from(fileContent.slice(0, 12)).map((b) => b.toString(16).padStart(2, "0")).join("");
  if (header.startsWith("89504e47")) {
    return { extension: "png", mimeType: "image/png" };
  }
  if (header.startsWith("ffd8ff")) {
    return { extension: "jpg", mimeType: "image/jpeg" };
  }
  if (header.startsWith("47494638")) {
    return { extension: "gif", mimeType: "image/gif" };
  }
  if (header.startsWith("52494646") && header.substring(16, 24) === "57454250") {
    return { extension: "webp", mimeType: "image/webp" };
  }
  if (header.startsWith("52494646")) {
    return { extension: "webp", mimeType: "image/webp" };
  }
  return { extension: null, mimeType: null };
}
__name(detectFileFormat, "detectFileFormat");
function sanitizeFileName(fileName) {
  return fileName.trim().replace(/[<>:"\/\\|?*]/g, "_").replace(/\s+/g, "_");
}
__name(sanitizeFileName, "sanitizeFileName");
function getFileCategory(fileName, fileType) {
  if (fileType) {
    if (fileType.startsWith("image/"))
      return "images";
    if (fileType.startsWith("audio/"))
      return "audio";
    if (fileType.startsWith("video/"))
      return "video";
    if (fileType.startsWith("text/") || fileType.includes("document"))
      return "documents";
  }
  const ext = getFileExtension(fileName);
  const audioExts = ["wav", "mp3", "ogg", "m4a", "flac"];
  const imageExts = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
  const docExts = ["pdf", "doc", "docx", "txt", "md", "rtf"];
  const videoExts = ["mp4", "avi", "mov", "mkv"];
  if (audioExts.includes(ext))
    return "audio";
  if (imageExts.includes(ext))
    return "images";
  if (docExts.includes(ext))
    return "documents";
  if (videoExts.includes(ext))
    return "video";
  return "files";
}
__name(getFileCategory, "getFileCategory");

// src/formatters/message-formatter.ts
var _MessageFormatter = class {
  constructor(logger6, plugin) {
    this.logger = logger6;
    this.plugin = plugin;
  }
  formatMessages(messages) {
    return messages.filter((message) => message !== void 0).map((message) => this.formatMessage(message)).filter((formattedMessage) => formattedMessage !== "").join("\n");
  }
  formatMessage(message) {
    if (!message) {
      this.logger.error("Message is null or undefined:", message);
      return "";
    }
    const customFormat = this.plugin.settings.useCustomMessageTimestampFormat ? this.plugin.settings.messageTimestampFormat : void 0;
    const messageTime = formatMessageTimestamp(message.timestamp, customFormat);
    const authorName = message.role === "user" ? "User" : "Assistant";
    const calloutType = message.role === "user" ? _MessageFormatter.CALLOUTS.USER : _MessageFormatter.CALLOUTS.AGENT;
    let messageContent = `>[!${calloutType}] **${authorName}** - ${messageTime}
`;
    if (message.content) {
      const contentWithMath = _MessageFormatter.convertLatexDelimiters(message.content);
      const lines = contentWithMath.split("\n");
      const formattedLines = lines.map((line) => {
        if (line.trim() === "") {
          return ">";
        }
        if (line.startsWith(">")) {
          return ">" + line;
        }
        return `> ${line}`;
      });
      messageContent += formattedLines.join("\n");
    } else {
      messageContent += `> [No content found]`;
    }
    if (message.attachments && message.attachments.length > 0) {
      messageContent += "\n" + this.formatAttachments(message.attachments);
    }
    messageContent += `
<!-- UID: ${message.id} -->`;
    if (message.role === "assistant") {
      messageContent += "\n\n---";
    }
    return messageContent;
  }
  formatAttachments(attachments) {
    return attachments.map((attachment) => {
      return this.formatSingleAttachment(attachment);
    }).join("\n>\n");
  }
  /**
   * Format single attachment with Nexus callout styling
   *
   * Provider-formatted attachments (with extractedContent) are displayed as-is.
   * Generic attachments get basic formatting.
   */
  formatSingleAttachment(attachment) {
    var _a, _b;
    if (attachment.extractedContent) {
      return attachment.extractedContent;
    }
    let content = `>>[!${_MessageFormatter.CALLOUTS.ATTACHMENT}] `;
    if ((_a = attachment.status) == null ? void 0 : _a.found) {
      content += `**${attachment.fileName}**`;
    } else {
      content += `**${attachment.fileName}** *(missing)*`;
    }
    if (attachment.fileType) {
      content += ` (${attachment.fileType})`;
    }
    if (attachment.fileSize) {
      content += ` - ${formatFileSize(attachment.fileSize)}`;
    }
    content += "\n>>\n";
    if (((_b = attachment.status) == null ? void 0 : _b.found) && attachment.url) {
      if (!attachment.url.startsWith("sandbox://")) {
        if (isImageFile(attachment)) {
          content += `>> ![[${attachment.url}]]`;
        } else {
          content += `>> [[${attachment.url}]]`;
        }
      } else {
        content += `>> \u26A0\uFE0F File not available in archive. Visit the original conversation to access it`;
      }
    } else if (attachment.status && !attachment.status.found) {
      if (attachment.status.reason === "missing_from_export") {
        const link = attachment.url ? ` [Open original conversation](${attachment.url})` : "";
        content += `>> \u26A0\uFE0F ${this.getStatusMessage(attachment.status.reason)}.${link}`;
      } else {
        content += `>> \u26A0\uFE0F ${this.getStatusMessage(attachment.status.reason)}`;
        if (attachment.status.note) {
          content += `
>> **Note:** ${attachment.status.note}`;
        }
      }
    } else if (attachment.content) {
      content += `>> ${attachment.content}`;
    }
    return content;
  }
  /**
   * Convert LaTeX delimiters to Obsidian math syntax.
   * \[...\] → $$...$$ (display math)
   * \(...\) → $...$ (inline math)
   * Preserves content inside fenced code blocks and inline code.
   */
  static convertLatexDelimiters(text) {
    const codePattern = /(```[\s\S]*?```|`[^`]+`)/g;
    const segments = [];
    let lastIndex = 0;
    let match;
    while ((match = codePattern.exec(text)) !== null) {
      if (match.index > lastIndex) {
        segments.push({ text: text.slice(lastIndex, match.index), isCode: false });
      }
      segments.push({ text: match[0], isCode: true });
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < text.length) {
      segments.push({ text: text.slice(lastIndex), isCode: false });
    }
    return segments.map((segment) => {
      if (segment.isCode)
        return segment.text;
      let result = segment.text;
      result = result.replace(/(?<!\\)\\\[([\s\S]*?)(?<!\\)\\\]/g, "$$$$$1$$$$");
      result = result.replace(/(?<!\\)\\\((.*?)(?<!\\)\\\)/g, "$$$1$$");
      return result;
    }).join("");
  }
  /**
   * Get user-friendly status message
   */
  getStatusMessage(reason) {
    switch (reason) {
      case "missing_from_export":
        return "Not included in export";
      case "extraction_failed":
        return "Extraction failed";
      case "corrupted":
        return "File appears corrupted";
      case "unsupported_format":
        return "Unsupported file format";
      default:
        return "Processing issue";
    }
  }
};
var MessageFormatter = _MessageFormatter;
__name(MessageFormatter, "MessageFormatter");
// Nexus custom callouts with icons
MessageFormatter.CALLOUTS = {
  USER: "nexus_user",
  // 👤 User messages
  AGENT: "nexus_agent",
  // 🤖 Assistant/Agent messages
  ATTACHMENT: "nexus_attachment",
  // 📎 Attachments
  ARTIFACT: "nexus_artifact",
  // 🛠️ Claude artifacts
  PROMPT: "nexus_prompt"
  // 💭 System prompts
};

// src/formatters/note-formatter.ts
init_utils();

// src/types/standard.ts
init_constants();
var URL_GENERATORS = {
  chatgpt: {
    generateChatUrl: PROVIDER_URLS.CHATGPT.CHAT
  },
  claude: {
    generateChatUrl: PROVIDER_URLS.CLAUDE.CHAT
  }
};

// src/formatters/note-formatter.ts
var NoteFormatter = class {
  constructor(logger6, pluginId, pluginVersion, plugin) {
    this.logger = logger6;
    this.pluginId = pluginId;
    this.pluginVersion = pluginVersion;
    this.plugin = plugin;
    this.messageFormatter = new MessageFormatter(logger6, plugin);
  }
  generateMarkdownContent(conversation) {
    const safeTitle = generateSafeAlias(conversation.title);
    const createTimeStr = new Date(conversation.createTime * 1e3).toISOString();
    const updateTimeStr = new Date(conversation.updateTime * 1e3).toISOString();
    const createTimeDisplay = `${formatTimestamp(conversation.createTime, "date")} at ${formatTimestamp(conversation.createTime, "time")}`;
    const updateTimeDisplay = `${formatTimestamp(conversation.updateTime, "date")} at ${formatTimestamp(conversation.updateTime, "time")}`;
    let content = this.generateHeader(safeTitle, conversation.id, createTimeStr, updateTimeStr, createTimeDisplay, updateTimeDisplay, conversation);
    content += this.generateMessagesContent(conversation);
    return content;
  }
  generateHeader(title, conversationId, createTimeStr, updateTimeStr, createTimeDisplay, updateTimeDisplay, conversation) {
    let chatUrl = conversation.chatUrl;
    if (!chatUrl && URL_GENERATORS[conversation.provider]) {
      chatUrl = URL_GENERATORS[conversation.provider].generateChatUrl(conversationId);
    }
    let frontmatter = `---
nexus: ${this.pluginId}
plugin_version: "${this.pluginVersion}"
provider: ${conversation.provider}
aliases: ${title}
conversation_id: ${conversationId}
create_time: ${createTimeStr}
update_time: ${updateTimeStr}
---

`;
    let header = `# Title: ${conversation.title}

`;
    header += `Created: ${createTimeDisplay}
`;
    header += `Last Updated: ${updateTimeDisplay}
`;
    if (chatUrl) {
      header += `Chat URL: ${chatUrl}
`;
    }
    header += "\n\n";
    return frontmatter + header;
  }
  generateMessagesContent(conversation) {
    return this.messageFormatter.formatMessages(conversation.messages);
  }
};
__name(NoteFormatter, "NoteFormatter");

// src/services/file-service.ts
var import_obsidian14 = require("obsidian");
var FileService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async writeToFile(filePath, content) {
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian14.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else if (file instanceof import_obsidian14.TFolder) {
        throw new Error(`Cannot write to '${filePath}'; it is a folder.`);
      } else {
        await this.plugin.app.vault.create(filePath, content);
      }
    } catch (error) {
      this.plugin.logger.error(`Error creating or modifying file '${filePath}'`, error.message);
      throw error;
    }
  }
  async handleConversationFileDeletion(file) {
    var _a;
    try {
      const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!(frontmatter == null ? void 0 : frontmatter.conversation_id) || (frontmatter == null ? void 0 : frontmatter.nexus) !== this.plugin.manifest.id) {
        return;
      }
    } catch (error) {
      this.plugin.logger.error("Error handling conversation file deletion:", error);
    }
  }
  /**
   * Get file extension from filename (provider-agnostic utility)
   */
  getFileExtension(fileName) {
    const lastDot = fileName.lastIndexOf(".");
    return lastDot === -1 ? "" : fileName.substring(lastDot + 1).toLowerCase();
  }
  // TODO: Future enhancement - delete conversation attachments
  // async deleteConversationAttachments(conversationId: string): Promise<void> {
  //     // Implementation for deleting attachments when conversation is deleted
  // }
};
__name(FileService, "FileService");

// src/services/conversation-processor.ts
init_utils();
var ConversationProcessor = class {
  constructor(plugin, providerRegistry) {
    this.plugin = plugin;
    this.counters = {
      totalExistingConversations: 0,
      totalNewConversationsToImport: 0,
      totalExistingConversationsToUpdate: 0,
      totalNewConversationsSuccessfullyImported: 0,
      totalConversationsActuallyUpdated: 0,
      totalConversationsProcessed: 0,
      totalNonEmptyMessagesToImport: 0,
      totalNonEmptyMessagesToAdd: 0,
      totalNonEmptyMessagesAdded: 0
    };
    this.currentProvider = "unknown";
    this.messageFormatter = new MessageFormatter(plugin.logger, plugin);
    this.fileService = new FileService(plugin);
    this.noteFormatter = new NoteFormatter(plugin.logger, plugin.manifest.id, plugin.manifest.version, plugin);
    this.providerRegistry = providerRegistry;
  }
  /**
   * Process raw conversations (provider agnostic entry point)
   */
  async processRawConversations(rawConversations, importReport, zip, isReprocess = false, forcedProvider, progressCallback) {
    const provider = forcedProvider || this.providerRegistry.detectProvider(rawConversations);
    if (provider === "unknown") {
      const errorMsg = forcedProvider ? `Forced provider '${forcedProvider}' is not available or registered` : `Could not detect conversation provider from data structure`;
      importReport.addError("Unknown provider", errorMsg);
      return importReport;
    }
    return this.processConversationsWithProvider(provider, rawConversations, importReport, zip, isReprocess, progressCallback);
  }
  /**
   * Get provider name for current processing session
   */
  getCurrentProvider() {
    return this.currentProvider || "unknown";
  }
  /**
   * Process conversations using the detected provider
   */
  async processConversationsWithProvider(provider, rawConversations, importReport, zip, isReprocess = false, progressCallback) {
    var _a;
    this.currentProvider = provider;
    const adapter = this.providerRegistry.getAdapter(provider);
    if (!adapter) {
      importReport.addError("Provider adapter not found", `No adapter found for provider: ${provider}`);
      return importReport;
    }
    let conversationsToProcess = rawConversations;
    if (provider === "gemini" && ((_a = adapter.hasIndex) == null ? void 0 : _a.call(adapter))) {
      progressCallback == null ? void 0 : progressCallback({
        phase: "processing",
        title: "Grouping Gemini conversations...",
        detail: "Using index to reconstruct full conversations"
      });
      const groupedConversations = adapter.convertAllWithIndex(rawConversations);
      conversationsToProcess = groupedConversations;
      this.plugin.logger.info(`[Gemini] Grouped ${rawConversations.length} entries into ${groupedConversations.length} conversations`);
    }
    const storage = this.plugin.getStorageService();
    const existingConversationsMap = await storage.scanExistingConversations();
    this.counters.totalExistingConversations = existingConversationsMap.size;
    let processedCount = 0;
    for (const chat of conversationsToProcess) {
      await this.processSingleChat(adapter, chat, existingConversationsMap, importReport, zip, isReprocess);
      processedCount++;
      progressCallback == null ? void 0 : progressCallback({
        phase: "processing",
        title: "Processing conversations...",
        detail: `Processing conversation ${processedCount} of ${conversationsToProcess.length}`,
        current: processedCount,
        total: conversationsToProcess.length
      });
    }
    return importReport;
  }
  async processSingleChat(adapter, chat, existingConversations, importReport, zip, isReprocess = false) {
    try {
      const isStandardConversation = this.isStandardConversation(chat);
      const chatId = isStandardConversation ? chat.id : adapter.getId(chat);
      const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat) || "Untitled";
      if (!chatId || chatId.trim() === "") {
        this.plugin.logger.warn(`Skipping conversation with missing ID: ${chatTitle}`);
        importReport.addFailed(chatTitle, "N/A", 0, 0, "Missing conversation ID");
        return;
      }
      const existingEntry = existingConversations.get(chatId);
      if (existingEntry) {
        await this.handleExistingChat(adapter, chat, existingEntry, importReport, zip, isReprocess, isStandardConversation);
      } else {
        const filePath = await this.generateFilePathForChat(adapter, chat, isStandardConversation);
        await this.handleNewChat(adapter, chat, filePath, importReport, zip, isStandardConversation);
      }
      this.counters.totalConversationsProcessed++;
    } catch (error) {
      const errorMessage = error.message || "Unknown error occurred";
      const isStandardConversation = this.isStandardConversation(chat);
      const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat) || "Untitled";
      importReport.addError(`Error processing chat: ${chatTitle}`, errorMessage);
    }
  }
  /**
   * Check if a chat object is already a StandardConversation
   */
  isStandardConversation(chat) {
    return chat && typeof chat.id === "string" && typeof chat.title === "string" && typeof chat.provider === "string" && typeof chat.createTime === "number" && typeof chat.updateTime === "number" && Array.isArray(chat.messages);
  }
  async handleExistingChat(adapter, chat, existingRecord, importReport, zip, isReprocess = false, isStandardConversation = false) {
    const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat);
    const createTime = isStandardConversation ? chat.createTime : adapter.getCreateTime(chat);
    const updateTime = isStandardConversation ? chat.updateTime : adapter.getUpdateTime(chat);
    const totalMessageCount = await this.countMessages(adapter, chat, isStandardConversation);
    const fileExists = await this.plugin.app.vault.adapter.exists(existingRecord.path);
    if (!fileExists) {
      await this.handleNewChat(adapter, chat, existingRecord.path, importReport, zip, isStandardConversation);
      return;
    }
    if (isReprocess) {
      this.counters.totalExistingConversationsToUpdate++;
      await this.updateExistingNote(adapter, chat, existingRecord.path, totalMessageCount, importReport, zip, true, isStandardConversation);
      return;
    }
    const comparison = compareTimestampsIgnoringSeconds(updateTime, existingRecord.updateTime);
    if (comparison <= 0) {
      importReport.addSkipped(
        chatTitle,
        existingRecord.path,
        createTime,
        updateTime,
        totalMessageCount,
        "No Updates"
      );
    } else {
      this.counters.totalExistingConversationsToUpdate++;
      await this.updateExistingNote(adapter, chat, existingRecord.path, totalMessageCount, importReport, zip, false, isStandardConversation);
    }
  }
  async handleNewChat(adapter, chat, filePath, importReport, zip, isStandardConversation = false) {
    this.counters.totalNewConversationsToImport++;
    await this.createNewNote(adapter, chat, filePath, importReport, zip, isStandardConversation);
  }
  /**
   * Count messages in a chat using provider-specific logic
   */
  async countMessages(adapter, chat, isStandardConversation = false) {
    var _a, _b;
    if (isStandardConversation) {
      return ((_a = chat.messages) == null ? void 0 : _a.length) || 0;
    }
    try {
      const standardConversation = await adapter.convertChat(chat);
      return ((_b = standardConversation.messages) == null ? void 0 : _b.length) || 0;
    } catch (error) {
      if (chat.mapping) {
        return Object.values(chat.mapping).filter((msg) => isValidMessage(msg.message)).length;
      } else if (chat.messages) {
        return Array.isArray(chat.messages) ? chat.messages.length : 0;
      }
      return 0;
    }
  }
  /**
   * Get provider-specific count (artifacts for Claude, attachments for ChatGPT)
   */
  getProviderSpecificCount(adapter, chat) {
    try {
      const strategy = adapter.getReportNamingStrategy();
      if (strategy && strategy.getProviderSpecificColumn) {
        const columnInfo = strategy.getProviderSpecificColumn();
        return columnInfo.getValue(adapter, chat);
      }
    } catch (error) {
    }
    return 0;
  }
  async updateExistingNote(adapter, chat, filePath, totalMessageCount, importReport, zip, forceUpdate = false, isStandardConversation = false) {
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian15.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const originalContent = content;
        const chatUpdateTime = isStandardConversation ? chat.updateTime : adapter.getUpdateTime(chat);
        const chatCreateTime = isStandardConversation ? chat.createTime : adapter.getCreateTime(chat);
        const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat);
        const chatId = isStandardConversation ? chat.id : adapter.getId(chat);
        const existingMessageIds = this.extractMessageUIDsFromNote(content);
        let newMessages;
        if (isStandardConversation) {
          newMessages = chat.messages.filter(
            (msg) => !existingMessageIds.includes(msg.id)
          );
        } else {
          newMessages = adapter.getNewMessages(chat, existingMessageIds);
        }
        let attachmentStats = void 0;
        if (forceUpdate) {
          let standardConversation;
          if (isStandardConversation) {
            standardConversation = chat;
          } else {
            standardConversation = await adapter.convertChat(chat);
          }
          if (zip && adapter.processMessageAttachments) {
            standardConversation.messages = await adapter.processMessageAttachments(
              standardConversation.messages,
              chatId,
              zip
            );
            attachmentStats = this.calculateAttachmentStats(standardConversation.messages);
          }
          const newContent = this.noteFormatter.generateMarkdownContent(standardConversation);
          await this.fileService.writeToFile(filePath, newContent);
          importReport.addUpdated(
            chatTitle,
            filePath,
            chatCreateTime,
            chatUpdateTime,
            totalMessageCount,
            attachmentStats
          );
          this.counters.totalConversationsActuallyUpdated++;
          return;
        }
        if (newMessages.length > 0) {
          content = this.updateMetadata(content, chatUpdateTime);
          let standardConversation;
          if (isStandardConversation) {
            standardConversation = chat;
          } else {
            standardConversation = await adapter.convertChat(chat);
          }
          const newStandardMessages = standardConversation.messages.filter(
            (msg) => newMessages.some((newMsg) => newMsg.id === msg.id)
          );
          let processedNewMessages = newStandardMessages;
          if (zip && adapter.processMessageAttachments) {
            processedNewMessages = await adapter.processMessageAttachments(
              newStandardMessages,
              chatId,
              zip
            );
          }
          attachmentStats = this.calculateAttachmentStats(processedNewMessages);
          content += "\n\n" + this.messageFormatter.formatMessages(processedNewMessages);
          this.counters.totalConversationsActuallyUpdated++;
          this.counters.totalNonEmptyMessagesAdded += newMessages.length;
        }
        if (content !== originalContent) {
          await this.fileService.writeToFile(filePath, content);
          importReport.addUpdated(
            chatTitle,
            filePath,
            chatCreateTime,
            chatUpdateTime,
            newMessages.length,
            attachmentStats
          );
        } else {
          importReport.addSkipped(
            chatTitle,
            filePath,
            chatCreateTime,
            chatUpdateTime,
            totalMessageCount,
            "No changes needed"
          );
        }
      }
    } catch (error) {
      this.plugin.logger.error("Error updating note", error.message);
    }
  }
  async createNewNote(adapter, chat, filePath, importReport, zip, isStandardConversation = false) {
    try {
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
      const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
      if (!folderResult.success) {
        throw new Error(folderResult.error || "Failed to ensure folder exists.");
      }
      let standardConversation;
      if (isStandardConversation) {
        standardConversation = chat;
      } else {
        standardConversation = await adapter.convertChat(chat);
      }
      const chatId = standardConversation.id;
      let attachmentStats = { total: 0, found: 0, missing: 0, failed: 0 };
      if (zip && adapter.processMessageAttachments) {
        standardConversation.messages = await adapter.processMessageAttachments(
          standardConversation.messages,
          chatId,
          zip
        );
        attachmentStats = this.calculateAttachmentStats(standardConversation.messages);
      }
      const content = this.noteFormatter.generateMarkdownContent(standardConversation);
      await this.fileService.writeToFile(filePath, content);
      const messageCount = standardConversation.messages.length;
      const createTime = standardConversation.createTime;
      const updateTime = standardConversation.updateTime;
      const chatTitle = standardConversation.title;
      const providerSpecificCount = this.getProviderSpecificCount(adapter, chat);
      importReport.addCreated(
        chatTitle,
        filePath,
        createTime,
        updateTime,
        messageCount,
        attachmentStats,
        providerSpecificCount
      );
      this.counters.totalNewConversationsSuccessfullyImported++;
      this.counters.totalNonEmptyMessagesToImport += messageCount;
    } catch (error) {
      this.plugin.logger.error("Error creating new note", error.message);
      const createTime = isStandardConversation ? chat.createTime : adapter.getCreateTime(chat);
      const updateTime = isStandardConversation ? chat.updateTime : adapter.getUpdateTime(chat);
      const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat);
      importReport.addFailed(
        chatTitle,
        filePath,
        createTime,
        updateTime,
        error.message
      );
      throw error;
    }
  }
  updateMetadata(content, updateTime) {
    const updateTimeStr = new Date(updateTime * 1e3).toISOString();
    content = content.replace(/^update_time: .*$/m, `update_time: ${updateTimeStr}`);
    content = content.replace(/^Last Updated: .*$/m, `Last Updated: ${updateTimeStr}`);
    return content;
  }
  extractMessageUIDsFromNote(content) {
    const uidRegex = /<!-- UID: (.*?) -->/g;
    const uids = [];
    let match;
    while ((match = uidRegex.exec(content)) !== null) {
      uids.push(match[1]);
    }
    return uids;
  }
  async generateFilePathForChat(adapter, chat, isStandardConversation = false) {
    const createTime = isStandardConversation ? chat.createTime : adapter.getCreateTime(chat);
    const chatTitle = isStandardConversation ? chat.title : adapter.getTitle(chat);
    const providerName = isStandardConversation ? chat.provider : adapter.getProviderName();
    const date = new Date(createTime * 1e3);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const folderPath = `${this.plugin.settings.conversationFolder}/${providerName}/${year}/${month}`;
    const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(folderResult.error || "Failed to ensure folder exists.");
    }
    let fileName = generateConversationFileName(
      chatTitle,
      createTime,
      this.plugin.settings.addDatePrefix,
      this.plugin.settings.dateFormat
    ) + ".md";
    let filePath = `${folderPath}/${fileName}`;
    if (await doesFilePathExist(filePath, this.plugin.app.vault)) {
      filePath = await generateUniqueFileName(filePath, this.plugin.app.vault.adapter);
    }
    return filePath;
  }
  getCounters() {
    return this.counters;
  }
  /**
   * Reset counters for processing a new file
   */
  resetCounters() {
    this.counters = {
      totalExistingConversations: 0,
      totalNewConversationsToImport: 0,
      totalExistingConversationsToUpdate: 0,
      totalNewConversationsSuccessfullyImported: 0,
      totalConversationsActuallyUpdated: 0,
      totalConversationsProcessed: 0,
      totalNonEmptyMessagesToImport: 0,
      totalNonEmptyMessagesToAdd: 0,
      totalNonEmptyMessagesAdded: 0
    };
  }
  /**
   * Calculate attachment statistics from processed messages
   */
  calculateAttachmentStats(messages) {
    var _a, _b, _c;
    const stats = { total: 0, found: 0, missing: 0, failed: 0 };
    for (const message of messages) {
      if (message.attachments) {
        for (const attachment of message.attachments) {
          stats.total++;
          if ((_a = attachment.status) == null ? void 0 : _a.found) {
            stats.found++;
          } else if (((_b = attachment.status) == null ? void 0 : _b.reason) === "missing_from_export") {
            stats.missing++;
          } else if (((_c = attachment.status) == null ? void 0 : _c.reason) === "extraction_failed") {
            stats.failed++;
          }
        }
      }
    }
    return stats;
  }
};
__name(ConversationProcessor, "ConversationProcessor");

// src/models/errors.ts
var NexusAiChatImporterError = class extends Error {
  constructor(message, details) {
    super(message);
    this.details = details;
    this.name = "NexusAiChatImporterError";
  }
};
__name(NexusAiChatImporterError, "NexusAiChatImporterError");

// src/providers/provider-adapter.ts
var DefaultProviderRegistry = class {
  constructor() {
    this.adapters = {};
  }
  register(providerName, adapter) {
    this.adapters[providerName] = adapter;
  }
  getAdapter(provider) {
    return this.adapters[provider];
  }
  detectProvider(rawConversations) {
    for (const [name, adapter] of Object.entries(this.adapters)) {
      try {
        if (adapter.detect(rawConversations))
          return name;
      } catch (_) {
      }
    }
    return "unknown";
  }
};
__name(DefaultProviderRegistry, "DefaultProviderRegistry");

// src/providers/chatgpt/chatgpt-dalle-processor.ts
var ChatGPTDalleProcessor = class {
  /**
   * Extract DALL-E prompts from chat mapping using recursive descendant search
   * Returns both matched prompts (image found) and orphaned prompts (no image found)
   */
  static extractDallePromptsFromMapping(chat) {
    var _a;
    const imagePrompts = /* @__PURE__ */ new Map();
    const orphanedPrompts = /* @__PURE__ */ new Map();
    let promptMessagesFound = 0;
    let promptsWithImages = 0;
    let orphanedPromptsCount = 0;
    for (const messageObj of Object.values(chat.mapping)) {
      const message = messageObj == null ? void 0 : messageObj.message;
      if (!message || ((_a = message.author) == null ? void 0 : _a.role) !== "assistant")
        continue;
      if (this.isDallePromptMessage(message)) {
        promptMessagesFound++;
        const prompt = this.extractPromptFromJson(message);
        if (prompt) {
          const imageMessageId = this.findDalleImageInDescendants(
            chat.mapping,
            messageObj.id || ""
          );
          if (imageMessageId) {
            promptsWithImages++;
            imagePrompts.set(imageMessageId, {
              prompt,
              timestamp: message.create_time || 0
            });
          } else {
            orphanedPromptsCount++;
            orphanedPrompts.set(messageObj.id || "", prompt);
          }
        } else {
        }
      }
    }
    return { imagePrompts, orphanedPrompts };
  }
  /**
   * Recursively search for DALL-E image in descendants
   * Stops at first user message encountered (limit to prevent going too far)
   */
  static findDalleImageInDescendants(mapping, startId) {
    var _a, _b;
    const queue = [startId];
    const visited = /* @__PURE__ */ new Set();
    while (queue.length > 0) {
      const currentId = queue.shift();
      if (visited.has(currentId))
        continue;
      visited.add(currentId);
      const currentObj = mapping[currentId];
      if (!currentObj)
        continue;
      const message = currentObj.message;
      if (((_a = message == null ? void 0 : message.author) == null ? void 0 : _a.role) === "user") {
        return null;
      }
      if (((_b = message == null ? void 0 : message.author) == null ? void 0 : _b.role) === "tool" && this.hasRealDalleImage(message)) {
        return currentId;
      }
      const children = currentObj.children || [];
      queue.push(...children);
    }
    return null;
  }
  /**
   * Check if message is a DALL-E JSON prompt message
   * Handles both formats:
   * - content_type: "text" with parts[0] containing JSON
   * - content_type: "code" with text containing JSON
   *
   * IMPORTANT: Excludes research prompts which also have content_type "code" + "prompt"
   * Research prompts have recipient: "research_kickoff_tool.start_research_task"
   */
  static isDallePromptMessage(message) {
    var _a, _b, _c, _d, _e;
    if (((_a = message.author) == null ? void 0 : _a.role) !== "assistant")
      return false;
    if (message.recipient && typeof message.recipient === "string") {
      if (message.recipient.includes("research_kickoff_tool")) {
        return false;
      }
    }
    if (((_b = message.metadata) == null ? void 0 : _b.async_task_type) === "research") {
      return false;
    }
    if (((_c = message.content) == null ? void 0 : _c.parts) && Array.isArray(message.content.parts) && message.content.parts.length === 1 && typeof message.content.parts[0] === "string") {
      const content = message.content.parts[0].trim();
      if (content.startsWith("{") && content.includes('"prompt"')) {
        return true;
      }
    }
    if (((_d = message.content) == null ? void 0 : _d.content_type) === "code" && ((_e = message.content) == null ? void 0 : _e.text) && typeof message.content.text === "string") {
      const content = message.content.text.trim();
      if (content.startsWith("{") && content.includes('"prompt"')) {
        return true;
      }
    }
    return false;
  }
  /**
   * Extract prompt from DALL-E JSON message
   * Handles both formats:
   * - content_type: "text" with parts[0] containing JSON
   * - content_type: "code" with text containing JSON
   */
  static extractPromptFromJson(message) {
    var _a, _b, _c;
    try {
      let jsonStr = null;
      if (((_a = message.content) == null ? void 0 : _a.parts) && message.content.parts[0]) {
        jsonStr = message.content.parts[0];
      } else if (((_b = message.content) == null ? void 0 : _b.content_type) === "code" && ((_c = message.content) == null ? void 0 : _c.text)) {
        jsonStr = message.content.text;
      }
      if (jsonStr) {
        const parsed = JSON.parse(jsonStr);
        const extractedPrompt = parsed.prompt || null;
        return extractedPrompt;
      }
    } catch (error) {
    }
    return null;
  }
  /**
   * Check if message contains REAL DALL-E image (not user upload)
   */
  static hasRealDalleImage(message) {
    var _a;
    if (!((_a = message.content) == null ? void 0 : _a.parts) || !Array.isArray(message.content.parts)) {
      return false;
    }
    return message.content.parts.some((part) => {
      var _a2;
      if (typeof part !== "object" || part === null)
        return false;
      const contentPart = part;
      return contentPart.content_type === "image_asset_pointer" && contentPart.asset_pointer && ((_a2 = contentPart.metadata) == null ? void 0 : _a2.dalle) && contentPart.metadata.dalle !== null;
    });
  }
  /**
   * Create StandardAttachment for DALL-E image with provider-agnostic metadata
   * The prompt will be embedded in extractedContent for display
   */
  static createDalleAttachment(contentPart, associatedPrompt, hasImage = true) {
    const fileId = contentPart.asset_pointer.includes("://") ? contentPart.asset_pointer.split("://")[1] : contentPart.asset_pointer;
    const genId = contentPart.metadata.dalle.gen_id || "unknown";
    const width = contentPart.width || 1024;
    const height = contentPart.height || 1024;
    const fileName = `dalle_${genId}_${width}x${height}.png`;
    const prompt = associatedPrompt || contentPart.metadata.dalle.prompt;
    let extractedContent = "";
    if (prompt) {
      const formattedPrompt = prompt.split("\n").join("\n>> ");
      extractedContent = `>>[!nexus_prompt] **DALL-E Prompt**
>> \`\`\`
>> ${formattedPrompt}
>> \`\`\`
>
>>[!nexus_attachment] **{{FILENAME}}** ({{FILETYPE}}) - {{FILESIZE}}
>> ![[{{URL}}]]`;
      if (!hasImage) {
        extractedContent = `>>[!nexus_prompt] **DALL-E Prompt**
>> \`\`\`
>> ${formattedPrompt}
>> \`\`\`
>
>>[!nexus_attachment] **Image Not Found**
>> \u26A0\uFE0F Image could not be found. Perhaps it was not generated or is missing from the archive.`;
      }
    } else {
    }
    return {
      fileName,
      fileSize: contentPart.size_bytes,
      fileType: "image/png",
      // Will be corrected dynamically by extractor
      fileId,
      extractedContent,
      // Provider-agnostic metadata
      attachmentType: "generated_image",
      generationPrompt: prompt,
      // Provider-specific metadata
      providerMetadata: {
        dalle: {
          gen_id: contentPart.metadata.dalle.gen_id,
          seed: contentPart.metadata.dalle.seed,
          parent_gen_id: contentPart.metadata.dalle.parent_gen_id,
          edit_op: contentPart.metadata.dalle.edit_op
        }
      }
    };
  }
  /**
   * Create Assistant (DALL-E) message from tool message with associated prompt
   */
  static createDalleAssistantMessage(toolMessage, associatedPrompt, promptTimestamp) {
    var _a, _b;
    if (!((_a = toolMessage.content) == null ? void 0 : _a.parts) || !Array.isArray(toolMessage.content.parts)) {
      return null;
    }
    const attachments = [];
    for (const part of toolMessage.content.parts) {
      if (typeof part === "object" && part !== null) {
        const contentPart = part;
        if (contentPart.content_type === "image_asset_pointer" && contentPart.asset_pointer && ((_b = contentPart.metadata) == null ? void 0 : _b.dalle) && contentPart.metadata.dalle !== null) {
          const dalleAttachment = this.createDalleAttachment(contentPart, associatedPrompt, true);
          attachments.push(dalleAttachment);
        }
      }
    }
    if (attachments.length === 0) {
      return null;
    }
    return {
      id: toolMessage.id || "",
      role: "assistant",
      content: "DALL-E Generated Image",
      // Use prompt timestamp if available, otherwise fall back to tool message timestamp
      timestamp: promptTimestamp || toolMessage.create_time || 0,
      attachments
    };
  }
  /**
   * Create informational message for orphaned DALL-E prompt (no image found)
   * Creates a "phantom" attachment with the prompt and warning
   */
  static createOrphanedPromptMessage(promptMessage, prompt) {
    const formattedPrompt = prompt.split("\n").join("\n>> ");
    const phantomAttachment = {
      fileName: "dalle_image_not_found.png",
      fileType: "image/png",
      attachmentType: "generated_image",
      generationPrompt: prompt,
      extractedContent: `>>[!nexus_prompt] **DALL-E Prompt** (Image Generation Failed or Interrupted)
>> \`\`\`
>> ${formattedPrompt}
>> \`\`\`
>
>>[!nexus_attachment] **Image Not Found**
>> \u26A0\uFE0F Image generation may have failed or been interrupted. The prompt was saved but no image was found in the export.`,
      status: {
        processed: true,
        found: false,
        reason: "missing_from_export",
        note: "DALL-E generation was requested but the image was not found in the archive"
      }
    };
    return {
      id: promptMessage.id || "",
      role: "assistant",
      content: "DALL-E Image Generation (Failed/Interrupted)",
      timestamp: promptMessage.create_time || 0,
      attachments: [phantomAttachment]
    };
  }
};
__name(ChatGPTDalleProcessor, "ChatGPTDalleProcessor");

// src/providers/chatgpt/chatgpt-message-filter.ts
init_utils();
var ChatGPTMessageFilter = class {
  /**
   * Determine if a message should be included in the conversation
   */
  static shouldIncludeMessage(message) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!message || !message.author) {
      return false;
    }
    if (message.author.role === "system") {
      return false;
    }
    if (message.author.role === "tool") {
      return false;
    }
    if (((_a = message.metadata) == null ? void 0 : _a.is_visually_hidden_from_conversation) === true) {
      return false;
    }
    if (((_b = message.metadata) == null ? void 0 : _b.is_user_system_message) === true) {
      return false;
    }
    if (((_c = message.content) == null ? void 0 : _c.content_type) === "user_editable_context") {
      return false;
    }
    if (message.author.role === "assistant") {
      if (((_d = message.content) == null ? void 0 : _d.parts) && Array.isArray(message.content.parts) && message.content.parts.every(
        (part) => typeof part === "string" && part.trim() === ""
      )) {
        return false;
      }
      if (ChatGPTDalleProcessor.isDallePromptMessage(message)) {
        return false;
      }
      const excludedContentTypes = ["code", "system_error", "execution_output"];
      if (((_e = message.content) == null ? void 0 : _e.content_type) && excludedContentTypes.includes(message.content.content_type)) {
        return false;
      }
      if (((_f = message.content) == null ? void 0 : _f.content_type) === "multimodal_text") {
        if (((_g = message.content) == null ? void 0 : _g.parts) && Array.isArray(message.content.parts)) {
          const hasTextContent = message.content.parts.some((part) => {
            if (typeof part === "string" && part.trim() !== "") {
              return true;
            }
            if (typeof part === "object" && part !== null && "text" in part) {
              return typeof part.text === "string" && part.text.trim() !== "";
            }
            return false;
          });
          if (!hasTextContent) {
            return false;
          }
        }
      }
    }
    if (message.author.role === "user") {
      const excludedContentTypes = ["user_editable_context"];
      if (((_h = message.content) == null ? void 0 : _h.content_type) && excludedContentTypes.includes(message.content.content_type)) {
        return false;
      }
    }
    return isValidMessage(message);
  }
};
__name(ChatGPTMessageFilter, "ChatGPTMessageFilter");

// src/utils/message-utils.ts
function sortMessagesByTimestamp(messages) {
  if (messages.length <= 1) {
    return messages;
  }
  return messages.sort((a, b) => {
    if (a.timestamp !== b.timestamp) {
      return a.timestamp - b.timestamp;
    }
    return a.id.localeCompare(b.id);
  });
}
__name(sortMessagesByTimestamp, "sortMessagesByTimestamp");

// src/providers/chatgpt/chatgpt-converter.ts
var ChatGPTConverter = class {
  /**
   * Convert ChatGPT Chat to StandardConversation
   */
  static convertChat(chat) {
    const messages = this.extractMessagesFromMapping(chat);
    return {
      id: chat.id || "",
      title: chat.title || "Untitled",
      provider: "chatgpt",
      createTime: chat.create_time || 0,
      updateTime: chat.update_time || 0,
      messages,
      metadata: {
        conversation_template_id: chat.conversation_template_id,
        gizmo_id: chat.gizmo_id,
        gizmo_type: chat.gizmo_type,
        default_model_slug: chat.default_model_slug,
        is_archived: chat.is_archived,
        is_starred: chat.is_starred,
        current_node: chat.current_node,
        memory_scope: chat.memory_scope
      }
    };
  }
  /**
   * Convert single ChatGPT ChatMessage to StandardMessage
   */
  static convertMessage(chatMessage, conversationId) {
    var _a;
    const contentResult = this.extractContent(chatMessage, conversationId);
    return {
      id: chatMessage.id || "",
      role: ((_a = chatMessage.author) == null ? void 0 : _a.role) === "user" ? "user" : "assistant",
      content: contentResult.content,
      timestamp: chatMessage.create_time || 0,
      attachments: contentResult.attachments || []
    };
  }
  /**
   * Extract messages from ChatGPT mapping structure with DALL-E prompt association
   */
  static extractMessagesFromMapping(chat) {
    var _a;
    const messages = [];
    const conversationId = chat.id;
    const { imagePrompts, orphanedPrompts } = ChatGPTDalleProcessor.extractDallePromptsFromMapping(chat);
    for (const messageObj of Object.values(chat.mapping)) {
      const message = messageObj == null ? void 0 : messageObj.message;
      if (!message)
        continue;
      if (((_a = message.author) == null ? void 0 : _a.role) === "tool" && ChatGPTDalleProcessor.hasRealDalleImage(message)) {
        const promptData = imagePrompts.get(messageObj.id || "");
        const dalleMessage = ChatGPTDalleProcessor.createDalleAssistantMessage(
          message,
          promptData == null ? void 0 : promptData.prompt,
          promptData == null ? void 0 : promptData.timestamp
        );
        if (dalleMessage) {
          messages.push(dalleMessage);
        }
      } else if (orphanedPrompts.has(messageObj.id || "")) {
        const prompt = orphanedPrompts.get(messageObj.id || "");
        if (prompt) {
          const orphanedMessage = ChatGPTDalleProcessor.createOrphanedPromptMessage(message, prompt);
          messages.push(orphanedMessage);
        }
      } else if (ChatGPTMessageFilter.shouldIncludeMessage(message)) {
        messages.push(this.convertMessage(message, conversationId));
      }
    }
    if (messages.length <= 1)
      return messages;
    return sortMessagesByTimestamp(messages);
  }
  /**
   * Extract content and attachments from ChatGPT message parts
   */
  static extractContent(chatMessage, conversationId) {
    var _a;
    if (!((_a = chatMessage.content) == null ? void 0 : _a.parts) || !Array.isArray(chatMessage.content.parts)) {
      return { content: "" };
    }
    const contentParts = [];
    const attachments = [];
    for (const part of chatMessage.content.parts) {
      let textContent = "";
      if (typeof part === "string" && part.trim() !== "") {
        if (part.trim().startsWith("{") && part.trim().endsWith("}")) {
          try {
            const parsed = JSON.parse(part);
            if (parsed.type && parsed.content && typeof parsed.content === "string") {
              const codeType = parsed.type;
              const codeContent = parsed.content;
              if (codeContent.trim() !== "") {
                const language = codeType.includes("/") ? codeType.split("/")[1] : codeType;
                textContent = `\`\`\`${language}
${codeContent}
\`\`\``;
              }
            } else {
              textContent = part;
            }
          } catch (e) {
            textContent = part;
          }
        } else {
          textContent = part;
        }
      } else if (typeof part === "object" && part !== null) {
        if ("type" in part && "content" in part && typeof part.content === "string") {
          const codeType = part.type;
          const codeContent = part.content;
          if (codeContent.trim() !== "") {
            const language = codeType.includes("/") ? codeType.split("/")[1] : codeType;
            textContent = `\`\`\`${language}
${codeContent}
\`\`\``;
          }
        } else if ("content_type" in part && "text" in part && typeof part.text === "string") {
          if (part.content_type === "audio_transcription" && part.text.trim() !== "") {
            textContent = part.text;
          } else if (part.content_type === "text" && part.text.trim() !== "") {
            textContent = part.text;
          } else if (part.content_type === "multimodal_text" && part.text.trim() !== "") {
            textContent = part.text;
          }
        } else if ("content_type" in part && part.content_type === "image_asset_pointer" && "asset_pointer" in part) {
          const attachment = this.extractImageAttachment(part, conversationId);
          if (attachment) {
            attachments.push(attachment);
          }
        }
      }
      if (textContent) {
        textContent = this.cleanChatGPTArtifacts(textContent, conversationId);
        if (textContent.trim() !== "") {
          contentParts.push(textContent);
        }
      }
    }
    const finalContent = contentParts.join("\n");
    if (chatMessage.attachments) {
      for (const att of chatMessage.attachments) {
        attachments.push({
          fileName: att.file_name,
          fileType: att.file_type || "application/octet-stream",
          fileSize: att.file_size,
          extractedContent: att.extracted_content
        });
      }
    }
    return {
      content: finalContent,
      attachments: attachments.length > 0 ? attachments : void 0
    };
  }
  /**
   * Extract image attachment from content part
   */
  static extractImageAttachment(part, conversationId) {
    var _a;
    if (!part.asset_pointer)
      return null;
    let fileId = part.asset_pointer;
    if (fileId.includes("://")) {
      fileId = fileId.split("://")[1];
    }
    let fileName = `image_${fileId}`;
    if (part.width && part.height) {
      fileName = `image_${fileId}_${part.width}x${part.height}`;
    }
    const fileType = ((_a = part.metadata) == null ? void 0 : _a.mime_type) || "image/png";
    const extension = fileType.split("/")[1] || "png";
    fileName += `.${extension}`;
    return {
      fileName,
      fileType,
      fileSize: part.size_bytes,
      fileId
    };
  }
  /**
   * Clean ChatGPT artifacts, citations, and control characters - SMART LINKING
   */
  static cleanChatGPTArtifacts(text, conversationId) {
    if (!text || typeof text !== "string")
      return "";
    const chatUrl = conversationId ? `https://chatgpt.com/c/${conversationId}` : "https://chatgpt.com";
    let cleanText = text;
    for (const { pattern, replacement } of this.CLEANUP_PATTERNS) {
      cleanText = cleanText.replace(pattern, replacement(chatUrl));
    }
    return cleanText.trim();
  }
};
__name(ChatGPTConverter, "ChatGPTConverter");
// Pre-compiled regex patterns for performance
ChatGPTConverter.CLEANUP_PATTERNS = [
  // SMART: Replace sandbox links with actual links to original conversation
  { pattern: /📄 \[([^\]]+)\]\(sandbox:\/[^)]+\)/g, replacement: (chatUrl) => `\u{1F4C4} [$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /📄 ([^-\n]+) - File not available in archive/g, replacement: (chatUrl) => `\u{1F4C4} [$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /\[([^\]]+)\]\(sandbox:\/[^)]+\)/g, replacement: (chatUrl) => `[$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /([^-\n]+) - File not available in archive\. Visit the original conversation to access it/g, replacement: (chatUrl) => `[$1](${chatUrl}) *(visit original conversation to download)*` },
  // Remove patterns (static replacements)
  { pattern: /cite[a-zA-Z0-9_\-]+/g, replacement: () => "" },
  { pattern: /link[a-zA-Z0-9_\-]+/g, replacement: () => "" },
  { pattern: /turn\d+search\d+/g, replacement: () => "" },
  { pattern: /[\uE000-\uF8FF]/g, replacement: () => "" },
  // Unicode control characters
  { pattern: / {2,}/g, replacement: () => " " },
  // Multiple spaces
  { pattern: /\n{3,}/g, replacement: () => "\n\n" }
  // Multiple newlines
];

// src/providers/chatgpt/chatgpt-attachment-extractor.ts
init_utils();
var ChatGPTAttachmentExtractor = class {
  // All opened ZIPs for multi-ZIP fallback
  constructor(plugin, logger6) {
    this.plugin = plugin;
    this.logger = logger6;
    this.zipFileCache = /* @__PURE__ */ new Map();
    // Cache for ZIP file lookups
    this.attachmentMap = null;
    // Multi-ZIP attachment map
    this.allZips = [];
  }
  /**
   * Set attachment map for multi-ZIP support
   * This enables fallback to older ZIPs when files are missing in recent exports
   */
  setAttachmentMap(attachmentMap, allZips) {
    this.attachmentMap = attachmentMap;
    this.allZips = allZips;
  }
  /**
   * Clear attachment map and ZIPs (call after import completes)
   */
  clearAttachmentMap() {
    this.attachmentMap = null;
    this.allZips = [];
    this.zipFileCache.clear();
  }
  /**
   * Extract and save ChatGPT attachments using "best effort" strategy
   * - If file exists in ZIP: extract and link
   * - If file missing: create informative note
   */
  async extractAttachments(zip, conversationId, attachments, messageId) {
    if (attachments.length === 0) {
      return attachments.map((att) => ({ ...att, status: { processed: false, found: false } }));
    }
    const processedAttachments = [];
    for (const attachment of attachments) {
      try {
        const result = await this.processAttachmentBestEffort(zip, conversationId, attachment, messageId);
        processedAttachments.push(result);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const context = messageId ? `conversation: ${conversationId}, message: ${messageId}` : `conversation: ${conversationId}`;
        this.logger.error(`Failed to process ChatGPT attachment: ${attachment.fileName} (${context})`, errorMessage);
        processedAttachments.push({
          ...attachment,
          status: {
            processed: false,
            found: false,
            reason: "extraction_failed",
            note: `Processing failed: ${errorMessage}`
          }
        });
      }
    }
    return processedAttachments;
  }
  /**
   * Process single attachment with best effort strategy
   */
  async processAttachmentBestEffort(zip, conversationId, attachment, messageId) {
    const zipFile = await this.findChatGPTFileById(zip, attachment, conversationId, messageId);
    if (!zipFile) {
      let finalExtractedContent = attachment.extractedContent;
      if (attachment.attachmentType === "generated_image" && attachment.extractedContent) {
        finalExtractedContent = attachment.extractedContent.replace(
          />>\[!nexus_attachment\] \*\*\{\{FILENAME\}\}\*\* \(\{\{FILETYPE\}\}\) - \{\{FILESIZE\}\}\n>> !\[\[\{\{URL\}\}\]\]/,
          ">>[!nexus_attachment] **Image Not Found**\n>> \u26A0\uFE0F Image could not be found. Perhaps it was not generated or is missing from the archive."
        );
      }
      return {
        ...attachment,
        extractedContent: finalExtractedContent,
        url: attachment.url || `https://chatgpt.com/c/${conversationId}`,
        status: {
          processed: true,
          found: false,
          reason: "missing_from_export"
        }
      };
    }
    try {
      const extractResult = await this.extractSingleAttachment(zip, conversationId, attachment, zipFile);
      if (extractResult) {
        let finalExtractedContent = attachment.extractedContent;
        if (attachment.attachmentType === "generated_image" && attachment.extractedContent) {
          finalExtractedContent = attachment.extractedContent.replace("{{FILENAME}}", extractResult.finalFileName).replace("{{FILETYPE}}", extractResult.actualFileType).replace("{{FILESIZE}}", formatFileSize(attachment.fileSize || 0)).replace("{{URL}}", extractResult.localPath);
        }
        return {
          ...attachment,
          fileName: extractResult.finalFileName,
          // Update with actual extracted filename
          fileType: extractResult.actualFileType,
          // Update with detected file type
          url: extractResult.localPath,
          extractedContent: finalExtractedContent,
          // Update with replaced placeholders
          status: {
            processed: true,
            found: true,
            localPath: extractResult.localPath
          }
        };
      } else {
        let finalExtractedContent = attachment.extractedContent;
        if (attachment.attachmentType === "generated_image" && attachment.extractedContent) {
          finalExtractedContent = attachment.extractedContent.replace(
            />>\[!nexus_attachment\] \*\*\{\{FILENAME\}\}\*\* \(\{\{FILETYPE\}\}\) - \{\{FILESIZE\}\}\n>> !\[\[\{\{URL\}\}\]\]/,
            ">>[!nexus_attachment] **Image Not Found**\n>> \u26A0\uFE0F File was found in export but could not be extracted to disk."
          );
        }
        return {
          ...attachment,
          extractedContent: finalExtractedContent,
          status: {
            processed: true,
            found: false,
            reason: "extraction_failed",
            note: "File was found in export but could not be extracted to disk."
          }
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const context = messageId ? `conversation: ${conversationId}, message: ${messageId}` : `conversation: ${conversationId}`;
      this.logger.error(`Error extracting ChatGPT attachment: ${attachment.fileName} (${context})`, errorMessage);
      let finalExtractedContent = attachment.extractedContent;
      if (attachment.attachmentType === "generated_image" && attachment.extractedContent) {
        finalExtractedContent = attachment.extractedContent.replace(
          />>\[!nexus_attachment\] \*\*\{\{FILENAME\}\}\*\* \(\{\{FILETYPE\}\}\) - \{\{FILESIZE\}\}\n>> !\[\[\{\{URL\}\}\]\]/,
          `>>[!nexus_attachment] **Extraction Failed**
>> \u26A0\uFE0F ${errorMessage}`
        );
      }
      return {
        ...attachment,
        extractedContent: finalExtractedContent,
        status: {
          processed: true,
          found: true,
          // File exists but extraction failed
          reason: "extraction_failed",
          note: `Extraction failed: ${errorMessage}`
        }
      };
    }
  }
  /**
   * Extract single attachment to disk with conflict resolution and format detection
   */
  async extractSingleAttachment(zip, conversationId, attachment, zipFile) {
    const fileContent = await zipFile.async("uint8array");
    const formatInfo = detectFileFormat(fileContent);
    let finalFileName = attachment.fileName;
    let finalFileType = attachment.fileType;
    if (attachment.attachmentType === "generated_image" && formatInfo.extension) {
      const baseName = attachment.fileName.replace(/\.(dat|png|jpg|jpeg|gif|webp)$/i, "");
      finalFileName = `${baseName}.${formatInfo.extension}`;
      finalFileType = formatInfo.mimeType || attachment.fileType;
    }
    let targetPath = this.generateLocalPath(conversationId, {
      ...attachment,
      fileName: finalFileName,
      fileType: finalFileType
    });
    const folderPath = targetPath.substring(0, targetPath.lastIndexOf("/"));
    const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create ChatGPT attachment folder: ${folderResult.error}`);
    }
    targetPath = await this.resolveFileConflict(targetPath);
    await this.plugin.app.vault.adapter.writeBinary(targetPath, fileContent.buffer);
    return {
      localPath: targetPath,
      finalFileName,
      actualFileType: finalFileType || "application/octet-stream"
    };
  }
  /**
   * Resolve file conflicts by adding numeric suffix
   */
  async resolveFileConflict(originalPath) {
    let finalPath = originalPath;
    let counter = 1;
    while (await this.plugin.app.vault.adapter.exists(finalPath)) {
      const lastDot = originalPath.lastIndexOf(".");
      if (lastDot === -1) {
        finalPath = `${originalPath}_${counter}`;
      } else {
        const nameWithoutExt = originalPath.substring(0, lastDot);
        const extension = originalPath.substring(lastDot);
        finalPath = `${nameWithoutExt}_${counter}${extension}`;
      }
      counter++;
    }
    return finalPath;
  }
  /**
   * Find file in ZIP - ENHANCED WITH MULTI-ZIP FALLBACK + COMPREHENSIVE SEARCH + CACHING
   */
  async findChatGPTFileById(zip, attachment, conversationId, messageId) {
    if (!attachment.fileId) {
      const context = conversationId && messageId ? `conversation: ${conversationId}, message: ${messageId}` : conversationId ? `conversation: ${conversationId}` : "unknown context";
      this.logger.warn(`No fileId provided for attachment: ${attachment.fileName} (${context})`);
      const zipFile2 = zip.file(attachment.fileName);
      if (zipFile2) {
        return zipFile2;
      }
      return null;
    }
    const cacheKey = `${attachment.fileId}_${attachment.fileName}`;
    if (this.zipFileCache.has(cacheKey)) {
      return this.zipFileCache.get(cacheKey);
    }
    if (this.attachmentMap && this.allZips.length > 0) {
      const result = await this.findFileUsingAttachmentMap(attachment, conversationId, messageId);
      if (result) {
        this.zipFileCache.set(cacheKey, result);
        return result;
      }
    }
    let zipFile = zip.file(attachment.fileName);
    if (zipFile) {
      this.zipFileCache.set(cacheKey, zipFile);
      return zipFile;
    }
    if (attachment.fileName.startsWith("dalle_")) {
      const dalleFiles = await this.searchDalleGenerations(zip, attachment.fileId);
      if (dalleFiles.length > 0) {
        this.zipFileCache.set(cacheKey, dalleFiles[0]);
        return dalleFiles[0];
      }
    }
    const fileIdPattern = `${attachment.fileId}-${attachment.fileName}`;
    zipFile = zip.file(fileIdPattern);
    if (zipFile) {
      this.zipFileCache.set(cacheKey, zipFile);
      return zipFile;
    }
    const extension = this.getFileExtension(attachment.fileName);
    if (extension) {
      const fileIdExtPattern = `${attachment.fileId}.${extension}`;
      zipFile = zip.file(fileIdExtPattern);
      if (zipFile) {
        this.zipFileCache.set(cacheKey, zipFile);
        return zipFile;
      }
    }
    const foundFile = await this.searchZipByFileId(zip, attachment.fileId);
    this.zipFileCache.set(cacheKey, foundFile);
    return foundFile;
  }
  /**
   * Search entire ZIP for file by exact ID with enhanced DALL-E support
   */
  async searchZipByFileId(zip, fileId) {
    for (const [path, file] of Object.entries(zip.files)) {
      if (file.dir)
        continue;
      if (path.includes(fileId)) {
        return file;
      }
      const fileName = path.split("/").pop() || "";
      if (fileName.includes(fileId) || fileName.startsWith(`file-${fileId}`) || fileName.startsWith(fileId)) {
        return file;
      }
    }
    return null;
  }
  /**
   * Find file using attachment map (multi-ZIP fallback)
   * Tries to find the file in any of the available ZIPs, preferring newer exports
   */
  async findFileUsingAttachmentMap(attachment, conversationId, messageId) {
    if (!this.attachmentMap || this.allZips.length === 0) {
      return null;
    }
    const context = conversationId && messageId ? `conversation: ${conversationId}, message: ${messageId}` : conversationId ? `conversation: ${conversationId}` : "unknown context";
    const fileId = attachment.fileId || "";
    if (!fileId) {
      return null;
    }
    const locations = this.attachmentMap.get(fileId);
    if (!locations || locations.length === 0) {
      const alternativeIds = this.getAlternativeFileIds(fileId);
      for (const altId of alternativeIds) {
        const altLocations = this.attachmentMap.get(altId);
        if (altLocations && altLocations.length > 0) {
          return this.getFileFromLocation(altLocations[altLocations.length - 1]);
        }
      }
      return null;
    }
    const bestLocation = locations[locations.length - 1];
    return this.getFileFromLocation(bestLocation);
  }
  /**
   * Get alternative file ID formats for fallback matching
   */
  getAlternativeFileIds(fileId) {
    const alternatives = [];
    if (fileId.startsWith("file_")) {
      alternatives.push(fileId.substring(5));
    } else if (!fileId.startsWith("file-")) {
      alternatives.push(`file_${fileId}`);
    }
    if (fileId.includes("_")) {
      alternatives.push(fileId.replace(/_/g, "-"));
    }
    if (fileId.includes("-")) {
      alternatives.push(fileId.replace(/-/g, "_"));
    }
    return alternatives;
  }
  /**
   * Get JSZip file object from attachment location
   */
  getFileFromLocation(location) {
    if (location.zipIndex >= this.allZips.length) {
      this.logger.error(`Invalid ZIP index ${location.zipIndex} (only ${this.allZips.length} ZIPs available)`);
      return null;
    }
    const zip = this.allZips[location.zipIndex];
    const zipFile = zip.file(location.path);
    if (!zipFile) {
      this.logger.error(`File not found in ZIP ${location.zipIndex}: ${location.path}`);
      return null;
    }
    return zipFile;
  }
  /**
   * Search specifically in dalle-generations/ folder (restored from v1.2.0)
   */
  async searchDalleGenerations(zip, fileId) {
    const matches = [];
    for (const [path, file] of Object.entries(zip.files)) {
      if (!file.dir && path.toLowerCase().includes("dalle")) {
        if (path.includes(fileId) || path.includes(fileId.replace("file_", "")) || path.includes(fileId.replace("file-", ""))) {
          matches.push(file);
        }
      }
    }
    return matches;
  }
  /**
   * Get file extension from filename (restored from v1.2.0)
   */
  getFileExtension(fileName) {
    const lastDot = fileName.lastIndexOf(".");
    return lastDot === -1 ? "" : fileName.substring(lastDot + 1).toLowerCase();
  }
  /**
   * Generate local path for ChatGPT attachment using attachmentFolder setting
   */
  generateLocalPath(conversationId, attachment) {
    const category = this.categorizeFile(attachment);
    const safeFileName = sanitizeFileName(attachment.fileName);
    return `${this.plugin.settings.attachmentFolder}/chatgpt/${category}/${safeFileName}`;
  }
  /**
   * Categorize file based on MIME type or extension
   */
  categorizeFile(attachment) {
    if (attachment.fileType) {
      if (attachment.fileType.startsWith("image/"))
        return "images";
      if (attachment.fileType.startsWith("audio/"))
        return "audio";
      if (attachment.fileType.startsWith("video/"))
        return "video";
      if (attachment.fileType === "application/pdf")
        return "documents";
      if (attachment.fileType.includes("text/") || attachment.fileType.includes("markdown"))
        return "documents";
    }
    const ext = this.plugin.getFileService().getFileExtension(attachment.fileName);
    const audioExts = ["wav", "mp3", "ogg", "m4a", "flac"];
    const imageExts = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
    const docExts = ["pdf", "doc", "docx", "txt", "md", "rtf"];
    const videoExts = ["mp4", "avi", "mov", "mkv"];
    if (audioExts.includes(ext))
      return "audio";
    if (imageExts.includes(ext))
      return "images";
    if (docExts.includes(ext))
      return "documents";
    if (videoExts.includes(ext))
      return "video";
    return "files";
  }
  /**
   * Clear ZIP file cache (call between different ZIP files)
   */
  clearCache() {
    this.zipFileCache.clear();
  }
  /**
   * Get attachment processing statistics
   */
  getStatistics(attachments) {
    return {
      total: attachments.length,
      found: attachments.filter((a) => {
        var _a, _b;
        return ((_a = a.status) == null ? void 0 : _a.found) && ((_b = a.status) == null ? void 0 : _b.processed);
      }).length,
      missing: attachments.filter((a) => {
        var _a, _b;
        return !((_a = a.status) == null ? void 0 : _a.found) && ((_b = a.status) == null ? void 0 : _b.reason) === "missing_from_export";
      }).length,
      failed: attachments.filter((a) => {
        var _a;
        return ((_a = a.status) == null ? void 0 : _a.reason) === "extraction_failed";
      }).length
    };
  }
};
__name(ChatGPTAttachmentExtractor, "ChatGPTAttachmentExtractor");

// src/utils/report-naming-utils.ts
function getCurrentImportDate() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  return `${year}.${month}.${day}`;
}
__name(getCurrentImportDate, "getCurrentImportDate");
function extractArchiveDateFromFilename(fileName, patterns) {
  for (const pattern of patterns) {
    const match = fileName.match(pattern);
    if (match && match.length >= 4) {
      const [, year, month, day] = match;
      return `${year}.${month}.${day}`;
    }
  }
  return null;
}
__name(extractArchiveDateFromFilename, "extractArchiveDateFromFilename");
function generateReportPrefix(importDate, archiveDate) {
  return `imported-${importDate}-archive-${archiveDate}`;
}
__name(generateReportPrefix, "generateReportPrefix");
function extractReportPrefixFromZip(zipFileName, patterns) {
  const importDate = getCurrentImportDate();
  const archiveDate = extractArchiveDateFromFilename(zipFileName, patterns);
  const finalArchiveDate = archiveDate || importDate;
  return generateReportPrefix(importDate, finalArchiveDate);
}
__name(extractReportPrefixFromZip, "extractReportPrefixFromZip");

// src/providers/chatgpt/chatgpt-report-naming.ts
var ChatGPTReportNamingStrategy = class {
  /**
   * Extract date prefix from ChatGPT ZIP filename
   * Examples:
   * - "3b00abafb9222a9580aa7cbb198166ed0c61634222cce9571bb079a2886aeed5-2025-04-25-14-40-42-ff19c2fd898d44d9bc5945ee80c199ca.zip"
   * - "chatgpt-export-2025-04-25.zip"
   * - "conversations-2025-04-25-14-40-42.zip"
   */
  extractReportPrefix(zipFileName) {
    const patterns = [/(\d{4})-(\d{2})-(\d{2})/];
    return extractReportPrefixFromZip(zipFileName, patterns);
  }
  /**
   * Get ChatGPT provider name
   */
  getProviderName() {
    return "chatgpt";
  }
  getProviderSpecificColumn() {
    return {
      header: "Attachments",
      getValue: (adapter, chat) => {
        let attachmentCount = 0;
        if (chat.mapping) {
          Object.values(chat.mapping).forEach((node) => {
            var _a, _b, _c, _d;
            if ((_b = (_a = node.message) == null ? void 0 : _a.metadata) == null ? void 0 : _b.attachments) {
              attachmentCount += node.message.metadata.attachments.length;
            }
            if ((_d = (_c = node.message) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) {
              node.message.content.parts.forEach((part) => {
                var _a2;
                if (part.content_type === "image_asset_pointer" && part.asset_pointer && ((_a2 = part.metadata) == null ? void 0 : _a2.dalle) && part.metadata.dalle !== null) {
                  attachmentCount++;
                }
              });
            }
          });
        }
        return attachmentCount;
      }
    };
  }
};
__name(ChatGPTReportNamingStrategy, "ChatGPTReportNamingStrategy");

// src/providers/base/base-provider-adapter.ts
var BaseProviderAdapter = class {
  /**
   * Process message attachments - COMMON IMPLEMENTATION
   * 
   * This method is shared by all providers and handles:
   * - Iterating through messages
   * - Extracting attachments using provider-specific extractor
   * - Preserving message structure
   * 
   * Subclasses only need to provide their attachment extractor via getAttachmentExtractor()
   * 
   * @param messages - Array of messages to process
   * @param conversationId - ID of the conversation
   * @param zip - JSZip instance containing attachments
   * @returns Array of messages with processed attachments
   */
  async processMessageAttachments(messages, conversationId, zip) {
    const processedMessages = [];
    for (const message of messages) {
      if (message.attachments && message.attachments.length > 0) {
        const processedAttachments = await this.getAttachmentExtractor().extractAttachments(
          zip,
          conversationId,
          message.attachments,
          message.id
          // Pass message ID for better logging (optional parameter)
        );
        processedMessages.push({
          ...message,
          attachments: processedAttachments
        });
      } else {
        processedMessages.push(message);
      }
    }
    return processedMessages;
  }
  /**
   * Default ZIP entry filter — include everything.
   * Provider subclasses may override to skip large unwanted entries
   * (e.g. ChatGPT voice-recording DAT files) before they are loaded into RAM.
   */
  shouldIncludeZipEntry(_entryName, _uncompressedSize) {
    return true;
  }
};
__name(BaseProviderAdapter, "BaseProviderAdapter");

// src/providers/chatgpt/chatgpt-adapter.ts
var ChatGPTAdapter = class extends BaseProviderAdapter {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.attachmentExtractor = new ChatGPTAttachmentExtractor(plugin, plugin.logger);
    this.reportNamingStrategy = new ChatGPTReportNamingStrategy();
  }
  detect(rawConversations) {
    if (rawConversations.length === 0)
      return false;
    const sample = rawConversations[0];
    return !!(sample.mapping && sample.create_time && sample.update_time && sample.title);
  }
  getId(chat) {
    return chat.id || "";
  }
  getTitle(chat) {
    return chat.title || "Untitled";
  }
  getCreateTime(chat) {
    return chat.create_time || 0;
  }
  getUpdateTime(chat) {
    return chat.update_time || 0;
  }
  convertChat(chat) {
    return ChatGPTConverter.convertChat(chat);
  }
  getProviderName() {
    return "chatgpt";
  }
  getNewMessages(chat, existingMessageIds) {
    var _a, _b;
    const newMessages = [];
    const { imagePrompts, orphanedPrompts } = ChatGPTDalleProcessor.extractDallePromptsFromMapping(chat);
    for (const messageObj of Object.values(chat.mapping)) {
      if ((messageObj == null ? void 0 : messageObj.id) && !existingMessageIds.includes(messageObj.id)) {
        const message = messageObj.message;
        if (!message)
          continue;
        if (((_a = message.author) == null ? void 0 : _a.role) === "tool" && ChatGPTDalleProcessor.hasRealDalleImage(message)) {
          const promptData = imagePrompts.get(messageObj.id || "");
          const dalleMessage = ChatGPTDalleProcessor.createDalleAssistantMessage(
            message,
            promptData == null ? void 0 : promptData.prompt,
            promptData == null ? void 0 : promptData.timestamp
          );
          if (dalleMessage) {
            const chatMessage = {
              id: dalleMessage.id,
              author: { role: dalleMessage.role },
              content: { parts: [dalleMessage.content] },
              create_time: dalleMessage.timestamp,
              attachments: (_b = dalleMessage.attachments) == null ? void 0 : _b.map((att) => ({
                file_name: att.fileName,
                file_size: att.fileSize,
                file_type: att.fileType,
                extracted_content: att.extractedContent
              }))
            };
            newMessages.push(chatMessage);
          }
        } else if (orphanedPrompts.has(messageObj.id || "")) {
          const prompt = orphanedPrompts.get(messageObj.id || "");
          if (prompt) {
            const orphanedMessage = ChatGPTDalleProcessor.createOrphanedPromptMessage(message, prompt);
            const chatMessage = {
              id: orphanedMessage.id,
              author: { role: orphanedMessage.role },
              content: { parts: [orphanedMessage.content] },
              create_time: orphanedMessage.timestamp
            };
            newMessages.push(chatMessage);
          }
        } else if (ChatGPTMessageFilter.shouldIncludeMessage(message)) {
          newMessages.push(message);
        }
      }
    }
    return newMessages;
  }
  /**
   * ChatGPT-specific ZIP entry filter.
   *
   * ChatGPT exports can contain gigabytes of voice-recording files (.dat)
   * and audio/video files that are NOT user-uploaded attachments. Loading
   * them into RAM via JSZip would cause Electron to OOM-crash on large exports.
   *
   * Rules (first match wins):
   *  1. Small files (<1 MB) — always keep (JSON, metadata, tiny assets)
   *  2. User-uploaded attachments (basename starts with file- or file_) — keep
   *  3. Audio / video extensions — skip
   *  4. .dat files not matching user-attachment pattern — skip (voice recordings)
   *  5. Everything else — keep
   */
  shouldIncludeZipEntry(entryName, uncompressedSize) {
    var _a;
    if (uncompressedSize < 1 * 1024 * 1024)
      return true;
    const baseName = (_a = entryName.split("/").pop()) != null ? _a : entryName;
    const ext = baseName.includes(".") ? baseName.split(".").pop().toLowerCase() : "";
    const USER_ATTACHMENT = /^file[-_][A-Za-z0-9]/;
    if (USER_ATTACHMENT.test(baseName))
      return true;
    const AUDIO_VIDEO = /* @__PURE__ */ new Set([
      "mp3",
      "m4a",
      "mp4",
      "webm",
      "ogg",
      "aac",
      "wav",
      "flac",
      "opus",
      "wma",
      "mov",
      "avi",
      "mkv"
    ]);
    if (AUDIO_VIDEO.has(ext))
      return false;
    if (ext === "dat")
      return false;
    return true;
  }
  /**
   * Provide ChatGPT-specific attachment extractor
   * The actual processMessageAttachments() logic is inherited from BaseProviderAdapter
   */
  getAttachmentExtractor() {
    return this.attachmentExtractor;
  }
  getReportNamingStrategy() {
    return this.reportNamingStrategy;
  }
  /**
   * Set attachment map for multi-ZIP support
   */
  setAttachmentMap(attachmentMap, allZips) {
    this.attachmentExtractor.setAttachmentMap(attachmentMap, allZips);
  }
  /**
   * Clear attachment map after import completes
   */
  clearAttachmentMap() {
    this.attachmentExtractor.clearAttachmentMap();
  }
};
__name(ChatGPTAdapter, "ChatGPTAdapter");

// src/providers/claude/claude-converter.ts
init_utils();
var ClaudeConverter = class {
  static setPlugin(plugin) {
    this.plugin = plugin;
  }
  /**
   * Get artifact folder name matching the conversation file name (without .md)
   */
  static getArtifactFolderName(conversationTitle, conversationCreateTime) {
    if (!conversationTitle)
      return "unknown";
    return generateConversationFileName(
      conversationTitle,
      conversationCreateTime || 0,
      this.plugin.settings.addDatePrefix,
      this.plugin.settings.dateFormat
    );
  }
  static async convertChat(chat) {
    const createTime = chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0;
    const conversationTitle = chat.name || "Untitled";
    const messages = await this.convertMessages(chat.chat_messages, chat.uuid, conversationTitle, createTime);
    return {
      id: chat.uuid,
      title: conversationTitle,
      createTime: chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0,
      updateTime: chat.updated_at ? Math.floor(new Date(chat.updated_at).getTime() / 1e3) : 0,
      messages,
      provider: "claude",
      chatUrl: `https://claude.ai/chat/${chat.uuid}`,
      metadata: {
        model: chat.model || "claude-3",
        summary: chat.summary || "",
        is_starred: chat.is_starred,
        current_leaf_message_uuid: chat.current_leaf_message_uuid,
        project_uuid: chat.project_uuid
      }
    };
  }
  static async convertMessages(messages, conversationId, conversationTitle, conversationCreateTime) {
    var _a, _b, _c, _d;
    const standardMessages = [];
    if (!messages || messages.length === 0) {
      return standardMessages;
    }
    const messageComputerLinks = /* @__PURE__ */ new Map();
    for (let msgIndex = 0; msgIndex < messages.length; msgIndex++) {
      const message = messages[msgIndex];
      const linksInMessage = /* @__PURE__ */ new Set();
      if (message.content) {
        for (const block of message.content) {
          if (block.type === "text" && block.text) {
            const computerLinkRegex = /computer:\/\/\/([^\)]+)/g;
            let match;
            while ((match = computerLinkRegex.exec(block.text)) !== null) {
              linksInMessage.add(match[1]);
            }
          }
        }
      }
      if (linksInMessage.size > 0) {
        messageComputerLinks.set(msgIndex, linksInMessage);
      }
    }
    const allArtifacts = [];
    const toolOnlyArtifactIds = /* @__PURE__ */ new Set();
    for (let msgIndex = 0; msgIndex < messages.length; msgIndex++) {
      const message = messages[msgIndex];
      if (message.content) {
        for (let blockIndex = 0; blockIndex < message.content.length; blockIndex++) {
          const block = message.content[blockIndex];
          if (block.type === "tool_use" && block.name === "artifacts" && block.input) {
            const command = block.input.command || "create";
            const versionUuid = block.input.version_uuid;
            if (command !== "view" && versionUuid) {
              const messageTimestamp = message.created_at ? Math.floor(new Date(message.created_at).getTime() / 1e3) : 0;
              allArtifacts.push({
                artifact: block.input,
                messageIndex: msgIndex,
                blockIndex,
                messageTimestamp
              });
            }
          }
          if (block.type === "tool_use" && block.name === "create_file") {
            if (((_a = block.input) == null ? void 0 : _a.path) && ((_b = block.input) == null ? void 0 : _b.file_text)) {
              const fileText = block.input.file_text || "";
              const MIN_CONTENT_LENGTH = 200;
              const filePath = block.input.path;
              const fileName = filePath.split("/").pop() || "";
              if (fileText.length >= MIN_CONTENT_LENGTH) {
                const computerLinksInMessage = messageComputerLinks.get(msgIndex);
                if (computerLinksInMessage && computerLinksInMessage.size > 0) {
                  let matchingLink = null;
                  for (const link of computerLinksInMessage) {
                    const linkFileName = link.split("/").pop() || "";
                    if (linkFileName === fileName || linkFileName.startsWith(fileName.replace(/\.[^.]+$/, ""))) {
                      matchingLink = linkFileName;
                      break;
                    }
                  }
                  if (matchingLink) {
                    const extension = ((_c = matchingLink.split(".").pop()) == null ? void 0 : _c.toLowerCase()) || "";
                    if (this.isTextExploitableExtension(extension)) {
                      const messageTimestamp = message.created_at ? Math.floor(new Date(message.created_at).getTime() / 1e3) : 0;
                      allArtifacts.push({
                        artifact: {
                          ...block.input,
                          _format: "create_file",
                          _blockId: block.id,
                          command: "create"
                        },
                        messageIndex: msgIndex,
                        blockIndex,
                        messageTimestamp
                      });
                    } else {
                      const toolOnlyId = this.extractArtifactIdFromPath(filePath);
                      toolOnlyArtifactIds.add(toolOnlyId);
                    }
                  }
                } else {
                  const messageTimestamp = message.created_at ? Math.floor(new Date(message.created_at).getTime() / 1e3) : 0;
                  allArtifacts.push({
                    artifact: {
                      ...block.input,
                      _format: "create_file",
                      _blockId: block.id,
                      command: "create"
                    },
                    messageIndex: msgIndex,
                    blockIndex,
                    messageTimestamp
                  });
                }
              }
            }
          }
          if (block.type === "tool_use" && block.name === "str_replace" && ((_d = block.input) == null ? void 0 : _d.path)) {
            const artifactIdFromPath = this.extractArtifactIdFromPath(block.input.path);
            if (toolOnlyArtifactIds.has(artifactIdFromPath)) {
              continue;
            }
            const messageTimestamp = message.created_at ? Math.floor(new Date(message.created_at).getTime() / 1e3) : 0;
            allArtifacts.push({
              artifact: {
                ...block.input,
                _format: "str_replace",
                _blockId: block.id,
                command: "update"
              },
              messageIndex: msgIndex,
              blockIndex,
              messageTimestamp
            });
          }
        }
      }
    }
    const { artifactVersionMap, messageArtifactCallouts } = await this.processAllArtifacts(
      allArtifacts,
      conversationId,
      conversationTitle,
      conversationCreateTime
    );
    for (let msgIndex = 0; msgIndex < messages.length; msgIndex++) {
      const message = messages[msgIndex];
      if (!this.shouldIncludeMessage(message)) {
        continue;
      }
      const perMessageCalloutMap = messageArtifactCallouts.get(msgIndex) || /* @__PURE__ */ new Map();
      const { text, attachments } = await this.processContentBlocksForDisplay(
        message.content,
        artifactVersionMap,
        perMessageCalloutMap,
        conversationId,
        conversationTitle,
        conversationCreateTime
      );
      const fileAttachments = this.processFileAttachments(message.files);
      const standardMessage = {
        id: message.uuid,
        role: message.sender === "human" ? "user" : "assistant",
        content: text || message.text || "",
        timestamp: Math.floor(new Date(message.created_at).getTime() / 1e3),
        attachments: [...attachments, ...fileAttachments]
      };
      standardMessages.push(standardMessage);
    }
    return this.sortMessagesByTimestamp(standardMessages);
  }
  static shouldIncludeMessage(message) {
    if (message.sender === "human" || message.sender === "assistant") {
      if (!message.text && (!message.content || message.content.length === 0)) {
        return false;
      }
      return true;
    }
    return false;
  }
  /**
   * Sort messages by timestamp with UUID as secondary sort for chronological order
   */
  static sortMessagesByTimestamp(messages) {
    if (messages.length <= 1)
      return messages;
    return sortMessagesByTimestamp(messages);
  }
  /**
   * Process ALL artifacts from entire conversation and create files
   */
  static async processAllArtifacts(allArtifacts, conversationId, conversationTitle, conversationCreateTime) {
    const artifactVersionMap = /* @__PURE__ */ new Map();
    const messageArtifactCallouts = /* @__PURE__ */ new Map();
    const versionCounters = /* @__PURE__ */ new Map();
    const artifactContents = /* @__PURE__ */ new Map();
    const artifactLanguages = /* @__PURE__ */ new Map();
    for (const { artifact, messageIndex, messageTimestamp } of allArtifacts) {
      const isNewFormat = artifact._format === "create_file" || artifact._format === "str_replace";
      const artifactId = isNewFormat ? this.extractArtifactIdFromPath(artifact.path) : artifact.id || "unknown";
      const command = artifact.command || "create";
      const currentVersion = (versionCounters.get(artifactId) || 0) + 1;
      versionCounters.set(artifactId, currentVersion);
      let finalContent = "";
      if (command === "create" || command === "rewrite") {
        if (isNewFormat && artifact._format === "create_file") {
          finalContent = artifact.file_text || "";
        } else {
          finalContent = artifact.content || "";
        }
        artifactContents.set(artifactId, finalContent);
        const detectedLanguage = isNewFormat ? this.detectLanguageFromPath(artifact.path) : this.detectLanguageFromContent(finalContent, artifact.type);
        artifactLanguages.set(artifactId, detectedLanguage);
      } else if (command === "update") {
        const previousContent = artifactContents.get(artifactId) || "";
        if (artifact.old_str && artifact.new_str) {
          finalContent = previousContent.replace(artifact.old_str, artifact.new_str);
        } else if (artifact.content && artifact.content.length > 0) {
          finalContent = artifact.content;
        } else {
          finalContent = previousContent;
        }
        artifactContents.set(artifactId, finalContent);
      }
      try {
        const storedLanguage = artifactLanguages.get(artifactId);
        const languageToUse = storedLanguage || this.detectLanguageFromContent(finalContent, artifact.type);
        await this.saveSingleArtifactVersionWithContent(
          artifactId,
          artifact,
          currentVersion,
          finalContent,
          conversationId,
          conversationTitle,
          conversationCreateTime,
          languageToUse,
          messageTimestamp
        );
        const versionKey = isNewFormat ? `${artifact.path}::v${currentVersion}` : artifact.version_uuid;
        artifactVersionMap.set(versionKey, {
          versionNumber: currentVersion,
          title: artifact.title || artifactId
        });
        if (isNewFormat) {
          const fileName = artifact.path.split("/").pop();
          if (fileName) {
            const title = artifact.title || artifactId;
            const artifactFileName = `${artifactId}_v${currentVersion}`;
            const artifactPath = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${this.getArtifactFolderName(conversationTitle, conversationCreateTime)}/${artifactFileName}`;
            const callout = `>[!${this.CALLOUTS.ARTIFACT}] **${title}** v${currentVersion}
> \u{1F3A8} [[${artifactPath}|View Artifact]]`;
            if (!messageArtifactCallouts.has(messageIndex)) {
              messageArtifactCallouts.set(messageIndex, /* @__PURE__ */ new Map());
            }
            messageArtifactCallouts.get(messageIndex).set(fileName, callout);
          }
        }
      } catch (error) {
        this.plugin.logger.error(`Failed to save ${artifactId} v${currentVersion}:`, error);
      }
    }
    return { artifactVersionMap, messageArtifactCallouts };
  }
  /**
   * Process content blocks for display (with artifact links)
   */
  static async processContentBlocksForDisplay(contentBlocks, artifactVersionMap, artifactCalloutMap, conversationId, conversationTitle, conversationCreateTime) {
    var _a;
    const textParts = [];
    const attachments = [];
    if (!contentBlocks || contentBlocks.length === 0) {
      return { text: "", attachments: [] };
    }
    for (const block of contentBlocks) {
      switch (block.type) {
        case "text":
          if (block.text) {
            let processedText = this.filterArtifactPlaceholders(block.text, conversationId);
            processedText = this.replaceComputerLinks(processedText, conversationId, artifactCalloutMap, true);
            textParts.push(processedText);
          }
          break;
        case "thinking":
          break;
        case "tool_use":
          if (block.name === "artifacts" && ((_a = block.input) == null ? void 0 : _a.version_uuid)) {
            const versionInfo = artifactVersionMap.get(block.input.version_uuid);
            if (versionInfo) {
              const artifactId = block.input.id || "unknown";
              const versionNumber = versionInfo.versionNumber;
              const title = versionInfo.title || "Artifact";
              const artifactFileName = `${artifactId}_v${versionNumber}`;
              const artifactPath = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${this.getArtifactFolderName(conversationTitle, conversationCreateTime)}/${artifactFileName}`;
              const callout = `>[!${this.CALLOUTS.ARTIFACT}] **${title}** v${versionNumber}
> \u{1F3A8} [[${artifactPath}|View Artifact]]`;
              textParts.push(callout);
            }
          }
          break;
        case "tool_result":
          if (block.name === "present_files" && block.content) {
            for (const contentItem of block.content) {
              if (contentItem.type === "local_resource" && contentItem.file_path) {
                const fileName = contentItem.file_path.split("/").pop();
                if (fileName) {
                  const callout = artifactCalloutMap.get(fileName);
                  if (callout) {
                    textParts.push(callout);
                  }
                }
              }
            }
          }
          break;
      }
    }
    return {
      text: textParts.join("\n\n"),
      attachments
    };
  }
  static async processContentBlocks(contentBlocks, conversationId, conversationTitle, conversationCreateTime, versionCounters, artifactSummaries) {
    var _a;
    const textParts = [];
    const attachments = [];
    const artifactVersionsMap = /* @__PURE__ */ new Map();
    if (!contentBlocks || contentBlocks.length === 0) {
      return { text: "", attachments: [] };
    }
    for (const block of contentBlocks) {
      if (block.type === "tool_use" && block.name === "artifacts" && block.input) {
        const artifactId = block.input.id || "unknown";
        const content = block.input.content || "";
        const command = block.input.command || "create";
        const versionUuid = block.input.version_uuid;
        if (command === "update" && content.length === 0 || command === "view") {
          continue;
        }
        const isSignificant = command === "create" || command === "rewrite" || command === "update" && content.length > 100;
        if (isSignificant && versionUuid) {
          if (!artifactVersionsMap.has(artifactId)) {
            artifactVersionsMap.set(artifactId, []);
          }
          artifactVersionsMap.get(artifactId).push(block.input);
        }
      }
    }
    for (const block of contentBlocks) {
      if (block.type === "tool_use" && block.name === "create_file" && block.input) {
        const filePath = block.input.path || "";
        const fileText = block.input.file_text || "";
        const description = block.input.description || "";
        if (filePath && fileText) {
          const fileName = filePath.split("/").pop() || "";
          const artifactId = fileName.replace(/\.(md|py|js|ts|html|css|txt|json|java|cpp|c|go|rs|rb|php|swift|kt)$/, "");
          const ext = ((_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "text";
          const languageMap = {
            "md": "markdown",
            "py": "python",
            "js": "javascript",
            "ts": "typescript",
            "html": "html",
            "css": "css",
            "json": "json",
            "java": "java",
            "cpp": "cpp",
            "c": "c",
            "go": "go",
            "rs": "rust",
            "rb": "ruby",
            "php": "php",
            "swift": "swift",
            "kt": "kotlin"
          };
          const language = languageMap[ext] || "text";
          const artifactInput = {
            id: artifactId,
            version_uuid: block.id || `create_file_${artifactId}`,
            title: description || fileName,
            content: fileText,
            command: "create",
            language
          };
          if (!artifactVersionsMap.has(artifactId)) {
            artifactVersionsMap.set(artifactId, []);
          }
          artifactVersionsMap.get(artifactId).push(artifactInput);
        }
      }
    }
    if (!versionCounters)
      versionCounters = /* @__PURE__ */ new Map();
    if (!artifactSummaries)
      artifactSummaries = /* @__PURE__ */ new Map();
    const artifactContents = /* @__PURE__ */ new Map();
    for (const block of contentBlocks) {
      switch (block.type) {
        case "text":
          if (block.text) {
            const processedText = this.filterArtifactPlaceholders(block.text, conversationId);
            textParts.push(processedText);
          }
          break;
        case "thinking":
          break;
        case "tool_use":
          if (block.name === "repl" || block.name === "str_replace_editor" || block.name === "bash") {
            break;
          }
          if (block.name === "artifacts" && block.input) {
            const artifactId = block.input.id || "unknown";
            const command = block.input.command || "create";
            const versionUuid = block.input.version_uuid;
            if (command === "view") {
              break;
            }
            if (versionUuid) {
              const currentVersion = (versionCounters.get(artifactId) || 0) + 1;
              versionCounters.set(artifactId, currentVersion);
              let finalContent = "";
              if (command === "create" || command === "rewrite") {
                finalContent = block.input.content || "";
                artifactContents.set(artifactId, finalContent);
              } else if (command === "update") {
                const previousContent = artifactContents.get(artifactId) || "";
                if (block.input.old_str && block.input.new_str) {
                  finalContent = previousContent.replace(block.input.old_str, block.input.new_str);
                } else if (block.input.content && block.input.content.length > 0) {
                  finalContent = block.input.content;
                } else {
                  finalContent = previousContent;
                }
                artifactContents.set(artifactId, finalContent);
              }
              try {
                await this.saveSingleArtifactVersionWithContent(
                  artifactId,
                  block.input,
                  currentVersion,
                  finalContent,
                  conversationId,
                  conversationTitle,
                  conversationCreateTime
                );
                const title = block.input.title || artifactId;
                const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${this.getArtifactFolderName(conversationTitle, conversationCreateTime)}`;
                const versionFile = `${conversationFolder}/${artifactId}_v${currentVersion}`;
                const specificLink = `>[!${this.CALLOUTS.ARTIFACT}] **${title}** v${currentVersion}
> \u{1F3A8} [[${versionFile}|View Artifact]]`;
                textParts.push(specificLink);
              } catch (error) {
                this.plugin.logger.error(`Failed to save ${artifactId} v${currentVersion}:`, error);
                textParts.push(`>[!${this.CALLOUTS.ARTIFACT}] **${block.input.title || artifactId}** v${currentVersion}
> \u274C Error saving artifact`);
              }
            }
          } else if (block.name === "web_search") {
            break;
          } else if (block.name && block.input) {
            const code = block.input.code || JSON.stringify(block.input, null, 2);
            textParts.push(`**[Tool: ${block.name}]**
\`\`\`
${code}
\`\`\``);
          }
          break;
        case "tool_result":
          break;
      }
    }
    return {
      text: textParts.join("\n\n"),
      attachments
    };
  }
  static processFileAttachments(files) {
    const attachments = [];
    if (!files || files.length === 0) {
      return attachments;
    }
    for (const file of files) {
      if (file && file.file_name) {
        attachments.push({
          fileName: file.file_name,
          fileSize: 0,
          // Size not provided in Claude export
          fileType: this.getFileTypeFromName(file.file_name),
          fileId: file.file_name,
          // Use filename as ID
          extractedContent: ""
        });
      }
    }
    return attachments;
  }
  static getFileTypeFromName(fileName) {
    var _a;
    const extension = (_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (extension) {
      case "png":
      case "jpg":
      case "jpeg":
      case "gif":
      case "webp":
        return `image/${extension}`;
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "md":
        return "text/markdown";
      case "json":
        return "application/json";
      default:
        return "application/octet-stream";
    }
  }
  /**
   * Save a single artifact version with computed content
   */
  static async saveSingleArtifactVersionWithContent(artifactId, artifactData, versionNumber, finalContent, conversationId, conversationTitle, conversationCreateTime, forcedLanguage, messageTimestamp) {
    if (!this.plugin) {
      throw new Error("Plugin not available");
    }
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${this.getArtifactFolderName(conversationTitle, conversationCreateTime)}`;
    const folderResult = await ensureFolderExists2(conversationFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create artifacts folder: ${folderResult.error}`);
    }
    const safeArtifactId = artifactId.replace(/[\/\\:*?"<>|]/g, "_");
    const fileName = `${safeArtifactId}_v${versionNumber}.md`;
    const filePath = `${conversationFolder}/${fileName}`;
    const shouldSkip = await this.shouldSkipArtifactVersion(filePath, artifactData.version_uuid);
    if (shouldSkip) {
      return;
    }
    await this.saveIndividualArtifactVersion(
      artifactData,
      filePath,
      versionNumber,
      finalContent,
      conversationId,
      conversationTitle,
      conversationCreateTime,
      forcedLanguage,
      messageTimestamp
    );
  }
  /**
   * Create artifact summary for conversation
   */
  static createArtifactSummary(artifactId, info, conversationTitle, conversationCreateTime) {
    const title = info.title || artifactId;
    const totalVersions = info.totalVersions || 1;
    const latestVersion = info.latestVersion || 1;
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${this.getArtifactFolderName(conversationTitle, conversationCreateTime)}`;
    const latestFile = `${conversationFolder}/${artifactId}_v${latestVersion}`;
    let summary = `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}**`;
    if (totalVersions > 1) {
      summary += ` (${totalVersions} versions)`;
    }
    summary += `

\u{1F4CE} **[[${latestFile}|View Latest Version]]**`;
    if (totalVersions > 1) {
      summary += ` | **[[${conversationFolder}/|All Versions]]**`;
    }
    summary += `</div>`;
    return summary;
  }
  /**
   * Format artifact summary for conversation display
   */
  static formatArtifactSummary(firstVersion, savedVersions, latestVersion, conversationFolder) {
    const title = (firstVersion == null ? void 0 : firstVersion.title) || "Untitled Artifact";
    const versionCount = savedVersions.length;
    if (!latestVersion) {
      this.plugin.logger.error("Claude converter: No latest version available for artifact summary");
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}** (Error: No accessible version)</div>`;
    }
    let formattedContent = `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}**`;
    if (versionCount > 1) {
      formattedContent += ` (${versionCount} versions)`;
    }
    const latestVersionLink = latestVersion.replace(/\.md$/, "");
    formattedContent += `

\u{1F4CE} **[[${latestVersionLink}|View Latest Version]]**`;
    if (versionCount > 1) {
      formattedContent += ` | **[[${conversationFolder}/|All Versions]]**`;
    }
    formattedContent += `</div>`;
    return formattedContent;
  }
  /**
   * Save a single artifact version with specific content
   */
  static async saveIndividualArtifactVersion(artifactInput, filePath, versionNumber, versionContent, conversationId, conversationTitle, conversationCreateTime, forcedLanguage, messageTimestamp) {
    const isNewFormat = artifactInput._format === "create_file" || artifactInput._format === "str_replace";
    const title = isNewFormat ? this.extractArtifactIdFromPath(artifactInput.path) : artifactInput.title || "Untitled Artifact";
    let language = isNewFormat ? "text" : artifactInput.language || "text";
    const command = artifactInput.command || "create";
    const artifactId = isNewFormat ? this.extractArtifactIdFromPath(artifactInput.path) : artifactInput.id || "unknown";
    const versionUuid = isNewFormat ? artifactInput._blockId || `${artifactInput.path}::v${versionNumber}` : artifactInput.version_uuid;
    if (forcedLanguage) {
      language = forcedLanguage;
    } else if ((language.toLowerCase() === "text" || !language || language === "undefined") && versionContent) {
      const detectedLanguage = this.detectLanguageFromContent(versionContent, artifactInput.type);
      if (detectedLanguage !== "text") {
        language = detectedLanguage;
      }
    }
    let conversationLink = "";
    if (conversationId && conversationTitle && conversationCreateTime) {
      const createDate = new Date(conversationCreateTime * 1e3);
      const year = createDate.getFullYear();
      const month = String(createDate.getMonth() + 1).padStart(2, "0");
      const { generateConversationFileName: generateConversationFileName2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
      const fileName = generateConversationFileName2(
        conversationTitle,
        conversationCreateTime,
        this.plugin.settings.addDatePrefix,
        this.plugin.settings.dateFormat
      );
      const conversationPath = `${this.plugin.settings.conversationFolder}/claude/${year}/${month}/${fileName}`;
      conversationLink = `[[${conversationPath}|${conversationTitle}]]`;
    }
    const safeArtifactTitle = generateSafeAlias(title);
    const safeArtifactAlias = generateSafeAlias(`${artifactId}_v${versionNumber}`);
    const artifactCreateTime = messageTimestamp || conversationCreateTime || 0;
    const createTimeStr = artifactCreateTime > 0 ? new Date(artifactCreateTime * 1e3).toISOString() : "unknown";
    let markdownContent = `---
nexus: nexus-ai-chat-importer
plugin_version: "${this.plugin.manifest.version}"
provider: claude
artifact_id: ${artifactId}
version_uuid: ${versionUuid}
version_number: ${versionNumber}
command: ${command}
conversation_id: ${conversationId || "unknown"}
create_time: ${createTimeStr}
format: ${language}
aliases: [${safeArtifactTitle}, ${safeArtifactAlias}]
---

# ${title} (Version ${versionNumber})
`;
    if (conversationLink) {
      markdownContent += `
**Conversation:** ${conversationLink}

`;
    }
    markdownContent += `## Content

`;
    if (language.toLowerCase() === "markdown") {
      markdownContent += versionContent;
    } else {
      markdownContent += `\`\`\`${language}
${versionContent}
\`\`\``;
    }
    try {
      await this.plugin.app.vault.create(filePath, markdownContent);
    } catch (error) {
      this.plugin.logger.error(`Failed to create artifact file ${filePath}:`, error);
      throw error;
    }
  }
  /**
   * Check if we should skip saving this artifact version (already exists)
   */
  static async shouldSkipArtifactVersion(filePath, versionUuid) {
    try {
      const existingFile = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (!existingFile) {
        return false;
      }
      const existingContent = await this.plugin.app.vault.read(existingFile);
      if (existingContent.includes(`version_uuid: ${versionUuid}`)) {
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  /**
   * Determine if we should replace the current artifact with a new one
   * Priority: create > rewrite > update (with content) > view
   */
  static shouldReplaceArtifact(current, candidate) {
    const currentCommand = current.command || "create";
    const candidateCommand = candidate.command || "create";
    const currentContent = (current.content || "").length;
    const candidateContent = (candidate.content || "").length;
    const commandPriority = {
      "create": 4,
      "rewrite": 3,
      "update": 2,
      "view": 1
    };
    const currentPriority = commandPriority[currentCommand] || 1;
    const candidatePriority = commandPriority[candidateCommand] || 1;
    if (candidatePriority > currentPriority) {
      return true;
    }
    if (candidatePriority === currentPriority) {
      return candidateContent > currentContent;
    }
    return false;
  }
  /**
   * Extract artifact ID from file path (new format)
   * Example: "/home/claude/lettre_table.js" → "lettre_table"
   */
  static extractArtifactIdFromPath(path) {
    if (!path)
      return "unknown";
    const parts = path.split("/");
    const filename = parts[parts.length - 1] || "unknown";
    const dotIndex = filename.lastIndexOf(".");
    if (dotIndex > 0) {
      return filename.substring(0, dotIndex);
    }
    return filename;
  }
  /**
   * Detect language from file path extension (new format)
   * Example: "/home/claude/script.py" → "python"
   */
  static detectLanguageFromPath(path) {
    var _a;
    if (!path)
      return "text";
    const extension = ((_a = path.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
    switch (extension) {
      case "py":
        return "python";
      case "js":
        return "javascript";
      case "ts":
        return "typescript";
      case "jsx":
        return "jsx";
      case "tsx":
        return "tsx";
      case "html":
        return "html";
      case "css":
        return "css";
      case "scss":
        return "scss";
      case "md":
        return "markdown";
      case "json":
        return "json";
      case "yaml":
      case "yml":
        return "yaml";
      case "xml":
        return "xml";
      case "svg":
        return "xml";
      case "sql":
        return "sql";
      case "sh":
      case "bash":
        return "bash";
      case "php":
        return "php";
      case "rb":
        return "ruby";
      case "go":
        return "go";
      case "rs":
        return "rust";
      case "java":
        return "java";
      case "c":
        return "c";
      case "cpp":
      case "cc":
      case "cxx":
        return "cpp";
      case "cs":
        return "csharp";
      case "swift":
        return "swift";
      case "kt":
        return "kotlin";
      case "r":
        return "r";
      case "txt":
        return "text";
      default:
        return "text";
    }
  }
  /**
   * Auto-detect language from content and artifact type
   */
  static detectLanguageFromContent(content, artifactType) {
    if (!content || content.trim().length === 0)
      return "text";
    if (artifactType) {
      if (artifactType.includes("react") || artifactType.includes("jsx"))
        return "jsx";
      if (artifactType.includes("vue"))
        return "vue";
      if (artifactType.includes("svelte"))
        return "svelte";
      if (artifactType.includes("html"))
        return "html";
      if (artifactType.includes("css"))
        return "css";
      if (artifactType.includes("json"))
        return "json";
      if (artifactType.includes("xml"))
        return "xml";
      if (artifactType.includes("svg"))
        return "xml";
    }
    const trimmedContent = content.trim();
    if (trimmedContent.startsWith("<?php"))
      return "php";
    if (trimmedContent.startsWith("#!/bin/bash") || trimmedContent.startsWith("#!/bin/sh"))
      return "bash";
    if (trimmedContent.startsWith("<!DOCTYPE html") || trimmedContent.includes("<html"))
      return "html";
    if (trimmedContent.includes("import React") || trimmedContent.includes('from "react"') || trimmedContent.includes("useState") || trimmedContent.includes("useEffect") || trimmedContent.includes("className=") || trimmedContent.includes("jsx")) {
      return "jsx";
    }
    if (trimmedContent.startsWith("{") && trimmedContent.endsWith("}")) {
      try {
        JSON.parse(trimmedContent);
        return "json";
      } catch (e) {
      }
    }
    if (trimmedContent.startsWith("<svg") || trimmedContent.includes("xmlns")) {
      return "xml";
    }
    if (trimmedContent.includes("# ") || trimmedContent.includes("## ") || trimmedContent.includes("**") || trimmedContent.includes("```")) {
      return "markdown";
    }
    if (trimmedContent.includes("def ") || trimmedContent.includes("import ") || trimmedContent.includes("from ") || trimmedContent.includes("class ")) {
      return "python";
    }
    if (trimmedContent.includes("function ") || trimmedContent.includes("const ") || trimmedContent.includes("let ") || trimmedContent.includes("var ") || trimmedContent.includes("=>")) {
      return "javascript";
    }
    if (trimmedContent.includes("{") && trimmedContent.includes(":") && trimmedContent.includes(";") && trimmedContent.includes("}")) {
      return "css";
    }
    if (trimmedContent.toUpperCase().includes("SELECT ") || trimmedContent.toUpperCase().includes("INSERT ") || trimmedContent.toUpperCase().includes("UPDATE ") || trimmedContent.toUpperCase().includes("CREATE TABLE")) {
      return "sql";
    }
    return "text";
  }
  /**
   * Get file extension from language
   */
  static getExtensionFromLanguage(language) {
    switch (language.toLowerCase()) {
      case "python":
        return "py";
      case "javascript":
        return "js";
      case "typescript":
        return "ts";
      case "html":
        return "html";
      case "css":
        return "css";
      case "markdown":
        return "md";
      case "json":
        return "json";
      case "yaml":
        return "yml";
      case "xml":
        return "xml";
      case "sql":
        return "sql";
      case "bash":
        return "sh";
      case "shell":
        return "sh";
      case "php":
        return "php";
      default:
        return "txt";
    }
  }
  /**
   * Check if file extension is text exploitable (can be used as artifact in Obsidian)
   */
  static isTextExploitableExtension(extension) {
    const textExploitableExtensions = [
      // Code
      "py",
      "js",
      "ts",
      "java",
      "cpp",
      "c",
      "h",
      "cs",
      "go",
      "rs",
      "php",
      "rb",
      "swift",
      "kt",
      "scala",
      "r",
      "sh",
      "bash",
      // Web
      "html",
      "css",
      "scss",
      "sass",
      "less",
      "vue",
      "jsx",
      "tsx",
      // Config/Data
      "json",
      "xml",
      "yaml",
      "yml",
      "toml",
      "ini",
      "env",
      // Documentation
      "md",
      "txt",
      "rst",
      "adoc",
      // SQL
      "sql"
    ];
    return textExploitableExtensions.includes(extension);
  }
  /**
   * Get file type from extension (for binary file callouts)
   */
  static getFileTypeFromExtension(extension) {
    switch (extension) {
      case "svg":
        return "SVG Image";
      case "png":
        return "PNG Image";
      case "jpg":
      case "jpeg":
        return "JPEG Image";
      case "gif":
        return "GIF Image";
      case "webp":
        return "WebP Image";
      case "pdf":
        return "PDF Document";
      case "docx":
      case "doc":
        return "Word Document";
      case "pptx":
      case "ppt":
        return "PowerPoint Presentation";
      case "xlsx":
      case "xls":
        return "Excel Spreadsheet";
      case "txt":
        return "Text File";
      case "md":
        return "Markdown Document";
      case "json":
        return "JSON File";
      case "csv":
        return "CSV File";
      default:
        return extension.toUpperCase();
    }
  }
  /**
   * Filter mobile artifact placeholder messages and replace with Nexus callout
   * Claude.ai shows placeholder text on mobile instead of artifacts
   * This text gets exported in the JSON and needs to be replaced
   */
  static filterArtifactPlaceholders(text, conversationId) {
    const mobileArtifactPlaceholder = "Viewing artifacts created via the Analysis Tool web feature preview isn't yet supported on mobile.";
    if (!text.includes(mobileArtifactPlaceholder)) {
      return text;
    }
    const conversationUrl = conversationId ? `https://claude.ai/chat/${conversationId}` : "https://claude.ai";
    const replacementCallout = `>[!${this.CALLOUTS.ARTIFACT}] **Artifact** (Mobile View)
> \u26A0\uFE0F Artifact content not displayed in mobile view. Check the artifacts folder for extracted files, or [open original conversation](${conversationUrl}) to view artifacts.`;
    const codeBlockPattern = /```\s*\n?Viewing artifacts created via the Analysis Tool web feature preview isn't yet supported on mobile\.\s*\n?```/g;
    let result = text.replace(codeBlockPattern, replacementCallout);
    result = result.replace(new RegExp(mobileArtifactPlaceholder.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), replacementCallout);
    return result;
  }
  /**
   * Replace computer:/// links with artifact or attachment callouts
   * These are internal Anthropic server files not included in exports
   * @param artifactCalloutMap - Map of artifact file names to their callouts
   * @param insideCallout - If true, use quote-preserving separators for nested callouts
   */
  static replaceComputerLinks(text, conversationId, artifactCalloutMap, insideCallout = false) {
    var _a;
    const computerLinkRegex = /\[([^\]]+)\]\(computer:\/\/\/([^)]+)\)/g;
    const replacements = [];
    let lastIndex = 0;
    let match;
    while ((match = computerLinkRegex.exec(text)) !== null) {
      const [fullMatch, linkText, filePath] = match;
      const fileName = filePath.split("/").pop() || "file";
      const textBefore = text.substring(lastIndex, match.index).trim();
      if (textBefore && textBefore !== "|") {
        replacements.push(textBefore);
      }
      if (artifactCalloutMap && artifactCalloutMap.has(fileName)) {
        const artifactCallout = artifactCalloutMap.get(fileName);
        replacements.push(artifactCallout);
        lastIndex = match.index + fullMatch.length;
        continue;
      }
      const fileExtension = ((_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
      const fileType = this.getFileTypeFromExtension(fileExtension);
      const conversationUrl = conversationId ? `https://claude.ai/chat/${conversationId}` : "https://claude.ai";
      const callout = `>[!${this.CALLOUTS.ATTACHMENT}] **${fileName}** (${fileType})
> \u26A0\uFE0F File generated on Anthropic server, not included in archive. [Open original conversation](${conversationUrl})`;
      replacements.push(callout);
      lastIndex = match.index + fullMatch.length;
    }
    const remainingText = text.substring(lastIndex).trim();
    if (remainingText && remainingText !== "|") {
      replacements.push(remainingText);
    }
    const separator = "\n\n";
    return replacements.join(separator);
  }
  /**
   * Count unique artifacts in a conversation (by artifact ID, not versions)
   * Supports both old format (artifacts) and new format (create_file)
   * Only counts files with actual content (not binary/server files)
   */
  static countArtifacts(chat) {
    var _a, _b, _c;
    const uniqueArtifacts = /* @__PURE__ */ new Set();
    const MIN_CONTENT_LENGTH = 200;
    for (const message of chat.chat_messages) {
      if (message.content) {
        for (const block of message.content) {
          if (block.type === "tool_use" && block.name === "artifacts" && ((_a = block.input) == null ? void 0 : _a.id)) {
            uniqueArtifacts.add(block.input.id);
          }
          if (block.type === "tool_use" && block.name === "create_file" && ((_b = block.input) == null ? void 0 : _b.path) && ((_c = block.input) == null ? void 0 : _c.file_text)) {
            const fileText = block.input.file_text || "";
            if (fileText.length >= MIN_CONTENT_LENGTH) {
              const artifactId = this.extractArtifactIdFromPath(block.input.path);
              uniqueArtifacts.add(artifactId);
            }
          }
        }
      }
    }
    return uniqueArtifacts.size;
  }
};
__name(ClaudeConverter, "ClaudeConverter");
// Nexus custom callouts with icons
ClaudeConverter.CALLOUTS = {
  USER: "nexus_user",
  // 👤 User messages
  AGENT: "nexus_agent",
  // 🤖 Assistant/Agent messages
  ATTACHMENT: "nexus_attachment",
  // 📎 Attachments
  ARTIFACT: "nexus_artifact",
  // 🛠️ Claude artifacts
  PROMPT: "nexus_prompt"
  // 💭 System prompts
};

// src/providers/claude/claude-attachment-extractor.ts
var ClaudeAttachmentExtractor = class {
  constructor(plugin, logger6) {
    this.plugin = plugin;
    this.logger = logger6;
  }
  /**
   * Extract attachments from Claude ZIP archive
   * NOTE: Claude exports typically do NOT include the actual files, only references
   * This method handles the "files not found" case gracefully
   */
  async extractAttachments(zip, conversationId, attachments) {
    if (attachments.length === 0) {
      return attachments.map((att) => ({
        ...att,
        extractedContent: `File: ${att.fileName} (no attachments to process)`
      }));
    }
    const processedAttachments = [];
    for (const attachment of attachments) {
      try {
        const processedAttachment = await this.processAttachment(zip, conversationId, attachment);
        processedAttachments.push(processedAttachment);
      } catch (error) {
        this.logger.error(`Failed to process Claude attachment ${attachment.fileName}:`, error);
        processedAttachments.push({
          ...attachment,
          extractedContent: `\u274C **File: ${attachment.fileName}**

Error processing attachment: ${error instanceof Error ? error.message : "Unknown error"}`
        });
      }
    }
    return processedAttachments;
  }
  /**
   * Process a single Claude attachment
   * Claude exports typically don't include files, so we create informative placeholders
   */
  async processAttachment(zip, conversationId, attachment) {
    const fileName = attachment.fileName;
    const zipFile = this.findFileInZip(zip, fileName);
    if (!zipFile) {
      return this.createFileNotFoundPlaceholder(attachment, conversationId);
    }
    if (isImageFile(fileName)) {
      return await this.processImageAttachment(zipFile, attachment, conversationId);
    } else if (isTextFile(fileName)) {
      return await this.processTextAttachment(zipFile, attachment);
    } else {
      return await this.processBinaryAttachment(zipFile, attachment, conversationId);
    }
  }
  /**
   * Create simple placeholder for missing files (normal for Claude)
   */
  createFileNotFoundPlaceholder(attachment, conversationId) {
    const fileName = attachment.fileName;
    const conversationUrl = `https://claude.ai/chat/${conversationId}`;
    const fileType = this.getFileTypeFromExtension(fileName);
    const placeholder = `>>[!nexus_attachment] **${fileName}** (${fileType})
>> \u26A0\uFE0F Not included in archive. [Open original conversation](${conversationUrl})`;
    return {
      ...attachment,
      extractedContent: placeholder
    };
  }
  /**
   * Get file type from extension
   */
  getFileTypeFromExtension(fileName) {
    var _a;
    const extension = (_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (extension) {
      case "png":
      case "jpg":
      case "jpeg":
      case "gif":
      case "webp":
        return `image/${extension}`;
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "md":
        return "text/markdown";
      case "json":
        return "application/json";
      default:
        return "application/octet-stream";
    }
  }
  /**
   * Find a file in the ZIP archive
   * Claude files might be in root or in subdirectories
   */
  findFileInZip(zip, fileName) {
    let file = zip.file(fileName);
    if (file)
      return file;
    const commonPaths = ["attachments/", "files/", "uploads/"];
    for (const path of commonPaths) {
      file = zip.file(path + fileName);
      if (file)
        return file;
    }
    const allFiles = Object.keys(zip.files);
    for (const filePath of allFiles) {
      if (filePath.endsWith(fileName) || filePath.includes(fileName)) {
        return zip.file(filePath);
      }
    }
    return null;
  }
  /**
   * Process image attachment
   */
  async processImageAttachment(zipFile, attachment, conversationId) {
    try {
      const imageData = await zipFile.async("base64");
      const fileName = this.generateUniqueFileName(attachment.fileName, conversationId);
      const filePath = await this.saveAttachmentToVault(fileName, imageData, true, "images");
      return {
        ...attachment,
        fileName,
        extractedContent: `![${attachment.fileName}](${filePath})`
      };
    } catch (error) {
      this.logger.error(`Error processing Claude image ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error processing image: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Process text attachment
   */
  async processTextAttachment(zipFile, attachment) {
    try {
      const textContent = await zipFile.async("string");
      return {
        ...attachment,
        extractedContent: `\`\`\`
${textContent}
\`\`\``
      };
    } catch (error) {
      this.logger.error(`Error processing Claude text file ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error reading text file: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Process binary attachment
   */
  async processBinaryAttachment(zipFile, attachment, conversationId) {
    try {
      const binaryData = await zipFile.async("base64");
      const fileName = this.generateUniqueFileName(attachment.fileName, conversationId);
      const filePath = await this.saveAttachmentToVault(fileName, binaryData, true, "documents");
      return {
        ...attachment,
        fileName,
        extractedContent: `[${attachment.fileName}](${filePath})`
      };
    } catch (error) {
      this.logger.error(`Error processing Claude binary file ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error processing file: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Generate unique filename to avoid conflicts
   */
  generateUniqueFileName(originalFileName, conversationId) {
    const timestamp = Date.now();
    const shortConversationId = conversationId.substring(0, 8);
    const extension = originalFileName.includes(".") ? originalFileName.split(".").pop() : "";
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    return extension ? `claude_${shortConversationId}_${timestamp}_${baseName}.${extension}` : `claude_${shortConversationId}_${timestamp}_${baseName}`;
  }
  /**
   * Save attachment to vault using attachmentFolder setting
   */
  async saveAttachmentToVault(fileName, data, isBase64, category = "files") {
    const attachmentFolder = `${this.plugin.settings.attachmentFolder}/claude/${category}`;
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const folderResult = await ensureFolderExists2(attachmentFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create Claude attachment folder: ${folderResult.error}`);
    }
    const filePath = `${attachmentFolder}/${fileName}`;
    if (isBase64) {
      const binaryString = atob(data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      await this.plugin.app.vault.createBinary(filePath, bytes.buffer);
    } else {
      await this.plugin.app.vault.create(filePath, data);
    }
    return filePath;
  }
};
__name(ClaudeAttachmentExtractor, "ClaudeAttachmentExtractor");

// src/providers/claude/claude-report-naming.ts
var ClaudeReportNamingStrategy = class {
  getProviderName() {
    return "claude";
  }
  extractReportPrefix(zipFileName) {
    const patterns = [
      // Pattern 1: data-YYYY-MM-DD-HH-MM-SS-batch-NNNN.zip
      /data-(\d{4})-(\d{2})-(\d{2})-\d{2}-\d{2}-\d{2}-batch-\d{4}/,
      // Pattern 2: Legacy Claude format (generic YYYY-MM-DD)
      /(\d{4})-(\d{2})-(\d{2})/
    ];
    return extractReportPrefixFromZip(zipFileName, patterns);
  }
  getProviderSpecificColumn() {
    return {
      header: "Artifacts",
      getValue: (adapter, chat) => adapter.countArtifacts ? adapter.countArtifacts(chat) : 0
    };
  }
};
__name(ClaudeReportNamingStrategy, "ClaudeReportNamingStrategy");

// src/providers/claude/claude-adapter.ts
var ClaudeAdapter = class extends BaseProviderAdapter {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.attachmentExtractor = new ClaudeAttachmentExtractor(plugin, plugin.logger);
    this.reportNamingStrategy = new ClaudeReportNamingStrategy();
  }
  detect(rawConversations) {
    if (rawConversations.length === 0)
      return false;
    const sample = rawConversations[0];
    return !!(sample.uuid && "name" in sample && sample.chat_messages && Array.isArray(sample.chat_messages) && sample.created_at && sample.updated_at);
  }
  getId(chat) {
    return chat.uuid || "";
  }
  getTitle(chat) {
    return chat.name || "Untitled";
  }
  getCreateTime(chat) {
    return chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0;
  }
  getUpdateTime(chat) {
    return chat.updated_at ? Math.floor(new Date(chat.updated_at).getTime() / 1e3) : 0;
  }
  async convertChat(chat) {
    ClaudeConverter.setPlugin(this.plugin);
    return await ClaudeConverter.convertChat(chat);
  }
  async convertMessages(messages, conversationId, conversationTitle, conversationCreateTime) {
    ClaudeConverter.setPlugin(this.plugin);
    return await ClaudeConverter.convertMessages(messages, conversationId, conversationTitle, conversationCreateTime);
  }
  getProviderName() {
    return "claude";
  }
  getNewMessages(chat, existingMessageIds) {
    const newMessages = [];
    for (const message of chat.chat_messages) {
      if (message.uuid && !existingMessageIds.includes(message.uuid)) {
        if (this.shouldIncludeMessage(message)) {
          newMessages.push(message);
        }
      }
    }
    return newMessages;
  }
  /**
   * Provide Claude-specific attachment extractor
   * The actual processMessageAttachments() logic is inherited from BaseProviderAdapter
   */
  getAttachmentExtractor() {
    return this.attachmentExtractor;
  }
  getReportNamingStrategy() {
    return this.reportNamingStrategy;
  }
  countArtifacts(chat) {
    return ClaudeConverter.countArtifacts(chat);
  }
  shouldIncludeMessage(message) {
    if (message.sender === "human" || message.sender === "assistant") {
      if (!message.text && (!message.content || message.content.length === 0)) {
        return false;
      }
      return true;
    }
    return false;
  }
};
__name(ClaudeAdapter, "ClaudeAdapter");

// src/providers/lechat/lechat-converter.ts
var LeChatConverter = class {
  /**
   * Convert Le Chat conversation to StandardConversation
   * 
   * Note: Le Chat exports are arrays of messages without conversation-level metadata.
   * We derive conversation metadata from the messages themselves.
   */
  static convertChat(chat) {
    var _a;
    if (!chat || chat.length === 0) {
      throw new Error("Le Chat conversation is empty");
    }
    const sortedChat = this.sortMessagesByTimestamp(chat);
    const chatId = ((_a = sortedChat[0]) == null ? void 0 : _a.chatId) || "";
    const title = this.deriveConversationTitle(sortedChat);
    const createTime = this.getMinTimestamp(sortedChat);
    const updateTime = this.getMaxTimestamp(sortedChat);
    const messages = this.convertMessages(sortedChat);
    return {
      id: chatId,
      title,
      provider: "lechat",
      createTime,
      updateTime,
      messages,
      chatUrl: `https://chat.mistral.ai/chat/${chatId}`,
      metadata: {}
    };
  }
  /**
   * Convert Le Chat messages to StandardMessage array
   *
   * IMPORTANT: Assumes messages are already sorted chronologically
   */
  static convertMessages(messages) {
    const standardMessages = [];
    for (const message of messages) {
      const standardMessage = this.convertMessage(message);
      if (standardMessage) {
        standardMessages.push(standardMessage);
      }
    }
    return standardMessages;
  }
  /**
   * Convert single Le Chat message to StandardMessage
   */
  static convertMessage(message) {
    if (!message.id || !message.role) {
      return null;
    }
    const content = this.extractContent(message);
    const attachments = [
      ...this.extractAttachments(message),
      ...this.extractImageUrlAttachments(message)
    ];
    const timestamp = this.parseTimestamp(message.createdAt);
    return {
      id: message.id,
      role: message.role,
      content,
      timestamp,
      attachments
    };
  }
  /**
   * Extract content from Le Chat message
   * IMPORTANT: message.content is a duplicate of text chunks combined
   * We use EITHER contentChunks OR content, not both!
   */
  static extractContent(message) {
    if (message.contentChunks && message.contentChunks.length > 0) {
      const chunksContent = this.processContentChunks(message.contentChunks);
      return chunksContent || "(Empty message)";
    }
    if (message.content && message.content.trim()) {
      return message.content;
    }
    return "(Empty message)";
  }
  /**
   * Process contentChunks array
   * Handles text, tool_call, reference, and custom_element types
   */
  static processContentChunks(chunks) {
    const parts = [];
    for (const chunk of chunks) {
      if (chunk.type === "text" && "text" in chunk && chunk.text) {
        parts.push(chunk.text);
      } else if (chunk.type === "tool_call") {
        continue;
      } else if (chunk.type === "reference" && "referenceIds" in chunk && chunk.referenceIds) {
        const refMarkers = chunk.referenceIds.map((id) => `[^${id}]`).join("");
        if (refMarkers) {
          parts.push(refMarkers);
        }
      }
    }
    return parts.join("\n").trim();
  }
  /**
   * Extract attachments from Le Chat message files array
   */
  static extractAttachments(message) {
    const attachments = [];
    if (!message.files || message.files.length === 0) {
      return attachments;
    }
    for (const file of message.files) {
      const attachment = {
        fileName: file.name,
        fileType: this.getFileTypeFromLeChatType(file.type),
        fileSize: void 0,
        // Size not available in Le Chat export
        status: {
          processed: false,
          found: false
        }
      };
      attachments.push(attachment);
    }
    return attachments;
  }
  /**
   * Extract assistant-generated images from image_url content chunks.
   * These images are hosted on Mistral servers and never included in the ZIP export.
   * We pre-format the callout via extractedContent so the attachment extractor cannot
   * overwrite the note with an ugly internal ZIP path.
   */
  static extractImageUrlAttachments(message) {
    if (!message.contentChunks)
      return [];
    const chatUrl = `https://chat.mistral.ai/chat/${message.chatId}`;
    const imageChunks = message.contentChunks.filter((chunk) => chunk.type === "image_url" && "imageUrl" in chunk);
    return imageChunks.map((chunk, index) => {
      var _a;
      const urlPath = chunk.imageUrl.split("?")[0];
      const urlExt = ((_a = urlPath.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
      const validExts = ["jpg", "jpeg", "png", "gif", "webp"];
      const ext = validExts.includes(urlExt) ? urlExt : "jpg";
      const fileName = imageChunks.length === 1 ? `generated-image.${ext}` : `generated-image-${index + 1}.${ext}`;
      const fileType = ext === "png" ? "image/png" : "image/jpeg";
      const extractedContent = `>>[!nexus_attachment] **${fileName}** *(missing)* (${fileType})
>>
>> \u26A0\uFE0F Not included in export. [Open original conversation](${chatUrl})`;
      return {
        fileName,
        fileType,
        attachmentType: "generated_image",
        url: chatUrl,
        extractedContent,
        status: {
          processed: true,
          found: false,
          reason: "missing_from_export"
        }
      };
    });
  }
  /**
   * Convert Le Chat file type to MIME type
   */
  static getFileTypeFromLeChatType(type) {
    switch (type) {
      case "image":
        return "image/*";
      case "text":
        return "text/plain";
      case "document":
        return "application/octet-stream";
      default:
        return "application/octet-stream";
    }
  }
  /**
   * Sort messages by timestamp (chronological order)
   * CRITICAL: Le Chat exports messages in random order, not chronological!
   * Uses MILLISECOND precision for accurate sorting (even for sub-second responses)
   */
  static sortMessagesByTimestamp(chat) {
    return [...chat].sort((a, b) => {
      const timeA = new Date(a.createdAt).getTime();
      const timeB = new Date(b.createdAt).getTime();
      return timeA - timeB;
    });
  }
  /**
   * Derive conversation title from first user message (chronologically)
   * Truncates to 50 characters if needed
   *
   * IMPORTANT: Assumes messages are already sorted chronologically
   */
  static deriveConversationTitle(chat) {
    const firstUserMessage = chat.find((msg) => msg.role === "user");
    if (firstUserMessage && firstUserMessage.content) {
      const content = firstUserMessage.content.trim();
      if (content.length > 50) {
        return content.substring(0, 50).trim() + "...";
      }
      return content;
    }
    return "Untitled";
  }
  /**
   * Get minimum timestamp from messages (conversation create time)
   */
  static getMinTimestamp(chat) {
    const timestamps = chat.map((msg) => this.parseTimestamp(msg.createdAt)).filter((ts) => ts > 0);
    return timestamps.length > 0 ? Math.min(...timestamps) : 0;
  }
  /**
   * Get maximum timestamp from messages (conversation update time)
   */
  static getMaxTimestamp(chat) {
    const timestamps = chat.map((msg) => this.parseTimestamp(msg.createdAt)).filter((ts) => ts > 0);
    return timestamps.length > 0 ? Math.max(...timestamps) : 0;
  }
  /**
   * Parse ISO 8601 timestamp to Unix seconds
   */
  static parseTimestamp(isoString) {
    try {
      const date = new Date(isoString);
      return Math.floor(date.getTime() / 1e3);
    } catch (error) {
      return 0;
    }
  }
};
__name(LeChatConverter, "LeChatConverter");

// src/providers/lechat/lechat-attachment-extractor.ts
init_utils();
var LeChatAttachmentExtractor = class {
  constructor(plugin, logger6) {
    this.plugin = plugin;
    this.logger = logger6;
    this.zipFileCache = /* @__PURE__ */ new Map();
    this.attachmentMap = null;
    this.allZips = [];
  }
  /**
   * Set attachment map for multi-ZIP support
   */
  setAttachmentMap(attachmentMap, allZips) {
    this.attachmentMap = attachmentMap;
    this.allZips = allZips;
  }
  /**
   * Clear attachment map and ZIPs
   */
  clearAttachmentMap() {
    this.attachmentMap = null;
    this.allZips = [];
    this.zipFileCache.clear();
  }
  /**
   * Extract and save Le Chat attachments
   */
  async extractAttachments(zip, conversationId, attachments, messageId) {
    if (attachments.length === 0) {
      return attachments;
    }
    const processedAttachments = [];
    for (const attachment of attachments) {
      try {
        const result = await this.processAttachment(zip, conversationId, attachment, messageId);
        processedAttachments.push(result);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const context = messageId ? `conversation: ${conversationId}, message: ${messageId}` : `conversation: ${conversationId}`;
        this.logger.error(`Failed to process Le Chat attachment: ${attachment.fileName} (${context})`, errorMessage);
        processedAttachments.push({
          ...attachment,
          status: {
            processed: false,
            found: false,
            reason: "extraction_failed",
            note: `Processing failed: ${errorMessage}`
          }
        });
      }
    }
    return processedAttachments;
  }
  /**
   * Process single attachment
   */
  async processAttachment(zip, conversationId, attachment, messageId) {
    const zipPath = `chat-${conversationId}-files/${attachment.fileName}`;
    let zipFile = this.findFileInZip(zip, zipPath);
    if (!zipFile && this.attachmentMap) {
      const locations = this.attachmentMap.get(attachment.fileName);
      if (locations && locations.length > 0) {
        for (const location of locations) {
          const zipIndex = this.allZips.indexOf(zip);
          if (zipIndex !== -1 && location.zipIndex < this.allZips.length) {
            const targetZip = this.allZips[location.zipIndex];
            zipFile = this.findFileInZip(targetZip, location.path);
            if (zipFile)
              break;
          }
        }
      }
    }
    if (!zipFile) {
      return {
        ...attachment,
        status: {
          processed: false,
          found: false,
          reason: "missing_from_export",
          note: `File not found in ZIP: ${zipPath}`
        }
      };
    }
    const fileContent = await zipFile.async("uint8array");
    let finalFileName = attachment.fileName;
    let finalFileType = attachment.fileType;
    if (!finalFileType || finalFileType === "application/octet-stream") {
      const detected = detectFileFormat(fileContent);
      if (detected.extension && detected.mimeType) {
        finalFileType = detected.mimeType;
        if (!finalFileName.includes(".")) {
          finalFileName = `${finalFileName}.${detected.extension}`;
        }
      }
    }
    const uniqueFileName = this.generateUniqueFileName(finalFileName, conversationId, messageId);
    const category = getFileCategory(uniqueFileName, finalFileType);
    const attachmentFolder = this.plugin.settings.attachmentFolder;
    let vaultPath = `${attachmentFolder}/lechat/${category}/${sanitizeFileName(uniqueFileName)}`;
    const folderPath = vaultPath.substring(0, vaultPath.lastIndexOf("/"));
    await ensureFolderExists(folderPath, this.plugin.app.vault);
    vaultPath = await this.resolveFileConflict(vaultPath);
    await this.plugin.app.vault.adapter.writeBinary(vaultPath, fileContent.buffer);
    return {
      ...attachment,
      fileName: finalFileName,
      fileType: finalFileType,
      fileSize: fileContent.length,
      url: vaultPath,
      status: {
        processed: true,
        found: true,
        localPath: vaultPath
      }
    };
  }
  /**
   * Find file in ZIP with caching
   */
  findFileInZip(zip, path) {
    const cacheKey = `${zip}:${path}`;
    if (this.zipFileCache.has(cacheKey)) {
      return this.zipFileCache.get(cacheKey) || null;
    }
    let file = zip.file(path);
    if (!file) {
      const lowerPath = path.toLowerCase();
      const allFiles = Object.keys(zip.files);
      const matchingPath = allFiles.find((p) => p.toLowerCase() === lowerPath);
      if (matchingPath) {
        file = zip.file(matchingPath);
      }
    }
    this.zipFileCache.set(cacheKey, file);
    return file;
  }
  /**
   * Generate unique filename to avoid conflicts
   * Strategy: lechat_{conversationId}_{messageId}_{timestamp}_{originalName}
   */
  generateUniqueFileName(originalFileName, conversationId, messageId) {
    const timestamp = Date.now();
    const shortConversationId = conversationId.substring(0, 8);
    const shortMessageId = messageId ? messageId.substring(0, 8) : "unknown";
    const extension = originalFileName.includes(".") ? originalFileName.split(".").pop() : "";
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    const safeBaseName = baseName.replace(/[^a-zA-Z0-9_-]/g, "_");
    const uniqueName = `lechat_${shortConversationId}_${shortMessageId}_${timestamp}_${safeBaseName}`;
    return extension ? `${uniqueName}.${extension}` : uniqueName;
  }
  /**
   * Resolve file conflicts by adding numeric suffix
   * Same strategy as ChatGPT provider
   */
  async resolveFileConflict(originalPath) {
    let finalPath = originalPath;
    let counter = 1;
    while (await this.plugin.app.vault.adapter.exists(finalPath)) {
      const lastDot = originalPath.lastIndexOf(".");
      if (lastDot === -1) {
        finalPath = `${originalPath}_${counter}`;
      } else {
        const nameWithoutExt = originalPath.substring(0, lastDot);
        const extension = originalPath.substring(lastDot);
        finalPath = `${nameWithoutExt}_${counter}${extension}`;
      }
      counter++;
    }
    return finalPath;
  }
};
__name(LeChatAttachmentExtractor, "LeChatAttachmentExtractor");

// src/providers/lechat/lechat-report-naming.ts
var LeChatReportNamingStrategy = class {
  /**
   * Extract date prefix from Le Chat ZIP filename
   * 
   * Le Chat ZIP format: chat-export-{timestamp}.zip
   * Example: chat-export-1760124530481.zip
   * 
   * The timestamp is in milliseconds since Unix epoch.
   */
  extractReportPrefix(zipFileName) {
    const importDate = getCurrentImportDate();
    const timestampPattern = /chat-export-(\d{10,13})/;
    const match = zipFileName.match(timestampPattern);
    if (match) {
      const timestamp = parseInt(match[1]);
      const date = new Date(timestamp);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const archiveDate = `${year}.${month}.${day}`;
      return generateReportPrefix(importDate, archiveDate);
    }
    return generateReportPrefix(importDate, importDate);
  }
  /**
   * Get Le Chat provider name
   */
  getProviderName() {
    return "lechat";
  }
  /**
   * Provider-specific column: Attachments
   * Counts the number of file attachments (images, documents) in the conversation
   */
  getProviderSpecificColumn() {
    return {
      header: "Attachments",
      getValue: (adapter, chat) => {
        let attachmentCount = 0;
        if (!Array.isArray(chat)) {
          return 0;
        }
        for (const message of chat) {
          if (message.files && Array.isArray(message.files)) {
            attachmentCount += message.files.length;
          }
        }
        return attachmentCount;
      }
    };
  }
};
__name(LeChatReportNamingStrategy, "LeChatReportNamingStrategy");

// src/providers/lechat/lechat-adapter.ts
var LeChatAdapter = class extends BaseProviderAdapter {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.attachmentExtractor = new LeChatAttachmentExtractor(plugin, plugin.logger);
    this.reportNamingStrategy = new LeChatReportNamingStrategy();
  }
  /**
   * Detect if raw data is from Le Chat
   * 
   * Le Chat format:
   * - Array of messages (not wrapped in conversation object)
   * - Each message has: chatId, contentChunks, createdAt, role
   */
  detect(rawConversations) {
    if (rawConversations.length === 0)
      return false;
    const sample = rawConversations[0];
    return Array.isArray(sample) && sample.length > 0 && sample[0].chatId !== void 0 && sample[0].contentChunks !== void 0 && sample[0].createdAt !== void 0 && sample[0].role !== void 0;
  }
  /**
   * Get conversation ID from first message's chatId field
   */
  getId(chat) {
    var _a;
    return ((_a = chat[0]) == null ? void 0 : _a.chatId) || "";
  }
  /**
   * Get conversation title
   * Derived from first user message (truncated to 50 chars)
   */
  getTitle(chat) {
    const firstUserMessage = chat.find((msg) => msg.role === "user");
    if (firstUserMessage && firstUserMessage.content) {
      const content = firstUserMessage.content.trim();
      if (content.length > 50) {
        return content.substring(0, 50).trim() + "...";
      }
      return content;
    }
    return "Untitled";
  }
  /**
   * Get conversation creation time (minimum message timestamp)
   */
  getCreateTime(chat) {
    const timestamps = chat.map((msg) => this.parseTimestamp(msg.createdAt)).filter((ts) => ts > 0);
    return timestamps.length > 0 ? Math.min(...timestamps) : 0;
  }
  /**
   * Get conversation update time (maximum message timestamp)
   */
  getUpdateTime(chat) {
    const timestamps = chat.map((msg) => this.parseTimestamp(msg.createdAt)).filter((ts) => ts > 0);
    return timestamps.length > 0 ? Math.max(...timestamps) : 0;
  }
  /**
   * Convert Le Chat conversation to StandardConversation
   */
  convertChat(chat) {
    return LeChatConverter.convertChat(chat);
  }
  /**
   * Get provider name
   */
  getProviderName() {
    return "lechat";
  }
  /**
   * Get new messages not in existing message IDs
   */
  getNewMessages(chat, existingMessageIds) {
    return chat.filter((msg) => !existingMessageIds.includes(msg.id));
  }
  /**
   * Get report naming strategy
   */
  getReportNamingStrategy() {
    return this.reportNamingStrategy;
  }
  /**
   * Get attachment extractor (required by BaseProviderAdapter)
   */
  getAttachmentExtractor() {
    return this.attachmentExtractor;
  }
  /**
   * Parse ISO 8601 timestamp to Unix seconds
   */
  parseTimestamp(isoString) {
    try {
      const date = new Date(isoString);
      return Math.floor(date.getTime() / 1e3);
    } catch (error) {
      return 0;
    }
  }
};
__name(LeChatAdapter, "LeChatAdapter");

// src/providers/provider-registry.ts
function createProviderRegistry(plugin) {
  const registry = new DefaultProviderRegistry();
  registry.register("chatgpt", new ChatGPTAdapter(plugin));
  registry.register("claude", new ClaudeAdapter(plugin));
  registry.register("lechat", new LeChatAdapter(plugin));
  return registry;
}
__name(createProviderRegistry, "createProviderRegistry");

// src/ui/import-progress-modal.ts
var import_obsidian16 = require("obsidian");
init_i18n();
var ImportProgressModal = class extends import_obsidian16.Modal {
  constructor(app, fileName) {
    super(app);
    this.totalConversations = 0;
    this.currentConversation = 0;
    this.isSelectiveImport = false;
    this.selectedCount = 0;
    this.totalAvailable = 0;
    this.isComplete = false;
    this.fileName = fileName;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nexus-import-progress-modal");
    this.modalTitleEl = contentEl.createEl("h2", {
      text: t("import_progress.title", { filename: this.fileName }),
      cls: "modal-title"
    });
    const contentContainer = contentEl.createDiv({ cls: "modal-content" });
    this.phaseEl = contentContainer.createEl("div", { cls: "import-phase" });
    this.phaseEl.style.cssText = `
            text-align: center;
            margin: 10px 0;
            font-weight: 600;
            color: var(--text-accent);
            font-size: 1.1em;
        `;
    this.importModeEl = contentContainer.createEl("div", { cls: "import-mode" });
    this.importModeEl.style.cssText = `
            text-align: center;
            margin: 5px 0 10px 0;
            font-weight: 500;
            color: var(--text-accent);
            font-size: 0.85em;
            padding: 4px 8px;
            background: var(--background-secondary);
            border-radius: 4px;
            display: none;
        `;
    this.conversationCountEl = contentContainer.createEl("div", { cls: "conversation-counter" });
    this.conversationCountEl.style.cssText = `
            text-align: center;
            margin: 5px 0 15px 0;
            font-weight: 500;
            color: var(--text-normal);
            font-size: 0.9em;
        `;
    const progressContainer = contentContainer.createDiv({ cls: "progress-container" });
    progressContainer.style.cssText = `
            background: var(--background-secondary);
            border-radius: 8px;
            padding: 4px;
            margin: 20px 0;
            border: 1px solid var(--background-modifier-border);
        `;
    this.progressBarEl = progressContainer.createDiv({ cls: "progress-bar" });
    this.progressBarEl.style.cssText = `
            height: 20px;
            background: linear-gradient(90deg, var(--interactive-accent), var(--interactive-accent-hover));
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        `;
    this.statusEl = contentContainer.createEl("div", { cls: "status-text" });
    this.statusEl.style.cssText = `
            text-align: center;
            margin: 10px 0;
            font-weight: 500;
            color: var(--text-normal);
        `;
    this.detailEl = contentContainer.createEl("div", { cls: "detail-text" });
    this.detailEl.style.cssText = `
            text-align: center;
            margin: 5px 0;
            font-size: 0.85em;
            color: var(--text-muted);
            min-height: 1.2em;
        `;
    this.updateProgress({
      phase: "validation",
      title: t("import_progress.initial.title"),
      detail: t("import_progress.initial.detail")
    });
  }
  /**
   * Update progress with step information
   */
  updateProgress(step) {
    const phaseLabels = {
      "validation": t("common.progress.phase_validation"),
      "scanning": t("common.progress.phase_scanning"),
      "processing": t("common.progress.phase_processing"),
      "writing": t("common.progress.phase_writing"),
      "complete": t("common.progress.phase_complete"),
      "error": t("common.progress.phase_error")
    };
    this.phaseEl.textContent = phaseLabels[step.phase] || step.phase;
    if (step.total !== void 0) {
      this.totalConversations = step.total;
    }
    if (step.current !== void 0) {
      this.currentConversation = step.current;
    }
    if (this.totalConversations > 0) {
      if (this.isSelectiveImport) {
        this.conversationCountEl.textContent = t("import_progress.conversation_counter_selective", { current: String(this.currentConversation), total: String(this.totalConversations) });
      } else {
        this.conversationCountEl.textContent = t("import_progress.conversation_counter", { current: String(this.currentConversation), total: String(this.totalConversations) });
      }
    } else {
      this.conversationCountEl.textContent = "";
    }
    let percentage = 0;
    if (step.percentage !== void 0) {
      percentage = step.percentage;
    } else if (this.totalConversations > 0 && step.phase === "processing") {
      percentage = Math.round(this.currentConversation / this.totalConversations * 100);
    } else {
      const phaseProgress = {
        "validation": 10,
        "scanning": 20,
        "processing": 80,
        "writing": 95,
        "complete": 100,
        "error": 0
      };
      percentage = phaseProgress[step.phase] || 0;
    }
    percentage = Math.min(100, Math.max(0, percentage));
    this.progressBarEl.style.width = `${percentage}%`;
    this.statusEl.textContent = step.title;
    this.detailEl.textContent = step.detail || "";
    if (step.phase === "complete") {
      this.showComplete(step.title);
    } else if (step.phase === "error") {
      this.showError(step.title);
    }
  }
  /**
   * Show completion state
   */
  showComplete(message = t("import_progress.complete.message")) {
    this.isComplete = true;
    this.progressBarEl.style.width = "100%";
    this.progressBarEl.style.background = "var(--text-success)";
    this.statusEl.textContent = message;
    this.detailEl.textContent = t("import_progress.complete.detail");
    this.closeAfterDelay(3e3);
  }
  /**
   * Show error state
   */
  showError(message = t("import_progress.error.message")) {
    this.progressBarEl.style.background = "var(--text-error)";
    this.statusEl.textContent = message;
    this.detailEl.textContent = t("import_progress.error.detail");
  }
  /**
   * Close after delay
   */
  closeAfterDelay(delay = 2e3) {
    setTimeout(() => {
      if (this.isComplete) {
        this.close();
      }
    }, delay);
  }
  /**
   * Set selective import mode
   */
  setSelectiveImportMode(selectedCount, totalAvailable) {
    this.isSelectiveImport = true;
    this.selectedCount = selectedCount;
    this.totalAvailable = totalAvailable;
    this.importModeEl.style.display = "block";
    this.importModeEl.textContent = t("import_progress.selective_mode_indicator", { selected: String(selectedCount), total: String(totalAvailable) });
  }
  /**
   * Get progress callback function
   */
  getProgressCallback() {
    return (step) => {
      this.updateProgress(step);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(ImportProgressModal, "ImportProgressModal");

// src/utils/zip-loader.ts
var import_jszip = __toESM(require_jszip_min());
function streamToBuffer(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(
        Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)
      );
    });
    stream.on(
      "end",
      () => resolve(Buffer.concat(chunks))
    );
    stream.on("error", reject);
  });
}
__name(streamToBuffer, "streamToBuffer");
function openYauzl(filePath) {
  return new Promise((resolve, reject) => {
    const yauzl = require_yauzl();
    yauzl.open(
      filePath,
      { lazyEntries: true, autoClose: false },
      (err, zipfile) => {
        if (err)
          reject(err);
        else
          resolve(zipfile);
      }
    );
  });
}
__name(openYauzl, "openYauzl");
function openEntryStream(zipfile, entry) {
  return new Promise((resolve, reject) => {
    zipfile.openReadStream(
      entry,
      (err, stream) => {
        if (err)
          reject(err);
        else
          resolve(stream);
      }
    );
  });
}
__name(openEntryStream, "openEntryStream");
function readSlice(file, start, length) {
  if (length <= 0)
    return Promise.resolve(new ArrayBuffer(0));
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => {
      var _a;
      return reject((_a = reader.error) != null ? _a : new Error("[zip-loader] FileReader error"));
    };
    reader.readAsArrayBuffer(file.slice(start, start + length));
  });
}
__name(readSlice, "readSlice");
async function findEOCD(file) {
  const searchSize = Math.min(65557, file.size);
  const buffer = await readSlice(file, file.size - searchSize, searchSize);
  const view = new DataView(buffer);
  for (let i = buffer.byteLength - 22; i >= 0; i--) {
    if (view.getUint32(i, true) !== 101010256)
      continue;
    const entryCount = view.getUint16(i + 10, true);
    const cdSize = view.getUint32(i + 12, true);
    const cdOffset = view.getUint32(i + 16, true);
    if (cdOffset === 4294967295 || entryCount === 65535 || cdSize === 4294967295) {
      return null;
    }
    return { cdOffset, cdSize, entryCount };
  }
  return null;
}
__name(findEOCD, "findEOCD");
async function parseCentralDirectory(file, cdOffset, cdSize) {
  const buffer = await readSlice(file, cdOffset, cdSize);
  const view = new DataView(buffer);
  const decoder = new TextDecoder("utf-8");
  const entries = [];
  let pos = 0;
  while (pos + 46 <= buffer.byteLength) {
    if (view.getUint32(pos, true) !== 33639248)
      break;
    const compressionMethod = view.getUint16(pos + 10, true);
    const compressedSize32 = view.getUint32(pos + 20, true);
    const uncompressedSize32 = view.getUint32(pos + 24, true);
    const nameLength = view.getUint16(pos + 28, true);
    const extraLength = view.getUint16(pos + 30, true);
    const commentLength = view.getUint16(pos + 32, true);
    const localHeaderOffset32 = view.getUint32(pos + 42, true);
    const nameBytes = new Uint8Array(buffer, pos + 46, nameLength);
    const name = decoder.decode(nameBytes);
    let compressedSize = compressedSize32;
    let uncompressedSize = uncompressedSize32;
    let localHeaderOffset = localHeaderOffset32;
    if (extraLength > 0) {
      const extraStart = pos + 46 + nameLength;
      let extraPos = 0;
      while (extraPos + 4 <= extraLength) {
        const headerId = view.getUint16(extraStart + extraPos, true);
        const dataSize = view.getUint16(
          extraStart + extraPos + 2,
          true
        );
        if (headerId === 1 && dataSize >= 8) {
          let z64Pos = extraStart + extraPos + 4;
          if (uncompressedSize32 === 4294967295 && z64Pos + 8 <= extraStart + extraPos + 4 + dataSize) {
            uncompressedSize = Number(
              view.getBigUint64(z64Pos, true)
            );
            z64Pos += 8;
          }
          if (compressedSize32 === 4294967295 && z64Pos + 8 <= extraStart + extraPos + 4 + dataSize) {
            compressedSize = Number(
              view.getBigUint64(z64Pos, true)
            );
            z64Pos += 8;
          }
          if (localHeaderOffset32 === 4294967295 && z64Pos + 8 <= extraStart + extraPos + 4 + dataSize) {
            localHeaderOffset = Number(
              view.getBigUint64(z64Pos, true)
            );
          }
        }
        extraPos += 4 + dataSize;
      }
    }
    if (!name.endsWith("/")) {
      entries.push({
        name,
        compressionMethod,
        compressedSize,
        uncompressedSize,
        localHeaderOffset
      });
    }
    pos += 46 + nameLength + extraLength + commentLength;
  }
  return entries;
}
__name(parseCentralDirectory, "parseCentralDirectory");
async function decompressEntry(file, entry) {
  if (entry.compressedSize === 0)
    return new Uint8Array(0);
  const localHeader = await readSlice(file, entry.localHeaderOffset, 30);
  const localView = new DataView(localHeader);
  if (localView.getUint32(0, true) !== 67324752) {
    throw new Error(
      `[zip-loader] Invalid local file header for "${entry.name}"`
    );
  }
  const localNameLen = localView.getUint16(26, true);
  const localExtraLen = localView.getUint16(28, true);
  const dataOffset = entry.localHeaderOffset + 30 + localNameLen + localExtraLen;
  const compressedData = await readSlice(
    file,
    dataOffset,
    entry.compressedSize
  );
  if (entry.compressionMethod === 0) {
    return new Uint8Array(compressedData);
  }
  if (entry.compressionMethod === 8) {
    if (typeof DecompressionStream === "undefined") {
      throw new Error("[zip-loader] DecompressionStream unavailable");
    }
    const ds = new DecompressionStream("deflate-raw");
    const chunks = [];
    await new ReadableStream({
      start(controller) {
        controller.enqueue(new Uint8Array(compressedData));
        controller.close();
      }
    }).pipeThrough(ds).pipeTo(
      new WritableStream({
        write(chunk) {
          chunks.push(chunk);
        }
      })
    );
    const totalLength = chunks.reduce((acc, c) => acc + c.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }
  throw new Error(
    `[zip-loader] Unsupported compression method ${entry.compressionMethod} for "${entry.name}"`
  );
}
__name(decompressEntry, "decompressEntry");
async function loadZipSelectiveMobile(file, shouldInclude) {
  console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] loadZipSelectiveMobile: findEOCD start (${file.size} bytes)`);
  const eocd = await findEOCD(file);
  if (!eocd)
    throw new Error(
      "[zip-loader] ZIP64 or invalid ZIP \u2014 using JSZip fallback"
    );
  console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] loadZipSelectiveMobile: EOCD found \u2014 cdOffset=${eocd.cdOffset} cdSize=${eocd.cdSize} entries=${eocd.entryCount}`);
  const entries = await parseCentralDirectory(
    file,
    eocd.cdOffset,
    eocd.cdSize
  );
  console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] loadZipSelectiveMobile: CD parsed \u2014 ${entries.length} non-dir entries`);
  const resultZip = new import_jszip.default();
  let included = 0;
  let skipped = 0;
  for (const entry of entries) {
    if (shouldInclude && !shouldInclude(entry.name, entry.uncompressedSize)) {
      skipped++;
      continue;
    }
    included++;
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] decompressEntry: "${entry.name}" compressed=${entry.compressedSize} uncompressed=${entry.uncompressedSize}`);
    const data = await decompressEntry(file, entry);
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] decompressEntry: "${entry.name}" done \u2014 ${data.byteLength} bytes`);
    resultZip.file(entry.name, data);
  }
  console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] loadZipSelectiveMobile: done \u2014 included=${included} skipped=${skipped}`);
  return resultZip;
}
__name(loadZipSelectiveMobile, "loadZipSelectiveMobile");
async function enumerateZipEntriesMobile(file) {
  const eocd = await findEOCD(file);
  if (!eocd)
    throw new Error(
      "[zip-loader] ZIP64 or invalid ZIP \u2014 using JSZip fallback"
    );
  const entries = await parseCentralDirectory(
    file,
    eocd.cdOffset,
    eocd.cdSize
  );
  return entries.map((e) => ({ path: e.name, size: e.uncompressedSize }));
}
__name(enumerateZipEntriesMobile, "enumerateZipEntriesMobile");
async function loadZipSelective(file, shouldInclude) {
  const filePath = file.path;
  if (!filePath) {
    try {
      return await loadZipSelectiveMobile(file, shouldInclude);
    } catch (mobileErr) {
      console.error(`[NexusAI] loadZipSelectiveMobile failed, falling back to JSZip:`, mobileErr);
      const zip = new import_jszip.default();
      return zip.loadAsync(file);
    }
  }
  const resultZip = new import_jszip.default();
  let zipfile;
  try {
    zipfile = await openYauzl(filePath);
  } catch (e) {
    const zip = new import_jszip.default();
    return zip.loadAsync(file);
  }
  await new Promise((resolve, reject) => {
    zipfile.on("error", (err) => {
      zipfile.close();
      reject(err);
    });
    zipfile.on("end", () => {
      zipfile.close();
      resolve();
    });
    zipfile.on("entry", async (entry) => {
      try {
        if (shouldInclude && !shouldInclude(entry.fileName, entry.uncompressedSize)) {
          zipfile.readEntry();
          return;
        }
        if (entry.fileName.endsWith("/")) {
          resultZip.folder(entry.fileName.slice(0, -1));
          zipfile.readEntry();
          return;
        }
        const stream = await openEntryStream(zipfile, entry);
        const buffer = await streamToBuffer(stream);
        resultZip.file(entry.fileName, new Uint8Array(buffer), {
          date: entry.getLastModDate ? entry.getLastModDate() : new Date()
        });
        zipfile.readEntry();
      } catch (entryErr) {
        console.warn(
          `[zip-loader] Skipping entry "${entry.fileName}": ${entryErr}`
        );
        zipfile.readEntry();
      }
    });
    zipfile.readEntry();
  });
  return resultZip;
}
__name(loadZipSelective, "loadZipSelective");
async function enumerateZipEntries(file) {
  const filePath = file.path;
  if (!filePath) {
    try {
      return await enumerateZipEntriesMobile(file);
    } catch (e) {
      const zip = new import_jszip.default();
      const content = await zip.loadAsync(file);
      return Object.entries(content.files).filter(([, f]) => !f.dir).map(([path, f]) => {
        var _a, _b;
        return {
          path,
          size: (_b = (_a = f._data) == null ? void 0 : _a.uncompressedSize) != null ? _b : 0
        };
      });
    }
  }
  const entries = [];
  let zipfile;
  try {
    zipfile = await openYauzl(filePath);
  } catch (e) {
    const zip = new import_jszip.default();
    const content = await zip.loadAsync(file);
    return Object.entries(content.files).filter(([, f]) => !f.dir).map(([path, f]) => {
      var _a, _b;
      return {
        path,
        size: (_b = (_a = f._data) == null ? void 0 : _a.uncompressedSize) != null ? _b : 0
      };
    });
  }
  await new Promise((resolve, reject) => {
    zipfile.on("error", (err) => {
      zipfile.close();
      reject(err);
    });
    zipfile.on("end", () => {
      zipfile.close();
      resolve();
    });
    zipfile.on("entry", (entry) => {
      if (!entry.fileName.endsWith("/")) {
        entries.push({
          path: entry.fileName,
          size: entry.uncompressedSize
        });
      }
      zipfile.readEntry();
    });
    zipfile.readEntry();
  });
  return entries;
}
__name(enumerateZipEntries, "enumerateZipEntries");
async function enumerateZipEntriesRaw(file, filter) {
  let eocd;
  try {
    eocd = await findEOCD(file);
  } catch (e) {
    return [];
  }
  if (!eocd)
    return [];
  let all;
  try {
    all = await parseCentralDirectory(file, eocd.cdOffset, eocd.cdSize);
  } catch (e) {
    return [];
  }
  const files = all.filter((e) => !e.name.endsWith("/"));
  return filter ? files.filter((e) => filter(e.name, e.uncompressedSize)) : files;
}
__name(enumerateZipEntriesRaw, "enumerateZipEntriesRaw");
async function decompressZipEntry(file, entry) {
  return decompressEntry(file, entry);
}
__name(decompressZipEntry, "decompressZipEntry");

// src/services/attachment-map-builder.ts
var AttachmentMapBuilder = class {
  constructor(logger6) {
    this.logger = logger6;
  }
  /**
   * Scan all ZIP files and build a map of available attachments
   * Processes ZIPs in order (oldest to newest) so newer versions are at the end
   */
  async buildAttachmentMap(files) {
    const attachmentMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      try {
        const entries = await enumerateZipEntries(file);
        for (const entry of entries) {
          const fileIds = this.extractFileIds(entry.path);
          for (const fileId of fileIds) {
            if (!attachmentMap.has(fileId)) {
              attachmentMap.set(fileId, []);
            }
            const locations = attachmentMap.get(fileId);
            locations.push({
              zipIndex: i,
              path: entry.path,
              size: entry.size,
              zipFileName: file.name
            });
          }
        }
      } catch (error) {
        this.logger.error(`Failed to scan attachments in ${file.name}:`, error);
      }
    }
    return attachmentMap;
  }
  /**
   * Extract all possible file IDs from a file path
   * Handles various ChatGPT export formats:
   * - file_XXXXX.dat → ["file_XXXXX", "XXXXX"]
   * - user-xxx/file_XXXXX-uuid.png → ["file_XXXXX", "XXXXX"]
   * - dalle-generations/xxx.png → ["xxx"]
   */
  extractFileIds(path) {
    const fileIds = [];
    const fileName = path.split("/").pop() || "";
    const filePattern = /file_([a-f0-9]+)/i;
    const fileMatch = fileName.match(filePattern);
    if (fileMatch) {
      fileIds.push(`file_${fileMatch[1]}`);
      fileIds.push(fileMatch[1]);
    }
    const modernPattern = /^(file-[A-Za-z0-9]+)-/;
    const modernMatch = fileName.match(modernPattern);
    if (modernMatch) {
      const fullId = modernMatch[1];
      if (!fileIds.includes(fullId)) {
        fileIds.push(fullId);
      }
      const idOnly = fullId.substring(5);
      if (idOnly && !fileIds.includes(idOnly)) {
        fileIds.push(idOnly);
      }
    }
    const hashPattern = /^([a-f0-9]{32,})(?:[-.]|$)/i;
    const hashMatch = fileName.match(hashPattern);
    if (hashMatch && !fileMatch) {
      fileIds.push(hashMatch[1]);
    }
    const baseFileName = fileName.replace(/\.(dat|png|jpg|jpeg|gif|webp)$/i, "");
    if (baseFileName && !fileIds.includes(baseFileName)) {
      fileIds.push(baseFileName);
    }
    return fileIds;
  }
  /**
   * Find the best location for a file ID
   * Returns the NEWEST available location (last in array)
   * Falls back to older locations if needed
   */
  findBestLocation(attachmentMap, fileId) {
    const locations = attachmentMap.get(fileId);
    if (!locations || locations.length === 0) {
      return null;
    }
    return locations[locations.length - 1];
  }
  /**
   * Find all locations for a file ID (for debugging/logging)
   */
  findAllLocations(attachmentMap, fileId) {
    return attachmentMap.get(fileId) || [];
  }
};
__name(AttachmentMapBuilder, "AttachmentMapBuilder");

// src/services/archive-mode-decider.ts
var ZIP_LARGE_ARCHIVE_THRESHOLD_BYTES = 100 * 1024 * 1024;
var UNCOMPRESSED_LARGE_ARCHIVE_THRESHOLD_BYTES = 250 * 1024 * 1024;
function decideArchiveMode(context) {
  const { zipSizeBytes, conversationsUncompressedBytes } = context;
  if (typeof conversationsUncompressedBytes === "number" && conversationsUncompressedBytes >= UNCOMPRESSED_LARGE_ARCHIVE_THRESHOLD_BYTES) {
    return {
      mode: "large-archive",
      reason: "uncompressed-too-large"
    };
  }
  if (zipSizeBytes >= ZIP_LARGE_ARCHIVE_THRESHOLD_BYTES) {
    return {
      mode: "large-archive",
      reason: "zip-too-large"
    };
  }
  return {
    mode: "normal",
    reason: "within-threshold"
  };
}
__name(decideArchiveMode, "decideArchiveMode");

// src/utils/lazy-zip.ts
var LazyZipObject = class {
  constructor(file, entry) {
    this._file = file;
    this._entry = entry;
    this.name = entry.name;
    this.dir = entry.name.endsWith("/");
  }
  async async(type) {
    const data = await decompressZipEntry(this._file, this._entry);
    if (type === "uint8array")
      return data;
    if (type === "string") {
      return new TextDecoder("utf-8").decode(data);
    }
    if (type === "base64") {
      const CHUNK = 8192;
      let binary = "";
      for (let i = 0; i < data.byteLength; i += CHUNK) {
        binary += String.fromCharCode(
          ...data.subarray(i, Math.min(i + CHUNK, data.byteLength))
        );
      }
      return btoa(binary);
    }
    throw new Error(`[LazyZip] Unsupported output type: "${type}"`);
  }
};
__name(LazyZipObject, "LazyZipObject");
var LazyZip = class {
  constructor(sourceFile, entries) {
    this.files = {};
    for (const entry of entries) {
      this.files[entry.name] = new LazyZipObject(sourceFile, entry);
    }
  }
  /**
   * Look up an entry by name, matching JSZip's `zip.file(name)` API.
   * Returns null (not undefined) when not found, so callers using
   * `if (!zip.file(name))` continue to work correctly.
   */
  file(name) {
    var _a;
    return (_a = this.files[name]) != null ? _a : null;
  }
};
__name(LazyZip, "LazyZip");

// src/utils/streaming-json-array-parser.ts
var StreamingJsonArrayParser = class {
  /**
   * Stream objects from a JSON payload that contains a conversations array.
   *
   * Supports two shapes:
   * - ChatGPT:        [ { ... }, { ... }, ... ]
   * - Claude:  { ..., "conversations": [ { ... }, ... ], ... }
   */
  static *streamConversations(json) {
    const arraySlice = this.extractConversationsArray(json);
    for (const element of this.streamArrayElements(arraySlice)) {
      try {
        yield JSON.parse(element);
      } catch (error) {
        continue;
      }
    }
  }
  /**
   * Extract the raw JSON for the conversations array.
   * Returns a substring representing `[ {...}, {...}, ... ]`.
   */
  static extractConversationsArray(json) {
    const trimmed = json.trimStart();
    if (trimmed.startsWith("[")) {
      const offset = json.length - trimmed.length;
      const start2 = offset;
      const end2 = this.findMatchingBracket(json, start2, "[");
      return json.slice(start2, end2 + 1);
    }
    const keyIndex = json.indexOf('"conversations"');
    if (keyIndex === -1) {
      throw new Error("Could not find conversations array in JSON payload");
    }
    let i = keyIndex + '"conversations"'.length;
    const len = json.length;
    while (i < len && json[i] !== ":")
      i++;
    if (i >= len) {
      throw new Error("Invalid JSON: missing ':' after conversations key");
    }
    i++;
    while (i < len && /\s/.test(json[i]))
      i++;
    if (i >= len || json[i] !== "[") {
      throw new Error("Invalid JSON: conversations value is not an array");
    }
    const start = i;
    const end = this.findMatchingBracket(json, start, "[");
    return json.slice(start, end + 1);
  }
  /**
   * Stream element substrings from a JSON array like `[ {...}, {...} ]`.
   * Handles nested objects/arrays and quoted strings with escapes.
   */
  static *streamArrayElements(arrayJson) {
    const len = arrayJson.length;
    let i = 0;
    while (i < len && /\s/.test(arrayJson[i]))
      i++;
    if (i >= len || arrayJson[i] !== "[") {
      throw new Error("Expected '[' at start of JSON array");
    }
    i++;
    while (i < len) {
      while (i < len && /\s/.test(arrayJson[i]))
        i++;
      if (i >= len)
        break;
      if (arrayJson[i] === "]")
        break;
      const start = i;
      let depth = 0;
      let inString = false;
      let escape = false;
      while (i < len) {
        const ch = arrayJson[i];
        if (inString) {
          if (escape) {
            escape = false;
          } else if (ch === "\\") {
            escape = true;
          } else if (ch === '"') {
            inString = false;
          }
        } else {
          if (ch === '"') {
            inString = true;
          } else if (ch === "{" || ch === "[") {
            depth++;
          } else if (ch === "}" || ch === "]") {
            depth--;
            if (depth < 0) {
              throw new Error("Invalid JSON array: unbalanced brackets");
            }
            if (depth === 0) {
              i++;
              break;
            }
          }
        }
        i++;
      }
      const element = arrayJson.slice(start, i).trim();
      if (element.length > 0) {
        yield element;
      }
      while (i < len && /\s/.test(arrayJson[i]))
        i++;
      if (i < len && arrayJson[i] === ",") {
        i++;
      }
    }
  }
  /**
   * Find the matching closing bracket for `[` starting at startIndex.
   */
  static findMatchingBracket(source, startIndex, open) {
    const close = open === "[" ? "]" : "}";
    const len = source.length;
    let depth = 0;
    let inString = false;
    let escape = false;
    for (let i = startIndex; i < len; i++) {
      const ch = source[i];
      if (inString) {
        if (escape) {
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (ch === '"') {
          inString = false;
        }
      } else {
        if (ch === '"') {
          inString = true;
        } else if (ch === open) {
          depth++;
        } else if (ch === close) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
    }
    throw new Error("No matching closing bracket found in JSON source");
  }
};
__name(StreamingJsonArrayParser, "StreamingJsonArrayParser");

// src/utils/zip-content-reader.ts
function findGeminiActivityJsonFiles(fileNames) {
  const geminiJsonFiles = [];
  for (const name of fileNames) {
    if (!name.toLowerCase().endsWith(".json"))
      continue;
    const segments = name.split("/");
    if (segments.length >= 3 && segments[0] === "Takeout") {
      const thirdLevel = segments[2];
      if (thirdLevel.toLowerCase().includes("gemini")) {
        geminiJsonFiles.push(name);
      }
    }
  }
  return geminiJsonFiles;
}
__name(findGeminiActivityJsonFiles, "findGeminiActivityJsonFiles");
async function extractRawConversations(zip) {
  const fileNames = Object.keys(zip.files);
  const leChatFiles = fileNames.filter((name) => /^chat-[a-f0-9-]+\.json$/.test(name));
  if (leChatFiles.length > 0) {
    const conversations = [];
    let uncompressedBytes = 0;
    for (const fileName of leChatFiles) {
      const f = zip.file(fileName);
      if (!f)
        continue;
      const content = await f.async("string");
      uncompressedBytes += content.length;
      conversations.push(JSON.parse(content));
    }
    return { conversations, uncompressedBytes };
  }
  const geminiJsonFiles = findGeminiActivityJsonFiles(fileNames);
  if (geminiJsonFiles.length > 0) {
    const activityFilePath = geminiJsonFiles[0];
    const activityFile = zip.file(activityFilePath);
    if (!activityFile) {
      throw new NexusAiChatImporterError(
        "Missing Gemini activity JSON",
        "The ZIP file appears to contain a Gemini folder but the My Activity JSON file is missing."
      );
    }
    const activityJson = await activityFile.async("string");
    try {
      const conversations = [];
      for (const entry of StreamingJsonArrayParser.streamConversations(activityJson)) {
        conversations.push(entry);
      }
      if (conversations.length === 0) {
        throw new NexusAiChatImporterError(
          "Empty Gemini export",
          "No entries found in the Gemini My Activity JSON file."
        );
      }
      return { conversations, uncompressedBytes: activityJson.length };
    } catch (error) {
      if (error instanceof NexusAiChatImporterError)
        throw error;
      throw new NexusAiChatImporterError(
        "Invalid Gemini My Activity JSON structure",
        "The Gemini My Activity JSON file does not contain a valid array of activity entries."
      );
    }
  }
  const numberedConvFiles = fileNames.filter((n) => /^conversations-\d+\.json$/.test(n)).sort();
  if (numberedConvFiles.length > 0) {
    const conversations = [];
    let uncompressedBytes = 0;
    for (const fileName of numberedConvFiles) {
      const f = zip.file(fileName);
      if (!f)
        continue;
      const json = await f.async("string");
      uncompressedBytes += json.length;
      for (const conv of StreamingJsonArrayParser.streamConversations(json)) {
        conversations.push(conv);
      }
    }
    if (conversations.length === 0) {
      throw new NexusAiChatImporterError(
        "No conversations found",
        "The numbered conversation files (conversations-NNN.json) are all empty."
      );
    }
    return { conversations, uncompressedBytes };
  }
  const conversationsFile = zip.file("conversations.json");
  if (!conversationsFile) {
    throw new NexusAiChatImporterError(
      "Missing conversations.json",
      "The ZIP file does not contain a conversations.json file, chat-{uuid}.json files, or a Gemini My Activity JSON file."
    );
  }
  const conversationsJson = await conversationsFile.async("string");
  try {
    const conversations = [];
    for (const conv of StreamingJsonArrayParser.streamConversations(conversationsJson)) {
      conversations.push(conv);
    }
    if (conversations.length === 0) {
      throw new NexusAiChatImporterError(
        "No conversations found",
        "The conversations.json file exists but contains no conversations."
      );
    }
    return { conversations, uncompressedBytes: conversationsJson.length };
  } catch (error) {
    if (error instanceof NexusAiChatImporterError)
      throw error;
    throw new NexusAiChatImporterError(
      "Invalid conversations.json structure",
      "The conversations.json file does not contain a valid conversation array."
    );
  }
}
__name(extractRawConversations, "extractRawConversations");

// src/utils/conversation-filter.ts
init_logger();
function filterConversationsByIds(rawConversations, selectedIds, providerRegistry, forcedProvider) {
  if (!rawConversations || rawConversations.length === 0)
    return [];
  if (!selectedIds || selectedIds.length === 0)
    return [];
  const selectedIdsSet = new Set(selectedIds);
  const detectedProvider = forcedProvider || providerRegistry.detectProvider(rawConversations);
  const adapter = detectedProvider !== "unknown" ? providerRegistry.getAdapter(detectedProvider) : void 0;
  const getConversationId = /* @__PURE__ */ __name((conversation) => {
    var _a, _b;
    if (adapter && typeof adapter.getId === "function") {
      try {
        const id = adapter.getId(conversation);
        if (id && typeof id === "string") {
          return id;
        }
      } catch (error) {
        logger.error(
          `Error getting conversation ID using adapter for provider ${detectedProvider}`,
          error
        );
      }
    }
    try {
      if (forcedProvider === "lechat" || Array.isArray(conversation) && ((_a = conversation[0]) == null ? void 0 : _a.chatId)) {
        return ((_b = conversation[0]) == null ? void 0 : _b.chatId) || "";
      }
      if (forcedProvider === "claude" || conversation && conversation.uuid && conversation.name) {
        return conversation.uuid || "";
      }
      return conversation && conversation.id || "";
    } catch (e) {
      return "";
    }
  }, "getConversationId");
  return rawConversations.filter((conversation) => {
    const conversationId = getConversationId(conversation);
    if (!conversationId)
      return false;
    return selectedIdsSet.has(conversationId);
  });
}
__name(filterConversationsByIds, "filterConversationsByIds");

// src/services/import-service.ts
var MOBILE_SKIP_EXTS = /* @__PURE__ */ new Set([
  "mp3",
  "m4a",
  "mp4",
  "webm",
  "ogg",
  "aac",
  "wav",
  "flac",
  "opus",
  "wma",
  "mov",
  "avi",
  "mkv",
  "dat"
]);
var DEFAULT_MOBILE_FILTER = /* @__PURE__ */ __name((name, _size) => {
  var _a, _b;
  if (name.endsWith(".json"))
    return true;
  const ext = (_b = (_a = name.split(".").pop()) == null ? void 0 : _a.toLowerCase()) != null ? _b : "";
  return !MOBILE_SKIP_EXTS.has(ext);
}, "DEFAULT_MOBILE_FILTER");
var ImportService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.importReport = new ImportReport();
    this.currentAttachmentMap = null;
    this.currentZips = [];
    this.providerRegistry = createProviderRegistry(plugin);
    this.attachmentMapBuilder = new AttachmentMapBuilder(plugin.logger);
    this.conversationProcessor = new ConversationProcessor(plugin, this.providerRegistry);
  }
  /**
   * Set or clear the Gemini index on the Gemini adapter.
   *
   * When an index JSON generated by the browser extension is provided,
   * this enables hash-based reconstruction of full Gemini conversations.
   */
  setGeminiIndex(index) {
    var _a, _b;
    const adapter = this.providerRegistry.getAdapter("gemini");
    if (adapter && typeof adapter.setIndex === "function") {
      adapter.setIndex(index);
      const status = index ? `loaded (conversations=${(_b = (_a = index.conversations) == null ? void 0 : _a.length) != null ? _b : 0})` : "cleared";
      this.plugin.logger.info(`[Gemini] Index ${status} on ImportService adapter`);
    } else {
      this.plugin.logger.warn("[Gemini] Unable to set index: Gemini adapter not found or setIndex() missing");
    }
  }
  async selectZipFile() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".zip";
    input.multiple = true;
    input.onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length > 0) {
        const sortedFiles = this.sortFilesByTimestamp(files);
        for (const file of sortedFiles) {
          await this.handleZipFile(file);
        }
      }
    };
    input.click();
  }
  sortFilesByTimestamp(files) {
    return files.sort((a, b) => {
      const timestampRegex = /(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2})/;
      const getTimestamp = /* @__PURE__ */ __name((filename) => {
        const match = filename.match(timestampRegex);
        if (!match) {
          this.plugin.logger.warn(`No timestamp found in filename: ${filename}`);
          return "0";
        }
        return match[1];
      }, "getTimestamp");
      return getTimestamp(a.name).localeCompare(getTimestamp(b.name));
    });
  }
  async handleZipFile(file, forcedProvider, selectedConversationIds, sharedReport) {
    var _a;
    const fileName = file.name.toLowerCase();
    if (!fileName.endsWith(".zip")) {
      const errorMessage = `Invalid file format: "${file.name}"

Only ZIP files are supported. The file must have a .zip extension.

\u{1F4DD} Known Issue: When downloading Claude exports with Firefox on Mac, the file may have a .dat extension instead of .zip. Simply rename the file to change the extension from .dat to .zip, then try importing again.

Do NOT extract and re-compress the file - just rename it!`;
      new import_obsidian17.Notice(errorMessage, 1e4);
      this.plugin.logger.error("Invalid file extension", {
        fileName: file.name,
        expectedExtension: ".zip"
      });
      throw new NexusAiChatImporterError(
        "Invalid file format",
        errorMessage
      );
    }
    const isSharedReport = !!sharedReport;
    this.importReport = sharedReport || new ImportReport();
    if (!isSharedReport && this.plugin.settings.useCustomMessageTimestampFormat) {
      this.importReport.setCustomTimestampFormat(this.plugin.settings.messageTimestampFormat);
    }
    this.importReport.startFileSection(file.name);
    this.conversationProcessor.resetCounters();
    const storage = this.plugin.getStorageService();
    let processingStarted = false;
    const progressModal = new ImportProgressModal(this.plugin.app, file.name);
    const progressCallback = progressModal.getProgressCallback();
    progressModal.open();
    if (selectedConversationIds && selectedConversationIds.length > 0) {
    }
    try {
      progressCallback({
        phase: "validation",
        title: "Validating ZIP structure...",
        detail: "Checking file format and contents"
      });
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [1/4 catalog] Reading ZIP Central Directory: ${file.name} (${file.size} bytes, mobile=${!file.path})`);
      const fileNames = await this.validateZipFile(file, forcedProvider);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [1/4 catalog] Done \u2014 ${fileNames.length} entries listed, 0 bytes decompressed, provider=${forcedProvider != null ? forcedProvider : "auto-detect"}`);
      const adapter = forcedProvider ? this.providerRegistry.getAdapter(forcedProvider) : void 0;
      const adapterFilter = (_a = adapter == null ? void 0 : adapter.shouldIncludeZipEntry) == null ? void 0 : _a.bind(adapter);
      const isMobile = !file.path;
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [2/4 decompress] Loading ZIP entries (mobile=${isMobile}, filter=${adapterFilter ? "custom" : isMobile ? "default-mobile" : "all"})`);
      let zip;
      if (isMobile) {
        const mobileFilter = /* @__PURE__ */ __name((name, size) => {
          if (!DEFAULT_MOBILE_FILTER(name, size))
            return false;
          return adapterFilter ? adapterFilter(name, size) : true;
        }, "mobileFilter");
        const lazyEntries = await enumerateZipEntriesRaw(file, mobileFilter);
        if (lazyEntries.length === 0) {
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [2/4 decompress] ZIP64/fallback \u2014 using loadZipSelective`);
          zip = await loadZipSelective(file, mobileFilter);
        } else {
          zip = new LazyZip(file, lazyEntries);
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [2/4 decompress] LazyZip ready \u2014 ${lazyEntries.length} entries indexed, 0 bytes decompressed`);
        }
      } else {
        zip = await loadZipSelective(file, adapterFilter);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [2/4 decompress] Done \u2014 ${Object.keys(zip.files).length} entries in memory`);
      }
      let isReprocess = false;
      let fileHash = "";
      if (!isSharedReport) {
        progressCallback({
          phase: "validation",
          title: "Validating file...",
          detail: "Checking file hash and import history"
        });
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [3/4 hash] Computing file hash (legacy mode, mobile=${!file.path})`);
        fileHash = await getFileHash(file);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [3/4 hash] Done: ${fileHash.substring(0, 16)}...`);
        const foundByHash = storage.isArchiveImported(fileHash);
        const foundByName = storage.isArchiveImported(file.name);
        isReprocess = foundByHash || foundByName;
        if (isReprocess) {
          progressModal.close();
          const shouldReimport = await showDialog(
            this.plugin.app,
            "confirmation",
            "Already processed",
            [
              `File ${file.name} has already been imported.`,
              `Do you want to reprocess it?`,
              `**Note:** This will recreate notes from before v1.1.0 to add attachment support.`
            ],
            void 0,
            { button1: "Let's do this", button2: "Skip this file" }
          );
          if (!shouldReimport) {
            new import_obsidian17.Notice(`Skipping ${file.name} (already imported).`);
            progressModal.close();
            return;
          }
          progressModal.open();
        }
      } else {
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [3/4 hash] Computing file hash (shared mode, mobile=${!file.path})`);
        fileHash = await getFileHash(file);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [3/4 hash] Done`);
      }
      processingStarted = true;
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [4/4 import] processConversations start`);
      await this.processConversations(
        zip,
        file,
        isReprocess,
        forcedProvider,
        progressCallback,
        selectedConversationIds,
        progressModal,
        file.size
      );
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [4/4 import] processConversations done`);
      storage.addImportedArchive(fileHash, file.name);
      await this.plugin.saveSettings();
      progressCallback({
        phase: "complete",
        title: "Import completed successfully!",
        detail: `Processed ${this.conversationProcessor.getCounters().totalNewConversationsToImport + this.conversationProcessor.getCounters().totalExistingConversationsToUpdate} conversations`
      });
    } catch (error) {
      const message = error instanceof NexusAiChatImporterError ? error.message : error instanceof Error ? error.message : "An unknown error occurred";
      this.plugin.logger.error("Error handling zip file", { message });
      console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleZipFile] FAILED ${file.name}: ${message}`);
      progressModal.close();
      if (isSharedReport) {
        sharedReport.addError(`Skipped: ${file.name}`, message);
        new import_obsidian17.Notice(`Skipped ${file.name}: ${message}`, 6e3);
      } else {
        await showDialog(
          this.plugin.app,
          "information",
          "Import failed",
          [message, "Please check the import report for more details."]
        );
      }
    } finally {
      if (processingStarted && !isSharedReport) {
        await this.writeImportReport(file.name);
        if (!progressModal.isComplete) {
          new import_obsidian17.Notice(
            this.importReport.hasErrors() ? "An error occurred during import. Please check the log file for details." : "Import completed. Log file created in the archive folder."
          );
        }
      }
    }
  }
  /**
   * Validate ZIP structure using enumerateZipEntries (zero decompression).
   * Returns file names on success; throws NexusAiChatImporterError on failure.
   *
   * Fix 1: Uses enumerateZipEntries instead of loadZipSelective so we never
   * decompress any entry just to check file names — critical for mobile OOM.
   * Fix 3: Structural provider validation from file names (ChatGPT vs Claude).
   */
  async validateZipFile(file, forcedProvider) {
    try {
      const entries = await enumerateZipEntries(file);
      const fileNames = entries.map((e) => e.path);
      if (fileNames.length === 0) {
        throw new NexusAiChatImporterError(
          "Empty ZIP file",
          "The ZIP file contains no files. Please check that you selected the correct export file."
        );
      }
      const geminiJsonFiles = findGeminiActivityJsonFiles(fileNames);
      const hasGeminiActivityJson = geminiJsonFiles.length > 0;
      const hasUsersJson = fileNames.includes("users.json");
      const hasUserJson = fileNames.includes("user.json");
      const hasMsgFeedback = fileNames.includes("message_feedback.json");
      if (forcedProvider) {
        if (forcedProvider === "lechat") {
          const hasLeChatFiles = fileNames.some((name) => /^chat-[a-f0-9-]+\.json$/.test(name));
          if (!hasLeChatFiles) {
            throw new NexusAiChatImporterError(
              "Wrong Provider Selected",
              "No Le Chat conversation files (chat-<uuid>.json) found in this ZIP. Please select the correct provider for this export."
            );
          }
        } else if (forcedProvider === "gemini") {
          if (!hasGeminiActivityJson) {
            throw new NexusAiChatImporterError(
              "Wrong Provider Selected",
              "No Gemini activity JSON found in this ZIP. Expected a Google Takeout export with a folder like:\nTakeout/<My Activity>/<*Gemini*>/My Activity.json"
            );
          }
        } else {
          const hasConversations = fileNames.includes("conversations.json") || fileNames.some((n) => /^conversations-\d+\.json$/.test(n));
          if (!hasConversations) {
            throw new NexusAiChatImporterError(
              "Invalid ZIP structure",
              `Missing required file: conversations.json (or conversations-NNN.json) for ${forcedProvider} provider.`
            );
          }
          if (forcedProvider === "chatgpt" && hasUsersJson && !hasUserJson) {
            throw new NexusAiChatImporterError(
              "Wrong Provider Selected",
              "This ZIP appears to be a Claude export (contains users.json), not ChatGPT. Please select Claude as the provider and try again."
            );
          }
          if (forcedProvider === "claude" && hasUserJson && hasMsgFeedback && !hasUsersJson) {
            throw new NexusAiChatImporterError(
              "Wrong Provider Selected",
              "This ZIP appears to be a ChatGPT export (contains user.json + message_feedback.json), not Claude. Please select ChatGPT as the provider and try again."
            );
          }
        }
      } else {
        const hasConversationsJson = fileNames.includes("conversations.json") || fileNames.some((n) => /^conversations-\d+\.json$/.test(n));
        const hasProjectsJson = fileNames.includes("projects.json");
        const hasLeChatFiles = fileNames.some((name) => /^chat-[a-f0-9-]+\.json$/.test(name));
        const isChatGPTFormat = hasConversationsJson && !hasUsersJson && !hasProjectsJson;
        const isClaudeFormat = hasConversationsJson && hasUsersJson;
        const isLeChatFormat = hasLeChatFiles && !hasConversationsJson;
        const isGeminiFormat = hasGeminiActivityJson && !hasConversationsJson && !hasLeChatFiles;
        if (!isChatGPTFormat && !isClaudeFormat && !isLeChatFormat && !isGeminiFormat) {
          throw new NexusAiChatImporterError(
            "Unrecognized Export Format",
            "This ZIP file doesn't match any supported chat export format.\n\nSupported formats:\n\u2022 ChatGPT \u2014 contains conversations.json (without users.json)\n\u2022 Claude \u2014 contains conversations.json + users.json\n\u2022 Le Chat \u2014 contains chat-<uuid>.json files\n\u2022 Gemini \u2014 Google Takeout with Takeout/<Activity>/<*Gemini*>/My Activity.json"
          );
        }
      }
      return fileNames;
    } catch (error) {
      if (error instanceof NexusAiChatImporterError) {
        throw error;
      }
      if (error.message && error.message.includes("corrupted")) {
        throw new NexusAiChatImporterError(
          "Corrupted ZIP file",
          "The file appears to be corrupted or is not a valid ZIP file. Please try downloading the export again from your AI provider."
        );
      }
      throw new NexusAiChatImporterError(
        "Error reading ZIP file",
        `Failed to read the ZIP file: ${error.message || "Unknown error"}. Please ensure the file is a valid ZIP export from ChatGPT, Claude, Le Chat, or Gemini.`
      );
    }
  }
  async processConversations(zip, file, isReprocess, forcedProvider, progressCallback, selectedConversationIds, progressModal, zipSizeBytes) {
    try {
      progressCallback == null ? void 0 : progressCallback({
        phase: "scanning",
        title: "Extracting conversations...",
        detail: "Reading conversation data from ZIP file"
      });
      const extractionResult = await this.extractRawConversationsFromZip(zip, zipSizeBytes);
      let rawConversations = extractionResult.conversations;
      const archiveModeDecision = extractionResult.archiveModeDecision;
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [4/4 extract] ${rawConversations.length} conversations found in ZIP`);
      if (selectedConversationIds && selectedConversationIds.length > 0) {
        const originalCount = rawConversations.length;
        rawConversations = this.filterConversationsByIds(rawConversations, selectedConversationIds, forcedProvider);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [4/4 filter] ${rawConversations.length}/${originalCount} conversations selected for import`);
        if (progressModal) {
          progressModal.setSelectiveImportMode(rawConversations.length, originalCount);
        }
        progressCallback == null ? void 0 : progressCallback({
          phase: "scanning",
          title: "Filtering conversations...",
          detail: `Selected ${rawConversations.length} of ${originalCount} conversations for import`,
          total: rawConversations.length
        });
      }
      progressCallback == null ? void 0 : progressCallback({
        phase: "scanning",
        title: "Scanning existing conversations...",
        detail: "Checking vault for existing conversations",
        total: rawConversations.length
      });
      const detectedProvider = forcedProvider != null ? forcedProvider : this.providerRegistry.detectProvider(rawConversations);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [4/4 detect] provider=${detectedProvider}${forcedProvider ? " (forced)" : " (auto-detected)"}`);
      if (forcedProvider) {
        this.validateProviderMatch(rawConversations, forcedProvider);
      }
      const processingDetail = (archiveModeDecision == null ? void 0 : archiveModeDecision.mode) === "large-archive" ? "Processing a large archive using a streaming-safe pipeline" : "Converting and importing conversations";
      progressCallback == null ? void 0 : progressCallback({
        phase: "processing",
        title: "Processing conversations...",
        detail: processingDetail,
        current: 0,
        total: rawConversations.length
      });
      const report = await this.conversationProcessor.processRawConversations(
        rawConversations,
        this.importReport,
        zip,
        isReprocess,
        forcedProvider,
        progressCallback
      );
      this.importReport = report;
      this.importReport.setFileCounters(
        this.conversationProcessor.getCounters()
      );
      rawConversations.length = 0;
      progressCallback == null ? void 0 : progressCallback({
        phase: "writing",
        title: "Finalizing import...",
        detail: "Saving settings and generating report"
      });
    } catch (error) {
      if (error instanceof NexusAiChatImporterError) {
        this.plugin.logger.error("Error processing conversations", error.message);
        this.plugin.logger.error("Full NexusAiChatImporterError:", error);
      } else if (typeof error === "object" && error instanceof Error) {
        this.plugin.logger.error("General error processing conversations", error.message);
        this.plugin.logger.error("Full Error:", error);
        this.plugin.logger.error("Stack trace:", error.stack);
      } else {
        this.plugin.logger.error("Unknown error processing conversations", "An unknown error occurred");
        this.plugin.logger.error("Unknown error:", error);
      }
      throw error;
    }
  }
  /**
   * Extract raw conversation data without knowing provider specifics
   * and decide archive mode based on ZIP and uncompressed sizes.
   *
   * Fix 2 (DRY): delegates format detection to the shared extractRawConversations()
   * in zip-content-reader.ts. Archive-mode decision remains here since it is
   * specific to the import pipeline (metadata extractor does not need it).
   */
  async extractRawConversationsFromZip(zip, zipSizeBytes) {
    const { conversations, uncompressedBytes } = await extractRawConversations(zip);
    let archiveModeDecision;
    if (typeof zipSizeBytes === "number") {
      archiveModeDecision = decideArchiveMode({
        zipSizeBytes,
        conversationsUncompressedBytes: uncompressedBytes
      });
      if (archiveModeDecision.mode === "large-archive") {
        this.plugin.logger.info(
          `Large archive detected (reason: ${archiveModeDecision.reason}, zipSizeBytes=${zipSizeBytes}, uncompressedBytes=${uncompressedBytes})`
        );
      }
    }
    return { conversations, archiveModeDecision };
  }
  /**
   * Filter conversations by selected IDs
   */
  filterConversationsByIds(rawConversations, selectedIds, forcedProvider) {
    return filterConversationsByIds(
      rawConversations,
      selectedIds,
      this.providerRegistry,
      forcedProvider
    );
  }
  /**
   * Validate that the forced provider matches the actual content structure
   */
  validateProviderMatch(rawConversations, forcedProvider) {
    if (rawConversations.length === 0)
      return;
    const firstConversation = rawConversations[0];
    const isChatGPT = firstConversation.mapping !== void 0;
    const isClaude = firstConversation.chat_messages !== void 0 || firstConversation.name !== void 0 || firstConversation.summary !== void 0;
    const isLeChat = Array.isArray(firstConversation) && firstConversation.length > 0 && firstConversation[0].chatId !== void 0 && firstConversation[0].contentChunks !== void 0;
    const isGemini = !!firstConversation && typeof firstConversation.header === "string" && typeof firstConversation.title === "string" && typeof firstConversation.time === "string" && (Array.isArray(firstConversation.safeHtmlItem) || Array.isArray(firstConversation.activityControls) || Array.isArray(firstConversation.products));
    if (forcedProvider === "chatgpt" && !isChatGPT) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected ChatGPT but this archive appears to be from another provider. The structure doesn't match ChatGPT exports."
      );
    }
    if (forcedProvider === "claude" && !isClaude) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected Claude but this archive appears to be from another provider. The structure doesn't match Claude exports."
      );
    }
    if (forcedProvider === "lechat" && !isLeChat) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected Le Chat but this archive appears to be from another provider. The structure doesn't match Le Chat exports."
      );
    }
    if (forcedProvider === "gemini" && !isGemini) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected Gemini but this archive appears to be from another provider. The structure doesn't match Gemini My Activity exports."
      );
    }
  }
  async writeImportReport(zipFileName) {
    const reportWriter = new ReportWriter(this.plugin, this.providerRegistry);
    const currentProvider = this.conversationProcessor.getCurrentProvider();
    await reportWriter.writeReport(this.importReport, zipFileName, currentProvider);
  }
  /**
   * Build attachment map for multi-ZIP import
   * Opens all ZIPs and scans for available attachments
   */
  async buildAttachmentMapForMultiZip(files, provider) {
    var _a, _b, _c;
    try {
      const adapter = provider ? this.providerRegistry.getAdapter(provider) : void 0;
      const entryFilter = (_a = adapter == null ? void 0 : adapter.shouldIncludeZipEntry) == null ? void 0 : _a.bind(adapter);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] Building attachment map: ${files.length} files, provider=${provider != null ? provider : "auto"}`);
      this.currentAttachmentMap = await this.attachmentMapBuilder.buildAttachmentMap(files);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] Attachment map built: ${(_c = (_b = this.currentAttachmentMap) == null ? void 0 : _b.size) != null ? _c : 0} entries`);
      this.currentZips = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const isMobile = !file.path;
        try {
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] [${i + 1}/${files.length}] Opening ${file.name} (${(file.size / 1024 / 1024).toFixed(0)} MB, mobile=${isMobile})`);
          let zipContent;
          if (isMobile) {
            const mobileFilter = entryFilter ? (name, size) => DEFAULT_MOBILE_FILTER(name, 0) && entryFilter(name, size) : DEFAULT_MOBILE_FILTER;
            const lazyEntries = await enumerateZipEntriesRaw(file, mobileFilter);
            zipContent = lazyEntries.length > 0 ? new LazyZip(file, lazyEntries) : await loadZipSelective(file, mobileFilter);
          } else {
            zipContent = await loadZipSelective(file, entryFilter);
          }
          this.currentZips.push(zipContent);
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] [${i + 1}/${files.length}] ${file.name}: ${Object.keys(zipContent.files).length} entries indexed`);
        } catch (error) {
          this.plugin.logger.error(`Failed to open ZIP for attachment map: ${file.name}`, error);
          console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] [${i + 1}/${files.length}] FAILED: ${file.name}:`, error instanceof Error ? error.message : error);
        }
      }
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [attachmap] Done \u2014 ${this.currentZips.length}/${files.length} ZIPs indexed`);
      const chatgptAdapter = this.providerRegistry.getAdapter("chatgpt");
      if (chatgptAdapter && this.currentAttachmentMap) {
        chatgptAdapter.setAttachmentMap(this.currentAttachmentMap, this.currentZips);
      }
    } catch (error) {
      this.plugin.logger.error("Error building attachment map:", error);
      throw error;
    }
  }
  /**
   * Clear attachment map and close ZIPs after import completes
   */
  clearAttachmentMap() {
    this.currentAttachmentMap = null;
    this.currentZips = [];
    const chatgptAdapter = this.providerRegistry.getAdapter("chatgpt");
    if (chatgptAdapter) {
      chatgptAdapter.clearAttachmentMap();
    }
  }
};
__name(ImportService, "ImportService");
var ReportWriter = class {
  constructor(plugin, providerRegistry) {
    this.plugin = plugin;
    this.providerRegistry = providerRegistry;
  }
  async writeReport(report, zipFileName, provider) {
    const reportInfo = this.getReportGenerationInfo(zipFileName, provider);
    const adapter = this.providerRegistry.getAdapter(provider);
    if (adapter) {
      const strategy = adapter.getReportNamingStrategy();
      const columnInfo = strategy.getProviderSpecificColumn();
      report.setProviderSpecificColumnHeader(columnInfo.header);
    }
    const folderResult = await ensureFolderExists(reportInfo.folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      this.plugin.logger.error(`Failed to create or access log folder: ${reportInfo.folderPath}`, folderResult.error);
      new import_obsidian17.Notice("Failed to create log file. Check console for details.");
      return;
    }
    let logFilePath = `${reportInfo.folderPath}/${reportInfo.baseFileName}`;
    let counter = 2;
    while (await this.plugin.app.vault.adapter.exists(logFilePath)) {
      const baseName = reportInfo.baseFileName.replace(" - import report.md", "");
      logFilePath = `${reportInfo.folderPath}/${baseName}-${counter} - import report.md`;
      counter++;
    }
    const currentDate = new Date().toISOString();
    const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
    const logContent = `---
importdate: ${currentDate}
archivedate: ${archiveDate}
zipFile: ${zipFileName}
provider: ${provider}
totalSuccessfulImports: ${report.getCreatedCount()}
totalUpdatedImports: ${report.getUpdatedCount()}
totalSkippedImports: ${report.getSkippedCount()}
---

${report.generateReportContent()}
`;
    try {
      await this.plugin.app.vault.create(logFilePath, logContent);
    } catch (error) {
      this.plugin.logger.error(`Failed to write import log`, error.message);
      new import_obsidian17.Notice("Failed to create log file. Check console for details.");
    }
  }
  getReportGenerationInfo(zipFileName, provider) {
    const reportFolder = this.plugin.settings.reportFolder;
    const adapter = this.providerRegistry.getAdapter(provider);
    if (adapter) {
      const strategy = adapter.getReportNamingStrategy();
      const reportPrefix = strategy.extractReportPrefix(zipFileName);
      return {
        folderPath: `${reportFolder}/${strategy.getProviderName()}`,
        baseFileName: `${reportPrefix} - import report.md`
      };
    }
    const now = new Date();
    const importDate = `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, "0")}.${String(now.getDate()).padStart(2, "0")}`;
    const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
    const fallbackPrefix = `imported-${importDate}-archive-${archiveDate}`;
    return {
      folderPath: `${reportFolder}`,
      baseFileName: `${fallbackPrefix} - import report.md`
    };
  }
  extractArchiveDateFromFilename(zipFileName) {
    const dateRegex = /(\d{4})-(\d{2})-(\d{2})/;
    const match = zipFileName.match(dateRegex);
    if (match) {
      const [, year, month, day] = match;
      return `${year}.${month}.${day}`;
    }
    const now = new Date();
    return `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, "0")}.${String(now.getDate()).padStart(2, "0")}`;
  }
};
__name(ReportWriter, "ReportWriter");

// src/main.ts
init_storage_service();

// src/upgrade/incremental-upgrade-manager.ts
var import_obsidian25 = require("obsidian");
init_version_utils();
init_dialogs();
init_logger();
init_constants();

// src/upgrade/utils/multi-operation-progress-modal.ts
var import_obsidian18 = require("obsidian");
init_i18n();
var MultiOperationProgressModal = class extends import_obsidian18.Modal {
  constructor(app, title, operations) {
    super(app);
    this.canClose = false;
    this.title = title;
    this.operations = [...operations];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nexus-ai-chat-importer-modal");
    contentEl.addClass("multi-operation-progress-modal");
    this.modalTitleEl = contentEl.createEl("h2", {
      text: this.title,
      cls: "modal-title"
    });
    const contentContainer = contentEl.createDiv({ cls: "modal-content" });
    this.operationsContainer = contentContainer.createDiv({ cls: "operations-container" });
    this.operationsContainer.style.cssText = `
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        `;
    this.overallProgressEl = contentContainer.createDiv({ cls: "overall-progress" });
    this.overallProgressEl.style.cssText = `
            margin-top: 20px;
            padding: 15px;
            background: var(--background-secondary);
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            text-align: center;
            font-weight: 500;
        `;
    this.renderOperations();
    this.updateOverallProgress();
    this.modalEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !this.canClose) {
        e.preventDefault();
        e.stopPropagation();
      }
    });
  }
  /**
   * Update operation status
   */
  updateOperation(operationId, updates) {
    const operation = this.operations.find((op) => op.id === operationId);
    if (operation) {
      Object.assign(operation, updates);
      this.renderOperations();
      this.updateOverallProgress();
    }
  }
  /**
   * Mark all operations as complete and allow closing
   */
  markComplete(message = t("upgrade.multi_operation_modal.mark_complete_default")) {
    this.canClose = true;
    this.overallProgressEl.textContent = message;
    this.overallProgressEl.style.color = "var(--text-success)";
    if (!this.closeButtonEl) {
      const buttonContainer = this.contentEl.createDiv({ cls: "modal-button-container" });
      this.closeButtonEl = buttonContainer.createEl("button", {
        text: t("upgrade.multi_operation_modal.buttons.complete"),
        cls: "mod-cta"
      });
      this.closeButtonEl.addEventListener("click", () => this.close());
    }
  }
  /**
   * Show error state
   */
  showError(message) {
    this.canClose = true;
    this.overallProgressEl.textContent = message;
    this.overallProgressEl.style.color = "var(--text-error)";
    if (!this.closeButtonEl) {
      const buttonContainer = this.contentEl.createDiv({ cls: "modal-button-container" });
      this.closeButtonEl = buttonContainer.createEl("button", {
        text: t("upgrade.multi_operation_modal.buttons.close"),
        cls: "mod-warning"
      });
      this.closeButtonEl.addEventListener("click", () => this.close());
    }
  }
  /**
   * Render all operations
   */
  renderOperations() {
    this.operationsContainer.empty();
    for (const operation of this.operations) {
      const operationEl = this.operationsContainer.createDiv({ cls: "operation-item" });
      operationEl.style.cssText = `
                display: flex;
                align-items: center;
                margin: 10px 0;
                padding: 10px;
                background: var(--background-primary);
                border-radius: 6px;
                border: 1px solid var(--background-modifier-border);
            `;
      const iconEl = operationEl.createDiv({ cls: "operation-icon" });
      iconEl.style.cssText = `
                width: 20px;
                height: 20px;
                margin-right: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
            `;
      switch (operation.status) {
        case "pending":
          iconEl.textContent = "\u25CB";
          iconEl.style.color = "var(--text-muted)";
          break;
        case "running":
          iconEl.textContent = "\u26A0";
          iconEl.style.color = "var(--text-accent)";
          break;
        case "completed":
          iconEl.textContent = "\u2713";
          iconEl.style.color = "var(--text-success)";
          break;
        case "failed":
          iconEl.textContent = "\u2717";
          iconEl.style.color = "var(--text-error)";
          break;
      }
      const contentEl = operationEl.createDiv({ cls: "operation-content" });
      contentEl.style.cssText = `flex: 1; min-width: 0;`;
      const nameEl = contentEl.createDiv({ cls: "operation-name" });
      nameEl.textContent = operation.name;
      nameEl.style.cssText = `
                font-weight: 500;
                margin-bottom: 5px;
                color: var(--text-normal);
            `;
      if (operation.status === "running" || operation.progress !== void 0 && operation.progress > 0) {
        const progressContainer = contentEl.createDiv({ cls: "progress-container" });
        progressContainer.style.cssText = `
                    background: var(--background-secondary);
                    border-radius: 4px;
                    height: 8px;
                    margin: 5px 0;
                    overflow: hidden;
                `;
        const progressBar = progressContainer.createDiv({ cls: "progress-bar" });
        const progress = operation.progress || 0;
        progressBar.style.cssText = `
                    background: var(--interactive-accent);
                    height: 100%;
                    width: ${progress}%;
                    transition: width 0.3s ease;
                `;
      }
      if (operation.currentDetail) {
        const detailEl = contentEl.createDiv({ cls: "operation-detail" });
        detailEl.textContent = this.truncateDetail(operation.currentDetail);
        detailEl.style.cssText = `
                    font-size: 0.9em;
                    color: var(--text-muted);
                    font-style: italic;
                    margin-top: 3px;
                `;
      }
      if (operation.status === "failed" && operation.error) {
        const errorEl = contentEl.createDiv({ cls: "operation-error" });
        errorEl.textContent = operation.error;
        errorEl.style.cssText = `
                    font-size: 0.9em;
                    color: var(--text-error);
                    margin-top: 3px;
                `;
      }
    }
  }
  /**
   * Update overall progress display
   */
  updateOverallProgress() {
    const completed = this.operations.filter((op) => op.status === "completed").length;
    const failed = this.operations.filter((op) => op.status === "failed").length;
    const total = this.operations.length;
    if (failed > 0) {
      this.overallProgressEl.textContent = t("upgrade.multi_operation_modal.progress_with_failures", { completed: String(completed), total: String(total), failed: String(failed) });
      this.overallProgressEl.style.color = "var(--text-error)";
    } else if (completed === total) {
      this.overallProgressEl.textContent = t("upgrade.multi_operation_modal.all_completed", { total: String(total) });
      this.overallProgressEl.style.color = "var(--text-success)";
    } else {
      this.overallProgressEl.textContent = t("upgrade.multi_operation_modal.progress_label", { completed: String(completed), total: String(total) });
      this.overallProgressEl.style.color = "var(--text-normal)";
    }
  }
  /**
   * Truncate detail text to fit in modal
   */
  truncateDetail(detail) {
    const maxLength = 50;
    if (detail.length <= maxLength)
      return detail;
    return "..." + detail.slice(-maxLength + 3);
  }
  /**
   * Override close to respect canClose flag
   */
  close() {
    if (this.canClose) {
      super.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(MultiOperationProgressModal, "MultiOperationProgressModal");

// src/upgrade/incremental-upgrade-manager.ts
init_utils();
var logger4 = new Logger();
var IncrementalUpgradeManager = class {
  constructor(plugin) {
    this.availableUpgrades = [];
    this.plugin = plugin;
    this.registerUpgrades();
  }
  /**
   * Register all available version upgrades
   */
  registerUpgrades() {
    const { Upgrade110: Upgrade1102 } = (init_upgrade_1_1_0(), __toCommonJS(upgrade_1_1_0_exports));
    const { Upgrade120: Upgrade1202 } = (init_upgrade_1_2_0(), __toCommonJS(upgrade_1_2_0_exports));
    const { Upgrade130: Upgrade1302 } = (init_upgrade_1_3_0(), __toCommonJS(upgrade_1_3_0_exports));
    const { Upgrade140: Upgrade1402 } = (init_upgrade_1_4_0(), __toCommonJS(upgrade_1_4_0_exports));
    this.availableUpgrades = [
      new Upgrade1102(),
      new Upgrade1202(),
      new Upgrade1302(),
      new Upgrade1402()
    ];
    this.availableUpgrades.sort((a, b) => {
      return VersionUtils.compareVersions(a.version, b.version);
    });
  }
  /**
   * Main incremental upgrade check and execution
   */
  async checkAndPerformUpgrade() {
    var _a, _b, _c;
    try {
      const currentVersion = this.plugin.manifest.version;
      const previousVersion = this.plugin.settings.previousVersion;
      const data = await this.plugin.loadData();
      const versionKey = currentVersion.replace(/\./g, "_");
      const hasCompletedThisUpgrade = (_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedUpgrades) == null ? void 0 : _b[versionKey]) == null ? void 0 : _c.completed;
      if (hasCompletedThisUpgrade) {
        return null;
      }
      const isFreshInstall = await this.detectFreshInstall();
      if (isFreshInstall) {
        await this.markUpgradeComplete(currentVersion);
        return {
          success: true,
          upgradesExecuted: 0,
          upgradesSkipped: 0,
          upgradesFailed: 0,
          isFreshInstall: true,
          // Flag for showing installation welcome dialog
          results: []
        };
      }
      if (previousVersion === currentVersion) {
        return null;
      }
      const upgradeChain = this.getUpgradeChain(previousVersion, currentVersion);
      if (upgradeChain.length === 0) {
        await this.markUpgradeComplete(currentVersion);
        return {
          success: true,
          upgradesExecuted: 0,
          upgradesSkipped: 0,
          upgradesFailed: 0,
          showCompletionDialog: true,
          upgradedToVersion: currentVersion,
          results: []
        };
      }
      const result = await this.executeUpgradeChainWithModal(upgradeChain, previousVersion, currentVersion);
      await this.markUpgradeComplete(currentVersion);
      try {
        await this.writeUpgradeReport(previousVersion, currentVersion, upgradeChain, result);
      } catch (e) {
        logger4.error("Failed to write upgrade report:", e);
      }
      return {
        ...result,
        showCompletionDialog: true,
        upgradedToVersion: currentVersion
      };
    } catch (error) {
      logger4.error("Incremental upgrade failed:", error);
      if (error instanceof Error && error.message === "User cancelled upgrade") {
        new import_obsidian25.Notice("Migration cancelled. Please complete the migration before importing.");
        return {
          success: false,
          upgradesExecuted: 0,
          upgradesSkipped: 0,
          upgradesFailed: 0,
          results: []
        };
      }
      logger4.error("Error during incremental upgrade:", error);
      new import_obsidian25.Notice("Upgrade failed - see console for details");
      return {
        success: false,
        upgradesExecuted: 0,
        upgradesSkipped: 0,
        upgradesFailed: 1,
        results: []
      };
    }
  }
  /**
   * Detect if this is a fresh installation with no existing data
   */
  async detectFreshInstall() {
    try {
      const data = await this.plugin.loadData();
      const hasLegacyData = !!((data == null ? void 0 : data.conversationCatalog) && Object.keys(data.conversationCatalog).length > 0);
      const hasImportedArchives = !!((data == null ? void 0 : data.importedArchives) && Object.keys(data.importedArchives).length > 0);
      const conversationFolder = this.plugin.settings.conversationFolder;
      const allFiles = this.plugin.app.vault.getMarkdownFiles();
      const existingConversations = allFiles.filter((file) => {
        var _a;
        if (!file.path.startsWith(conversationFolder))
          return false;
        const relativePath = file.path.substring(conversationFolder.length + 1);
        if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
          return false;
        }
        const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return (frontmatter == null ? void 0 : frontmatter.nexus) === this.plugin.manifest.id;
      });
      const hasExistingConversations = existingConversations.length > 0;
      const isFreshInstall = !hasLegacyData && !hasImportedArchives && !hasExistingConversations;
      return isFreshInstall;
    } catch (error) {
      logger4.error("Error detecting fresh install:", error);
      return false;
    }
  }
  /**
   * Get chain of upgrades to execute incrementally
   */
  getUpgradeChain(fromVersion, toVersion) {
    return this.availableUpgrades.filter(
      (upgrade) => upgrade.shouldRun(fromVersion, toVersion)
    );
  }
  /**
   * Execute upgrade chain with modal progress tracking
   */
  async executeUpgradeChainWithModal(upgradeChain, fromVersion, toVersion) {
    const allOperations = [];
    for (const upgrade of upgradeChain) {
      for (const operation of upgrade.automaticOperations) {
        allOperations.push({
          id: `${upgrade.version}_${operation.id}`,
          name: operation.name,
          status: "pending"
        });
      }
    }
    const progressModal = new MultiOperationProgressModal(
      this.plugin.app,
      `Upgrading to v${toVersion}`,
      allOperations
    );
    progressModal.open();
    const results = [];
    let upgradesExecuted = 0;
    let upgradesSkipped = 0;
    let upgradesFailed = 0;
    try {
      for (const upgrade of upgradeChain) {
        const context = await this.createUpgradeContext(upgrade, fromVersion, toVersion);
        const automaticResults = await this.executeOperationsWithProgress(
          upgrade.automaticOperations,
          context,
          upgrade.version,
          progressModal
        );
        const manualResults = { success: true, results: [] };
        results.push({
          version: upgrade.version,
          automaticResults,
          manualResults
        });
        upgradesExecuted++;
      }
      const overallSuccess = true;
      progressModal.markComplete(`All operations completed successfully!`);
      await new Promise((resolve) => setTimeout(resolve, 450));
      progressModal.close();
      return {
        success: overallSuccess,
        upgradesExecuted,
        upgradesSkipped,
        upgradesFailed,
        results
      };
    } catch (error) {
      logger4.error("Modal upgrade execution failed:", error);
      progressModal.showError(`Upgrade failed: ${error}`);
      throw error;
    }
  }
  /**
   * Execute operations with progress updates to modal
   */
  async executeOperationsWithProgress(operations, context, version, progressModal) {
    const results = [];
    let criticalFailures = 0;
    for (const operation of operations) {
      const modalOperationId = `${version}_${operation.id}`;
      try {
        if (await this.isOperationCompleted(operation.id, version)) {
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100
          });
          results.push({
            operationId: operation.id,
            result: { success: true, message: "Already completed" }
          });
          continue;
        }
        progressModal.updateOperation(modalOperationId, {
          status: "running",
          progress: 0
        });
        if (!await operation.canRun(context)) {
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100,
            currentDetail: "Nothing to process"
          });
          results.push({
            operationId: operation.id,
            result: { success: true, message: "Prerequisites not met - nothing to process" }
          });
          continue;
        }
        const result = await this.executeOperationWithProgress(
          operation,
          context,
          modalOperationId,
          progressModal
        );
        results.push({ operationId: operation.id, result });
        if (result.success) {
          await this.markOperationCompleted(operation.id, version);
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100
          });
        } else {
          const isCritical = this.isCriticalFailure(result);
          if (isCritical) {
            criticalFailures++;
            progressModal.updateOperation(modalOperationId, {
              status: "failed",
              error: result.message
            });
          } else {
            progressModal.updateOperation(modalOperationId, {
              status: "completed",
              progress: 100,
              currentDetail: "Completed with warnings"
            });
          }
        }
      } catch (error) {
        const errorResult = {
          success: false,
          message: `Operation failed: ${error}`,
          details: { error: String(error) }
        };
        results.push({ operationId: operation.id, result: errorResult });
        progressModal.updateOperation(modalOperationId, {
          status: "failed",
          error: String(error)
        });
        criticalFailures++;
      }
    }
    return { success: criticalFailures === 0, results };
  }
  /**
   * Determine if an operation failure is critical
   */
  isCriticalFailure(result) {
    return false;
  }
  /**
   * Execute single operation with progress callbacks
   */
  async executeOperationWithProgress(operation, context, modalOperationId, progressModal) {
    const contextWithProgress = {
      ...context,
      onProgress: (progress, detail) => {
        progressModal.updateOperation(modalOperationId, {
          status: "running",
          progress,
          currentDetail: detail
        });
      }
    };
    const result = await operation.execute(contextWithProgress);
    progressModal.updateOperation(modalOperationId, {
      status: "running",
      progress: 100
    });
    return result;
  }
  /**
   * Create upgrade context
   */
  async createUpgradeContext(upgrade, fromVersion, toVersion) {
    const pluginData = await this.plugin.loadData();
    return {
      plugin: this.plugin,
      fromVersion,
      toVersion,
      pluginData
    };
  }
  /**
   * Mark overall upgrade as complete
   */
  async markUpgradeComplete(version) {
    const data = await this.plugin.loadData() || {};
    if (!data.upgradeHistory) {
      data.upgradeHistory = {
        completedUpgrades: {},
        completedOperations: {}
      };
    }
    const versionKey = version.replace(/\./g, "_");
    data.upgradeHistory.completedUpgrades[versionKey] = {
      version,
      date: new Date().toISOString(),
      completed: true
    };
    data.lastVersion = version;
    data.hasCompletedUpgrade = true;
    data.upgradeDate = new Date().toISOString();
    if (VersionUtils.compareVersions(version, "1.1.0") >= 0) {
      data.versionTrackingEnabled = true;
    }
    await this.plugin.saveData(data);
  }
  /**
   * Write a consolidated upgrade report per run
   */
  async writeUpgradeReport(fromVersion, toVersion, upgradeChain, result) {
    var _a, _b, _c, _d;
    const reportRoot = this.plugin.settings.reportFolder || "Nexus/Reports";
    const upgradesFolder = `${reportRoot}/Upgrades`;
    const folderResult = await ensureFolderExists(upgradesFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      logger4.error(`\u274C Failed to create folder: ${folderResult.error}`);
      throw new Error(`Failed to create upgrades folder: ${folderResult.error}`);
    }
    const now = new Date();
    const pad = /* @__PURE__ */ __name((n) => n.toString().padStart(2, "0"), "pad");
    const ts = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    const fileName = `${ts} - Upgrade to ${toVersion}.md`;
    const filePath = `${upgradesFolder}/${fileName}`;
    const opsByVersion = {};
    for (const up of upgradeChain) {
      opsByVersion[up.version] = {};
      for (const op of up.automaticOperations) {
        opsByVersion[up.version][op.id] = op.name;
      }
    }
    const readmeUrl = `${GITHUB.REPO_BASE}#readme`;
    const issuesUrl = `${GITHUB.REPO_BASE}/issues`;
    const totalVersions = result.results.length;
    const totalOps = result.results.reduce((acc, v) => {
      var _a2, _b2;
      return acc + (((_b2 = (_a2 = v.automaticResults) == null ? void 0 : _a2.results) == null ? void 0 : _b2.length) || 0);
    }, 0);
    let md = `# Upgrade to v${toVersion}

`;
    md += `From v${fromVersion} \u2192 v${toVersion}

`;
    md += `- Versions processed: ${totalVersions}
`;
    md += `- Operations executed: ${totalOps}

`;
    md += `See the latest README and release notes: ${readmeUrl}

`;
    md += `Report or review issues: ${issuesUrl}

`;
    for (const entry of result.results) {
      md += `## ${entry.version}

`;
      const ops = ((_a = entry.automaticResults) == null ? void 0 : _a.results) || [];
      if (!ops.length) {
        md += `- No automatic operations

`;
        continue;
      }
      for (const opRes of ops) {
        const opId = opRes.operationId;
        const opName = ((_b = opsByVersion[entry.version]) == null ? void 0 : _b[opId]) || opId;
        const ok = ((_c = opRes.result) == null ? void 0 : _c.success) === true;
        const status = ok ? "\u2705" : "\u26A0\uFE0F";
        const msg = ((_d = opRes.result) == null ? void 0 : _d.message) || "";
        md += `### ${opName} ${status}

`;
        if (msg)
          md += `${msg}

`;
      }
    }
    try {
      await this.plugin.app.vault.create(filePath, md);
    } catch (error) {
      logger4.error(`\u274C Failed to write report file:`, error);
      logger4.error(`Error details:`, {
        message: error instanceof Error ? error.message : String(error),
        filePath,
        contentLength: md.length
      });
      throw error;
    }
  }
  /**
   * Show upgrade complete dialog AFTER migrations
   * Displays support section + What's New + Improvements + Bug Fixes
   */
  /**
   * Show upgrade completion dialog
   * PUBLIC method - called from main.ts after checkAndPerformUpgrade() returns
   * This ensures styles.css is fully loaded by Obsidian
   */
  async showUpgradeCompleteDialog(version) {
    try {
      const isV130OrLater = this.compareVersions(version, "1.3.0") >= 0;
      if (isV130OrLater) {
        const { UpgradeCompleteModal: UpgradeCompleteModal2 } = await Promise.resolve().then(() => (init_upgrade_complete_modal(), upgrade_complete_modal_exports));
        new UpgradeCompleteModal2(this.plugin.app, this.plugin, version).open();
      } else {
        new import_obsidian25.Notice(`Upgraded to Nexus AI Chat Importer v${version}`);
      }
    } catch (error) {
      logger4.error("Error showing upgrade complete dialog:", error);
      new import_obsidian25.Notice(`Upgraded to Nexus AI Chat Importer v${version}`);
    }
  }
  /**
   * Show upgrade dialog - INFORMATION ONLY (no cancel)
   * @deprecated - No longer used in v1.3.0+, kept for compatibility
   */
  async showUpgradeDialog(currentVersion, lastVersion, upgradeChain) {
    try {
      const overview = await this.fetchReleaseOverview(currentVersion);
      const baseMessage = overview || `Nexus AI Chat Importer has been upgraded to version ${currentVersion}.`;
      const paragraphs = [];
      paragraphs.push(baseMessage);
      paragraphs.push(this.getDocLinks(currentVersion));
      if (upgradeChain.length > 0) {
        paragraphs.push("");
        paragraphs.push("**Upgrade Operations Required**");
        paragraphs.push("The following operations will be performed automatically:");
        paragraphs.push("");
        const operationsList = [];
        for (const upgrade of upgradeChain) {
          for (const operation of upgrade.automaticOperations) {
            operationsList.push(`\u2022 **${operation.name}**: ${operation.description}`);
          }
        }
        paragraphs.push(operationsList.join("\n"));
      } else {
        paragraphs.push("");
        paragraphs.push("All systems are up to date. No operations required.");
      }
      if (upgradeChain.length > 0) {
        const isV120Upgrade = upgradeChain.some((upgrade) => upgrade.version === "1.2.0");
        const isV130Upgrade = upgradeChain.some((upgrade) => upgrade.version === "1.3.0");
        if (isV130Upgrade) {
          const { NexusUpgradeModal130: NexusUpgradeModal1302 } = await Promise.resolve().then(() => (init_upgrade_modal_1_3_0(), upgrade_modal_1_3_0_exports));
          const userChoice = await new Promise((resolve) => {
            new NexusUpgradeModal1302(this.plugin.app, this.plugin, "1.3.0", resolve).open();
          });
          if (userChoice !== "ok") {
            throw new Error("User cancelled upgrade");
          }
        } else if (isV120Upgrade) {
          const { NexusUpgradeModal: NexusUpgradeModal2 } = (init_upgrade_1_2_0(), __toCommonJS(upgrade_1_2_0_exports));
          await new Promise((resolve) => {
            new NexusUpgradeModal2(this.plugin.app, this.plugin, "1.2.0", resolve).open();
          });
        } else {
          await showDialog(
            this.plugin.app,
            "information",
            `Upgrade to ${VersionUtils.formatVersion(currentVersion)}`,
            paragraphs,
            this.shouldShowUpgradeWarning(lastVersion) ? this.getUpgradeWarning() : void 0,
            { button1: "Proceed with Upgrade" }
          );
        }
      } else {
        await showDialog(
          this.plugin.app,
          "information",
          `Upgrade to ${VersionUtils.formatVersion(currentVersion)}`,
          paragraphs,
          this.shouldShowUpgradeWarning(lastVersion) ? this.getUpgradeWarning() : void 0,
          { button1: "Got it!" }
          // ← Juste informatif
        );
      }
    } catch (error) {
      logger4.error("Error showing upgrade dialog:", error);
      new import_obsidian25.Notice(`Upgraded to Nexus AI Chat Importer v${currentVersion}`);
    }
  }
  /**
   * Wait until a CSS rule (selectorText contains 'selector') is present in document.styleSheets
   * Returns false on timeout, true if found
   */
  async waitForCssRule(selector, timeoutMs = 2e3) {
    const start = Date.now();
    const hasRule = /* @__PURE__ */ __name(() => {
      for (const sheet of Array.from(document.styleSheets)) {
        let rules;
        try {
          rules = sheet.cssRules;
        } catch (e) {
          continue;
        }
        if (!rules)
          continue;
        for (let i = 0; i < rules.length; i++) {
          const rule = rules[i];
          if (rule.selectorText && rule.selectorText.includes(selector)) {
            return true;
          }
        }
      }
      return false;
    }, "hasRule");
    if (hasRule())
      return true;
    return await new Promise((resolve) => {
      const interval = window.setInterval(() => {
        if (hasRule()) {
          window.clearInterval(interval);
          resolve(true);
        } else if (Date.now() - start > timeoutMs) {
          window.clearInterval(interval);
          resolve(false);
        }
      }, 50);
    });
  }
  /**
   * Check if operation was completed using new upgrade history structure
   */
  async isOperationCompleted(operationId, version) {
    var _a, _b, _c;
    const data = await this.plugin.loadData();
    const operationKey = `operation_${version.replace(/\./g, "_")}_${operationId}`;
    return ((_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedOperations) == null ? void 0 : _b[operationKey]) == null ? void 0 : _c.completed) || false;
  }
  /**
   * Mark operation as completed using structured upgrade history
   */
  async markOperationCompleted(operationId, version) {
    const data = await this.plugin.loadData() || {};
    if (!data.upgradeHistory) {
      data.upgradeHistory = {
        completedUpgrades: {},
        completedOperations: {}
      };
    }
    const operationKey = `operation_${version.replace(/\./g, "_")}_${operationId}`;
    data.upgradeHistory.completedOperations[operationKey] = {
      operationId,
      version,
      date: new Date().toISOString(),
      completed: true
    };
    await this.plugin.saveData(data);
  }
  /**
   * Get documentation links
   */
  getDocLinks(version) {
    return `**Resources:**
\u2022 [Full Release Notes](${GITHUB.REPO_BASE}/blob/${version}/RELEASE_NOTES.md)
\u2022 [Documentation](${GITHUB.REPO_BASE}/blob/${version}/README.md)`;
  }
  /**
   * Check if should show upgrade warning for very old versions
   */
  shouldShowUpgradeWarning(lastVersion) {
    return VersionUtils.compareVersions(lastVersion, "1.0.2") < 0;
  }
  /**
   * Get upgrade warning for very old versions
   */
  getUpgradeWarning() {
    return `\u26A0\uFE0F **Important for users upgrading from versions prior to v1.0.2:**

Version 1.0.2 introduced new metadata parameters required for certain features. For optimal performance and feature compatibility, it's recommended to delete old data and re-import conversations with this new version.`;
  }
  /**
   * Fetch release overview from GitHub
   */
  async fetchReleaseOverview(version) {
    try {
      const { requestUrl: requestUrl2 } = require("obsidian");
      const response = await requestUrl2({
        url: `${GITHUB.RAW_BASE}/${version}/RELEASE_NOTES.md`,
        method: "GET"
      });
      const overviewRegex = /## Overview\s+(.*?)(?=##|$)/s;
      const match = response.text.match(overviewRegex);
      return match ? match[1].trim() : null;
    } catch (error) {
      logger4.warn("Could not fetch release overview:", error);
      return null;
    }
  }
  /**
   * Compare two version strings
   * Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2
   */
  compareVersions(v1, v2) {
    const parts1 = v1.split(".").map(Number);
    const parts2 = v2.split(".").map(Number);
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const num1 = parts1[i] || 0;
      const num2 = parts2[i] || 0;
      if (num1 < num2)
        return -1;
      if (num1 > num2)
        return 1;
    }
    return 0;
  }
  /**
   * Get manual operations status for settings UI
   */
  async getManualOperationsForSettings() {
    const results = [];
    for (const upgrade of this.availableUpgrades) {
      const context = await this.createUpgradeContext(upgrade, "0.0.0", this.plugin.manifest.version);
      const operationsStatus = await upgrade.getManualOperationsStatus(context);
      if (operationsStatus.length > 0) {
        results.push({
          version: upgrade.version,
          operations: operationsStatus.map((status) => ({
            id: status.operation.id,
            name: status.operation.name,
            description: status.operation.description,
            completed: status.completed,
            canRun: status.canRun
          }))
        });
      }
    }
    return results;
  }
  /**
   * Execute single manual operation from settings
   */
  async executeManualOperation(version, operationId) {
    const upgrade = this.availableUpgrades.find((u) => u.version === version);
    if (!upgrade) {
      return { success: false, message: "Upgrade version not found" };
    }
    const context = await this.createUpgradeContext(upgrade, "0.0.0", this.plugin.manifest.version);
    const result = await upgrade.executeManualOperation(operationId, context);
    return {
      success: result.success,
      message: result.message
    };
  }
};
__name(IncrementalUpgradeManager, "IncrementalUpgradeManager");

// src/main.ts
init_logger();

// src/dialogs/provider-selection-dialog.ts
var import_obsidian26 = require("obsidian");
init_i18n();
var ProviderSelectionDialog = class extends import_obsidian26.Modal {
  constructor(app, providerRegistry, onProviderSelected) {
    super(app);
    this.selectedProvider = null;
    this.onProviderSelected = onProviderSelected;
    this.providers = this.getAvailableProviders(providerRegistry);
  }
  getAvailableProviders(registry) {
    const providers = [];
    if (registry.getAdapter("chatgpt")) {
      providers.push({
        id: "chatgpt",
        name: t("provider_selection.providers.chatgpt.name"),
        description: t("provider_selection.providers.chatgpt.description"),
        fileFormats: [t("provider_selection.providers.chatgpt.file_formats_0")]
      });
    }
    if (registry.getAdapter("claude")) {
      providers.push({
        id: "claude",
        name: t("provider_selection.providers.claude.name"),
        description: t("provider_selection.providers.claude.description"),
        fileFormats: [
          t("provider_selection.providers.claude.file_formats_0"),
          t("provider_selection.providers.claude.file_formats_1")
        ]
      });
    }
    if (registry.getAdapter("lechat")) {
      providers.push({
        id: "lechat",
        name: t("provider_selection.providers.lechat.name"),
        description: t("provider_selection.providers.lechat.description"),
        fileFormats: [t("provider_selection.providers.lechat.file_formats_0")]
      });
    }
    return providers;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("provider_selection.title") });
    this.providers.forEach((provider) => {
      new import_obsidian26.Setting(contentEl).setName(provider.name).setDesc(this.createProviderDescription(provider)).addButton((button) => {
        button.setButtonText(t("provider_selection.buttons.select")).setCta().onClick(() => {
          this.selectedProvider = provider.id;
          this.close();
          this.onProviderSelected(provider.id);
        });
      });
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.textAlign = "center";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: t("provider_selection.buttons.cancel") });
    cancelButton.style.marginRight = "10px";
    cancelButton.onclick = () => this.close();
  }
  createProviderDescription(provider) {
    return provider.description;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(ProviderSelectionDialog, "ProviderSelectionDialog");

// src/dialogs/enhanced-file-selection-dialog.ts
var import_obsidian27 = require("obsidian");
init_i18n();
var EnhancedFileSelectionDialog = class extends import_obsidian27.Modal {
  constructor(app, provider, onFileSelectionComplete, plugin) {
    super(app);
    this.plugin = plugin;
    this.selectedFiles = [];
    this.importMode = "all";
    this.dragCounter = 0;
    this.lastImportMode = null;
    this.provider = provider;
    this.onFileSelectionComplete = onFileSelectionComplete;
    this.setInitialImportMode();
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    modalEl.addClass("nexus-file-selection-dialog");
    contentEl.addClass("nexus-file-selection-dialog");
    titleEl.setText(t("file_selection.title", { provider: this.provider.charAt(0).toUpperCase() + this.provider.slice(1) }));
    this.createImportModeSection(contentEl);
    this.createFileSelectionArea(contentEl);
    this.createFilePreviewArea(contentEl);
    this.createActionButtons(contentEl);
    this.addCustomStyles();
  }
  createImportModeSection(container) {
    const section = container.createDiv("import-mode-section");
    section.style.marginBottom = "20px";
    const sectionTitle = section.createEl("h3", { text: t("file_selection.import_mode.section_title") });
    sectionTitle.style.marginTop = "0";
    sectionTitle.style.marginBottom = "12px";
    sectionTitle.style.fontSize = "1em";
    const optionsContainer = section.createDiv("import-options-container");
    optionsContainer.style.display = "grid";
    optionsContainer.style.gridTemplateColumns = "1fr 1fr";
    optionsContainer.style.gap = "12px";
    const allOption = optionsContainer.createDiv("import-option-box");
    allOption.style.padding = "14px 16px";
    allOption.style.border = "1px solid var(--background-modifier-border)";
    allOption.style.borderRadius = "6px";
    allOption.style.cursor = "pointer";
    allOption.style.transition = "all 0.2s";
    allOption.style.display = "flex";
    allOption.style.alignItems = "center";
    allOption.style.gap = "10px";
    allOption.style.backgroundColor = "var(--background-primary)";
    if (this.importMode === "all") {
      allOption.style.borderColor = "var(--interactive-accent)";
      allOption.style.borderWidth = "2px";
    }
    const allRadio = allOption.createEl("input", { type: "radio" });
    allRadio.name = "importMode";
    allRadio.value = "all";
    allRadio.checked = this.importMode === "all";
    allRadio.id = "import-all";
    allRadio.addEventListener("change", () => {
      this.importMode = "all";
      this.updateImportModeDescription();
      this.updateImportModeBoxes();
    });
    const allContent = allOption.createDiv();
    allContent.style.flex = "1";
    const allLabel = allContent.createEl("label");
    allLabel.htmlFor = "import-all";
    allLabel.style.display = "block";
    allLabel.style.fontWeight = "500";
    allLabel.style.marginBottom = "4px";
    allLabel.style.cursor = "pointer";
    allLabel.style.color = "var(--text-normal)";
    allLabel.textContent = t("file_selection.import_mode.all_label");
    const allDesc = allContent.createDiv();
    allDesc.style.fontSize = "0.85em";
    allDesc.style.color = "var(--text-muted)";
    allDesc.textContent = t("file_selection.import_mode.all_description");
    allOption.addEventListener("click", () => {
      allRadio.checked = true;
      this.importMode = "all";
      this.updateImportModeDescription();
      this.updateImportModeBoxes();
    });
    const selectOption = optionsContainer.createDiv("import-option-box");
    selectOption.style.padding = "14px 16px";
    selectOption.style.border = "1px solid var(--background-modifier-border)";
    selectOption.style.borderRadius = "6px";
    selectOption.style.cursor = "pointer";
    selectOption.style.transition = "all 0.2s";
    selectOption.style.display = "flex";
    selectOption.style.alignItems = "center";
    selectOption.style.gap = "10px";
    selectOption.style.backgroundColor = "var(--background-primary)";
    if (this.importMode === "selective") {
      selectOption.style.borderColor = "var(--interactive-accent)";
      selectOption.style.borderWidth = "2px";
    }
    const selectRadio = selectOption.createEl("input", { type: "radio" });
    selectRadio.name = "importMode";
    selectRadio.value = "selective";
    selectRadio.checked = this.importMode === "selective";
    selectRadio.id = "import-selective";
    selectRadio.addEventListener("change", () => {
      this.importMode = "selective";
      this.updateImportModeDescription();
      this.updateImportModeBoxes();
    });
    const selectContent = selectOption.createDiv();
    selectContent.style.flex = "1";
    const selectLabel = selectContent.createEl("label");
    selectLabel.htmlFor = "import-selective";
    selectLabel.style.display = "block";
    selectLabel.style.fontWeight = "500";
    selectLabel.style.marginBottom = "4px";
    selectLabel.style.cursor = "pointer";
    selectLabel.style.color = "var(--text-normal)";
    selectLabel.textContent = t("file_selection.import_mode.selective_label");
    const selectDesc = selectContent.createDiv();
    selectDesc.style.fontSize = "0.85em";
    selectDesc.style.color = "var(--text-muted)";
    selectDesc.textContent = t("file_selection.import_mode.selective_description");
    selectOption.addEventListener("click", () => {
      selectRadio.checked = true;
      this.importMode = "selective";
      this.updateImportModeDescription();
      this.updateImportModeBoxes();
    });
  }
  updateImportModeBoxes() {
    const boxes = this.contentEl.querySelectorAll(".import-option-box");
    boxes.forEach((box, index) => {
      const isSelected = index === 0 && this.importMode === "all" || index === 1 && this.importMode === "selective";
      if (isSelected) {
        box.style.borderColor = "var(--interactive-accent)";
        box.style.borderWidth = "2px";
      } else {
        box.style.borderColor = "var(--background-modifier-border)";
        box.style.borderWidth = "1px";
      }
    });
  }
  createFileSelectionArea(container) {
    const section = container.createDiv("file-selection-section");
    section.style.marginBottom = "20px";
    const sectionTitle = section.createEl("h3", { text: t("file_selection.file_area.section_title") });
    sectionTitle.style.marginBottom = "10px";
    sectionTitle.style.fontSize = "1em";
    const dropZone = section.createDiv("drop-zone");
    dropZone.style.border = "2px dashed var(--background-modifier-border)";
    dropZone.style.borderRadius = "8px";
    dropZone.style.padding = "24px 20px";
    dropZone.style.textAlign = "center";
    dropZone.style.cursor = "pointer";
    dropZone.style.transition = "all 0.2s ease";
    const dropIcon = dropZone.createEl("div");
    dropIcon.style.fontSize = "48px";
    dropIcon.style.marginBottom = "15px";
    dropIcon.textContent = "\u{1F4C1}";
    const dropText = dropZone.createEl("div");
    dropText.style.fontSize = "16px";
    dropText.style.marginBottom = "10px";
    if (this.provider === "gemini") {
      dropText.textContent = t("file_selection.file_area.drop_text_gemini");
    } else {
      dropText.textContent = t("file_selection.file_area.drop_text_default");
    }
    const dropSubtext = dropZone.createEl("div");
    dropSubtext.style.fontSize = "14px";
    dropSubtext.style.color = "var(--text-muted)";
    if (this.provider === "gemini") {
      dropSubtext.textContent = t("file_selection.file_area.drop_subtext_gemini");
    } else {
      dropSubtext.textContent = t("file_selection.file_area.drop_subtext_default");
    }
    const fileInput = section.createEl("input", { type: "file" });
    if (this.provider === "gemini") {
      fileInput.accept = ".zip,.json";
    } else {
      fileInput.accept = ".zip";
    }
    fileInput.multiple = true;
    fileInput.style.display = "none";
    dropZone.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => this.handleFileSelection(e));
    dropZone.addEventListener("dragover", (e) => this.handleDragOver(e, dropZone));
    dropZone.addEventListener("dragenter", (e) => this.handleDragEnter(e, dropZone));
    dropZone.addEventListener("dragleave", (e) => this.handleDragLeave(e, dropZone));
    dropZone.addEventListener("drop", (e) => this.handleDrop(e, dropZone));
  }
  createFilePreviewArea(container) {
    const section = container.createDiv("file-preview-section");
    section.id = "file-preview-section";
    section.style.marginBottom = "20px";
    section.style.display = "none";
    const sectionTitle = section.createEl("h3", { text: t("file_selection.selected_files.section_title") });
    sectionTitle.style.marginBottom = "15px";
    const fileListContainer = section.createDiv("file-list-container");
    fileListContainer.style.maxHeight = "300px";
    fileListContainer.style.overflowY = "auto";
    fileListContainer.style.border = "1px solid var(--background-modifier-border)";
    fileListContainer.style.borderRadius = "6px";
    fileListContainer.style.padding = "8px";
    const fileList = fileListContainer.createDiv("file-list");
    fileList.id = "file-list";
  }
  createActionButtons(container) {
    const buttonContainer = container.createDiv("action-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: t("file_selection.buttons.cancel") });
    cancelButton.style.padding = "8px 16px";
    cancelButton.addEventListener("click", () => this.close());
    const importButton = buttonContainer.createEl("button", { text: t("file_selection.buttons.continue") });
    importButton.id = "import-button";
    importButton.style.padding = "8px 16px";
    importButton.classList.add("mod-cta");
    importButton.disabled = true;
    importButton.addEventListener("click", () => this.handleImport());
  }
  handleFileSelection(event) {
    const input = event.target;
    if (input.files) {
      const incoming = Array.from(input.files);
      const existingNames = new Set(this.selectedFiles.map((f) => f.name));
      const duplicates = incoming.filter((f) => existingNames.has(f.name));
      const unique = incoming.filter((f) => !existingNames.has(f.name));
      this.selectedFiles = [...this.selectedFiles, ...unique];
      if (duplicates.length > 0) {
        new import_obsidian27.Notice(`${duplicates.length} duplicate file(s) ignored: ${duplicates.map((f) => f.name).join(", ")}`);
      }
      this.updateFilePreview();
      this.updateImportButton();
    }
  }
  handleDragOver(event, dropZone) {
    event.preventDefault();
    dropZone.style.borderColor = "var(--interactive-accent)";
    dropZone.style.backgroundColor = "var(--background-modifier-hover)";
  }
  handleDragEnter(event, dropZone) {
    event.preventDefault();
    this.dragCounter++;
  }
  handleDragLeave(event, dropZone) {
    event.preventDefault();
    this.dragCounter--;
    if (this.dragCounter === 0) {
      dropZone.style.borderColor = "var(--background-modifier-border)";
      dropZone.style.backgroundColor = "transparent";
    }
  }
  handleDrop(event, dropZone) {
    var _a;
    event.preventDefault();
    this.dragCounter = 0;
    dropZone.style.borderColor = "var(--background-modifier-border)";
    dropZone.style.backgroundColor = "transparent";
    if ((_a = event.dataTransfer) == null ? void 0 : _a.files) {
      const files = Array.from(event.dataTransfer.files).filter((file) => {
        const fileName = file.name.toLowerCase();
        if (this.provider === "gemini") {
          return fileName.endsWith(".zip") || fileName.endsWith(".json");
        }
        return fileName.endsWith(".zip");
      });
      if (files.length > 0) {
        const existingNames = new Set(this.selectedFiles.map((f) => f.name));
        const duplicates = files.filter((f) => existingNames.has(f.name));
        const unique = files.filter((f) => !existingNames.has(f.name));
        this.selectedFiles = [...this.selectedFiles, ...unique];
        if (duplicates.length > 0) {
          new import_obsidian27.Notice(`${duplicates.length} duplicate file(s) ignored: ${duplicates.map((f) => f.name).join(", ")}`);
        }
        this.updateFilePreview();
        this.updateImportButton();
      }
    }
  }
  updateFilePreview() {
    const previewSection = this.contentEl.querySelector("#file-preview-section");
    const fileList = this.contentEl.querySelector("#file-list");
    if (this.selectedFiles.length > 0) {
      previewSection.style.display = "block";
      fileList.empty();
      this.selectedFiles.forEach((file, index) => {
        const fileItem = fileList.createDiv("file-item");
        fileItem.style.display = "flex";
        fileItem.style.justifyContent = "space-between";
        fileItem.style.alignItems = "center";
        fileItem.style.padding = "8px 12px";
        fileItem.style.border = "1px solid var(--background-modifier-border)";
        fileItem.style.borderRadius = "4px";
        fileItem.style.marginBottom = "8px";
        const fileInfo = fileItem.createDiv();
        fileInfo.style.display = "flex";
        fileInfo.style.flexDirection = "column";
        const fileName = fileInfo.createEl("span");
        fileName.textContent = file.name;
        fileName.style.fontWeight = "500";
        const fileSize = fileInfo.createEl("span");
        fileSize.textContent = formatFileSize(file.size);
        fileSize.style.fontSize = "0.9em";
        fileSize.style.color = "var(--text-muted)";
        const removeButton = fileItem.createEl("button", { text: t("file_selection.selected_files.remove_button") });
        removeButton.style.padding = "4px 8px";
        removeButton.style.fontSize = "0.9em";
        removeButton.addEventListener("click", () => this.removeFile(index));
      });
    } else {
      previewSection.style.display = "none";
    }
  }
  removeFile(index) {
    this.selectedFiles.splice(index, 1);
    this.updateFilePreview();
    this.updateImportButton();
  }
  updateImportButton() {
    const importButton = this.contentEl.querySelector("#import-button");
    importButton.disabled = this.selectedFiles.length === 0;
  }
  updateImportModeDescription() {
  }
  async handleImport() {
    var _a, _b;
    if (this.selectedFiles.length > 0) {
      if ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.rememberLastImportMode) {
        this.plugin.settings.defaultImportMode = this.importMode;
        await this.plugin.saveSettings();
      }
      const result = {
        files: this.selectedFiles,
        mode: this.importMode,
        provider: this.provider
      };
      this.close();
      this.onFileSelectionComplete(result);
    }
  }
  setInitialImportMode() {
    var _a;
    if (!((_a = this.plugin) == null ? void 0 : _a.settings)) {
      this.importMode = "all";
      return;
    }
    if (this.plugin.settings.rememberLastImportMode && this.lastImportMode) {
      this.importMode = this.lastImportMode;
    } else {
      this.importMode = this.plugin.settings.defaultImportMode || "all";
    }
  }
  addCustomStyles() {
    const style = document.createElement("style");
    style.textContent = `
            /* Modal sizing - wider and responsive */
            .modal.nexus-file-selection-dialog {
                max-width: min(800px, 90vw) !important;
                width: min(800px, 90vw) !important;
                height: auto !important;
                padding: 0 !important;
            }

            /* Modal title spacing */
            .modal.nexus-file-selection-dialog .modal-title {
                padding: 16px 24px !important;
                margin: 0 !important;
            }

            .modal.nexus-file-selection-dialog .modal-content {
                max-width: 100% !important;
                width: 100% !important;
                max-height: 85vh;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                padding: 20px 24px 24px 24px;
            }

            /* Import mode boxes hover effect */
            .nexus-file-selection-dialog .import-option-box:hover {
                background-color: var(--background-modifier-hover);
            }

            /* Drop zone hover effect */
            .nexus-file-selection-dialog .drop-zone:hover {
                border-color: var(--interactive-accent);
                background-color: var(--background-modifier-hover);
            }

            /* File list container with custom scrollbar */
            .nexus-file-selection-dialog .file-list-container {
                scrollbar-width: thin;
                scrollbar-color: var(--background-modifier-border) transparent;
            }

            .nexus-file-selection-dialog .file-list-container::-webkit-scrollbar {
                width: 10px;
            }

            .nexus-file-selection-dialog .file-list-container::-webkit-scrollbar-track {
                background: transparent;
            }

            .nexus-file-selection-dialog .file-list-container::-webkit-scrollbar-thumb {
                background-color: var(--background-modifier-border);
                border-radius: 5px;
            }

            .nexus-file-selection-dialog .file-list-container::-webkit-scrollbar-thumb:hover {
                background-color: var(--text-muted);
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(EnhancedFileSelectionDialog, "EnhancedFileSelectionDialog");

// src/dialogs/conversation-selection-dialog.ts
var import_obsidian28 = require("obsidian");
init_i18n();
var ConversationSelectionDialog = class extends import_obsidian28.Modal {
  // Information about analysis and filtering
  constructor(app, conversations, onSelectionComplete, plugin, analysisInfo) {
    var _a, _b;
    super(app);
    this.onSelectionComplete = onSelectionComplete;
    this.plugin = plugin;
    this.analysisInfo = analysisInfo;
    const pageSize = ((_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.lastConversationsPerPage) || 50;
    this.state = {
      allConversations: conversations,
      filteredConversations: conversations,
      selectedIds: /* @__PURE__ */ new Set(),
      pagination: {
        pageSize,
        currentPage: 1,
        totalPages: Math.ceil(conversations.length / pageSize),
        totalItems: conversations.length
      },
      sort: {
        field: "updateTime",
        direction: "desc"
      },
      filter: {
        existenceStatus: "all"
        // Default to show all conversations
      },
      isLoading: false
    };
    if ((_b = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _b.autoSelectAllOnOpen) {
      conversations.forEach((conv) => {
        this.state.selectedIds.add(conv.id);
      });
    }
    this.applyFiltersAndSort();
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    modalEl.addClass("nexus-conversation-selection-dialog");
    contentEl.addClass("nexus-conversation-selection-dialog");
    titleEl.setText(t("conversation_selection.title"));
    this.createSummarySection(contentEl);
    this.createControlsSection(contentEl);
    this.createConversationListSection(contentEl);
    this.createPaginationSection(contentEl);
    this.createActionButtons(contentEl);
    this.addCustomStyles();
    this.renderConversationList();
    this.updateSummary();
    this.updatePagination();
  }
  createSummarySection(container) {
    const section = container.createDiv("summary-section");
    section.id = "conversation-summary";
    section.style.marginBottom = "20px";
    section.style.display = "grid";
    section.style.gridTemplateColumns = "repeat(4, 1fr)";
    section.style.gap = "12px";
  }
  createControlsSection(container) {
    const section = container.createDiv("controls-section");
    section.style.marginBottom = "20px";
    section.style.display = "flex";
    section.style.gap = "12px";
    section.style.alignItems = "center";
    const selectAllBtn = section.createEl("button", { text: t("conversation_selection.controls.select_all") });
    selectAllBtn.style.padding = "8px 16px";
    selectAllBtn.style.whiteSpace = "nowrap";
    selectAllBtn.addEventListener("click", () => {
      this.state.filteredConversations.forEach((conv) => {
        this.state.selectedIds.add(conv.id);
      });
      this.renderConversationList();
      this.updateSummary();
    });
    const selectNoneBtn = section.createEl("button", { text: t("conversation_selection.controls.select_none") });
    selectNoneBtn.style.padding = "8px 16px";
    selectNoneBtn.style.whiteSpace = "nowrap";
    selectNoneBtn.addEventListener("click", () => {
      this.state.selectedIds.clear();
      this.renderConversationList();
      this.updateSummary();
    });
    const searchInput = section.createEl("input", { type: "text" });
    searchInput.placeholder = t("conversation_selection.controls.search_placeholder");
    searchInput.style.flex = "1";
    searchInput.style.minWidth = "200px";
    searchInput.style.padding = "8px 12px";
    searchInput.style.border = "1px solid var(--background-modifier-border)";
    searchInput.style.borderRadius = "4px";
    searchInput.addEventListener("input", (e) => {
      const target = e.target;
      this.state.filter.searchTerm = target.value;
      this.applyFiltersAndSort();
      this.renderConversationList();
      this.updateSummary();
      this.updatePagination();
    });
    const statusLabel = section.createEl("label");
    statusLabel.textContent = t("conversation_selection.controls.status_label");
    statusLabel.style.marginRight = "4px";
    statusLabel.style.fontSize = "14px";
    statusLabel.style.whiteSpace = "nowrap";
    const statusSelect = section.createEl("select");
    statusSelect.style.padding = "8px 12px";
    statusSelect.style.paddingRight = "28px";
    statusSelect.style.border = "1px solid var(--background-modifier-border)";
    statusSelect.style.borderRadius = "4px";
    statusSelect.style.fontSize = "14px";
    statusSelect.style.backgroundColor = "var(--background-primary)";
    statusSelect.style.color = "var(--text-normal)";
    statusSelect.classList.add("nexus-custom-select");
    const statusOptions = [
      { value: "all", text: t("conversation_selection.status_filter_options.all") },
      { value: "new", text: t("conversation_selection.status_filter_options.new") },
      { value: "updated", text: t("conversation_selection.status_filter_options.updated") },
      { value: "unchanged", text: t("conversation_selection.status_filter_options.unchanged") }
    ];
    statusOptions.forEach((option) => {
      const optionEl = statusSelect.createEl("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
    });
    statusSelect.value = this.state.filter.existenceStatus || "all";
    statusSelect.addEventListener("change", (e) => {
      const target = e.target;
      this.state.filter.existenceStatus = target.value;
      this.applyFiltersAndSort();
      this.renderConversationList();
      this.updateSummary();
      this.updatePagination();
    });
    const pageSizeLabel = section.createEl("label");
    pageSizeLabel.textContent = t("conversation_selection.controls.show_label");
    pageSizeLabel.style.marginRight = "4px";
    pageSizeLabel.style.fontSize = "14px";
    pageSizeLabel.style.whiteSpace = "nowrap";
    const pageSizeSelect = section.createEl("select");
    pageSizeSelect.style.padding = "8px 12px";
    pageSizeSelect.style.paddingRight = "28px";
    pageSizeSelect.style.border = "1px solid var(--background-modifier-border)";
    pageSizeSelect.style.borderRadius = "4px";
    pageSizeSelect.style.fontSize = "14px";
    pageSizeSelect.style.backgroundColor = "var(--background-primary)";
    pageSizeSelect.style.color = "var(--text-normal)";
    pageSizeSelect.classList.add("nexus-custom-select");
    const pageSizeOptions = [10, 20, 50, 100];
    pageSizeOptions.forEach((size) => {
      const optionEl = pageSizeSelect.createEl("option");
      optionEl.value = size.toString();
      optionEl.textContent = size.toString();
    });
    pageSizeSelect.value = this.state.pagination.pageSize.toString();
    pageSizeSelect.addEventListener("change", async (e) => {
      const target = e.target;
      const newPageSize = parseInt(target.value);
      this.state.pagination.pageSize = newPageSize;
      this.state.pagination.currentPage = 1;
      if (this.plugin) {
        this.plugin.settings.lastConversationsPerPage = newPageSize;
        await this.plugin.saveSettings();
      }
      this.updatePagination();
      this.renderConversationList();
    });
  }
  createConversationListSection(container) {
    const section = container.createDiv("conversation-list-section");
    section.style.marginBottom = "20px";
    const tableContainer = section.createDiv("table-container");
    tableContainer.classList.add("nexus-table-container");
    const table = tableContainer.createEl("table");
    table.id = "conversation-table";
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.style.backgroundColor = "var(--background-secondary)";
    headerRow.style.position = "sticky";
    headerRow.style.top = "0";
    headerRow.style.zIndex = "10";
    const headers = [
      { text: "", width: "40px", sortField: null },
      // Checkbox - plus compact
      { text: t("conversation_selection.table_headers.title"), width: "45%", sortField: "title" },
      // Plus d'espace
      { text: t("conversation_selection.table_headers.created"), width: "110px", sortField: "createTime" },
      // Réduit
      { text: t("conversation_selection.table_headers.updated"), width: "110px", sortField: "updateTime" },
      // Réduit
      { text: t("conversation_selection.table_headers.messages"), width: "80px", sortField: "messageCount" },
      // Réduit
      { text: t("conversation_selection.table_headers.status"), width: "100px", sortField: null }
      // Réduit
    ];
    headers.forEach((header) => {
      const th = headerRow.createEl("th");
      th.style.padding = "12px 8px";
      th.style.textAlign = "left";
      th.style.borderBottom = "2px solid var(--background-modifier-border)";
      th.style.fontWeight = "600";
      th.style.backgroundColor = "var(--background-secondary)";
      th.style.userSelect = "none";
      if (header.width !== "auto") {
        th.style.width = header.width;
      }
      if (header.sortField) {
        th.style.cursor = "pointer";
        th.classList.add("sortable-header");
        const headerContent = th.createSpan();
        headerContent.textContent = header.text;
        const sortIndicator = th.createSpan();
        sortIndicator.classList.add("sort-indicator");
        sortIndicator.style.marginLeft = "6px";
        sortIndicator.style.fontSize = "0.8em";
        sortIndicator.style.opacity = "0.5";
        if (this.state.sort.field === header.sortField) {
          sortIndicator.textContent = this.state.sort.direction === "asc" ? "\u25B2" : "\u25BC";
          sortIndicator.style.opacity = "1";
        } else {
          sortIndicator.textContent = "\u25BC";
        }
        th.addEventListener("click", () => {
          if (this.state.sort.field === header.sortField) {
            this.state.sort.direction = this.state.sort.direction === "asc" ? "desc" : "asc";
          } else {
            this.state.sort.field = header.sortField;
            this.state.sort.direction = "desc";
          }
          this.applyFiltersAndSort();
          this.renderConversationList();
        });
      } else {
        th.textContent = header.text;
      }
    });
    const tbody = table.createEl("tbody");
    tbody.id = "conversation-table-body";
  }
  createPaginationSection(container) {
    const section = container.createDiv("pagination-section");
    section.id = "pagination-section";
    section.style.marginBottom = "20px";
    section.style.display = "flex";
    section.style.justifyContent = "space-between";
    section.style.alignItems = "center";
    const pageInfo = section.createDiv();
    pageInfo.id = "page-info";
    pageInfo.style.fontSize = "0.9em";
    pageInfo.style.color = "var(--text-muted)";
    const pageControls = section.createDiv();
    pageControls.id = "page-controls";
    pageControls.style.display = "flex";
    pageControls.style.gap = "8px";
  }
  createActionButtons(container) {
    const buttonContainer = container.createDiv("action-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: t("conversation_selection.buttons.cancel") });
    cancelButton.style.padding = "8px 16px";
    cancelButton.addEventListener("click", () => this.close());
    const importButton = buttonContainer.createEl("button", { text: t("conversation_selection.buttons.import_selected") });
    importButton.id = "import-selected-button";
    importButton.style.padding = "8px 16px";
    importButton.classList.add("mod-cta");
    importButton.addEventListener("click", () => this.handleImportSelected());
  }
  applyFiltersAndSort() {
    let filtered = [...this.state.allConversations];
    if (this.state.filter.searchTerm) {
      const searchTerm = this.state.filter.searchTerm.toLowerCase();
      filtered = filtered.filter(
        (conv) => conv.title.toLowerCase().includes(searchTerm)
      );
    }
    if (this.state.filter.existenceStatus && this.state.filter.existenceStatus !== "all") {
      filtered = filtered.filter(
        (conv) => conv.existenceStatus === this.state.filter.existenceStatus
      );
    }
    filtered.sort((a, b) => {
      const { field, direction } = this.state.sort;
      let aVal = a[field];
      let bVal = b[field];
      if (field === "title") {
        aVal = aVal.toLowerCase();
        bVal = bVal.toLowerCase();
      }
      if (aVal < bVal)
        return direction === "asc" ? -1 : 1;
      if (aVal > bVal)
        return direction === "asc" ? 1 : -1;
      return 0;
    });
    this.state.filteredConversations = filtered;
    this.updatePagination();
  }
  updatePagination() {
    const totalItems = this.state.filteredConversations.length;
    const totalPages = Math.ceil(totalItems / this.state.pagination.pageSize);
    this.state.pagination = {
      ...this.state.pagination,
      totalItems,
      totalPages,
      currentPage: Math.min(this.state.pagination.currentPage, totalPages || 1)
    };
  }
  renderConversationList() {
    const tbody = this.contentEl.querySelector("#conversation-table-body");
    if (!tbody)
      return;
    tbody.empty();
    const { currentPage, pageSize } = this.state.pagination;
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const pageConversations = this.state.filteredConversations.slice(startIndex, endIndex);
    pageConversations.forEach((conversation) => {
      const row = tbody.createEl("tr");
      const checkboxCell = row.createEl("td");
      const checkbox = checkboxCell.createEl("input", { type: "checkbox" });
      checkbox.checked = this.state.selectedIds.has(conversation.id);
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.state.selectedIds.add(conversation.id);
        } else {
          this.state.selectedIds.delete(conversation.id);
        }
        this.updateSummary();
      });
      const titleCell = row.createEl("td");
      titleCell.style.fontWeight = "500";
      titleCell.textContent = conversation.title;
      if (conversation.sourceFile) {
        const sourceInfo = titleCell.createEl("div");
        sourceInfo.style.fontSize = "0.8em";
        sourceInfo.style.color = "var(--text-muted)";
        sourceInfo.style.marginTop = "4px";
        sourceInfo.textContent = `\u{1F4C1} ${conversation.sourceFile}`;
      }
      const createdCell = row.createEl("td");
      createdCell.style.fontSize = "0.9em";
      createdCell.textContent = this.formatDate(conversation.createTime);
      const updatedCell = row.createEl("td");
      updatedCell.style.fontSize = "0.9em";
      updatedCell.textContent = this.formatDate(conversation.updateTime);
      const messagesCell = row.createEl("td");
      messagesCell.style.textAlign = "center";
      messagesCell.textContent = conversation.messageCount.toString();
      const statusCell = row.createEl("td");
      statusCell.style.textAlign = "center";
      const statusBadge = this.createStatusBadge(conversation);
      statusCell.appendChild(statusBadge);
    });
    this.renderPaginationControls();
  }
  createStatusBadge(conversation) {
    const badge = document.createElement("span");
    badge.classList.add("status-badge");
    switch (conversation.existenceStatus) {
      case "new":
        badge.textContent = t("conversation_selection.status_badges.new");
        badge.classList.add("status-new");
        badge.title = t("conversation_selection.status_badges.tooltip_new");
        break;
      case "updated":
        badge.textContent = t("conversation_selection.status_badges.updated");
        badge.classList.add("status-updated");
        badge.title = t("conversation_selection.status_badges.tooltip_updated", { existing_date: this.formatDate(conversation.existingUpdateTime || 0), new_date: this.formatDate(conversation.updateTime) });
        break;
      case "unchanged":
        badge.textContent = t("conversation_selection.status_badges.unchanged");
        badge.classList.add("status-unchanged");
        badge.title = t("conversation_selection.status_badges.tooltip_unchanged");
        break;
      default:
        badge.textContent = t("conversation_selection.status_badges.unknown");
        badge.classList.add("status-unchanged");
        break;
    }
    return badge;
  }
  renderPaginationControls() {
    const pageInfo = this.contentEl.querySelector("#page-info");
    const pageControls = this.contentEl.querySelector("#page-controls");
    if (!pageInfo || !pageControls)
      return;
    const { currentPage, totalPages, totalItems, pageSize } = this.state.pagination;
    const startItem = (currentPage - 1) * pageSize + 1;
    const endItem = Math.min(currentPage * pageSize, totalItems);
    pageInfo.textContent = t("conversation_selection.pagination.showing", { start: String(startItem), end: String(endItem), total: String(totalItems) });
    pageControls.empty();
    const prevBtn = pageControls.createEl("button", { text: t("conversation_selection.pagination.previous") });
    prevBtn.disabled = currentPage <= 1;
    prevBtn.style.padding = "6px 12px";
    prevBtn.addEventListener("click", () => {
      if (currentPage > 1) {
        this.state.pagination.currentPage--;
        this.renderConversationList();
      }
    });
    const pageSpan = pageControls.createEl("span");
    pageSpan.textContent = t("conversation_selection.pagination.page_of", { current: String(currentPage), total: String(totalPages) });
    pageSpan.style.padding = "6px 12px";
    const nextBtn = pageControls.createEl("button", { text: t("conversation_selection.pagination.next") });
    nextBtn.disabled = currentPage >= totalPages;
    nextBtn.style.padding = "6px 12px";
    nextBtn.addEventListener("click", () => {
      if (currentPage < totalPages) {
        this.state.pagination.currentPage++;
        this.renderConversationList();
      }
    });
  }
  updateSummary() {
    const summary = this.contentEl.querySelector("#conversation-summary");
    if (!summary)
      return;
    const selectedCount = this.state.selectedIds.size;
    const totalCount = this.state.filteredConversations.length;
    const statusCounts = {
      new: 0,
      updated: 0,
      unchanged: 0,
      unknown: 0
    };
    this.state.filteredConversations.forEach((conv) => {
      const status = conv.existenceStatus || "unknown";
      statusCounts[status]++;
    });
    summary.innerHTML = this.buildComprehensiveSummary(selectedCount, totalCount, statusCounts);
    const importButton = this.contentEl.querySelector("#import-selected-button");
    if (importButton) {
      importButton.disabled = selectedCount === 0;
      importButton.textContent = selectedCount > 0 ? t("conversation_selection.buttons.import_selected_count", { count: String(selectedCount) }) : t("conversation_selection.buttons.import_selected");
    }
  }
  buildComprehensiveSummary(selectedCount, totalCount, statusCounts) {
    if (this.analysisInfo) {
      const info = this.analysisInfo;
      const uniqueCount = info.uniqueConversationsKept;
      return `
                <div style="text-align: center; padding: 12px; background-color: var(--background-primary); border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                    <div style="font-weight: 600; font-size: 1.4em; color: var(--text-accent);">${uniqueCount}</div>
                    <div style="color: var(--text-muted); font-size: 0.85em; margin-top: 4px;">${t("conversation_selection.summary.unique_conversations")}</div>
                </div>
                <div style="text-align: center; padding: 12px; background-color: var(--background-primary); border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                    <div style="font-weight: 600; font-size: 1.4em; color: var(--color-green);">${info.conversationsNew}</div>
                    <div style="color: var(--text-muted); font-size: 0.85em; margin-top: 4px;">${t("conversation_selection.summary.new")}</div>
                </div>
                <div style="text-align: center; padding: 12px; background-color: var(--background-primary); border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                    <div style="font-weight: 600; font-size: 1.4em; color: var(--color-orange);">${info.conversationsUpdated}</div>
                    <div style="color: var(--text-muted); font-size: 0.85em; margin-top: 4px;">${t("conversation_selection.summary.updated")}</div>
                </div>
                <div style="text-align: center; padding: 12px; background-color: var(--background-primary); border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                    <div style="font-weight: 600; font-size: 1.4em; color: var(--text-muted);">${info.conversationsIgnored}</div>
                    <div style="color: var(--text-muted); font-size: 0.85em; margin-top: 4px;">${t("conversation_selection.summary.unchanged")}</div>
                </div>
            `;
    }
    return `
            <div style="text-align: center; padding: 12px;">
                ${t("conversation_selection.summary.selected_of", { selected: String(selectedCount), total: String(totalCount) })}
            </div>
        `;
  }
  handleImportSelected() {
    const selectedIds = Array.from(this.state.selectedIds);
    if (selectedIds.length === 0) {
      return;
    }
    const result = {
      selectedIds,
      totalAvailable: this.state.allConversations.length,
      mode: "selective"
    };
    this.close();
    this.onSelectionComplete(result);
  }
  formatDate(timestamp) {
    if (!timestamp)
      return t("conversation_selection.date_unknown");
    const date = new Date(timestamp * 1e3);
    return date.toLocaleDateString();
  }
  addCustomStyles() {
    const style = document.createElement("style");
    style.textContent = `
            /* Modal sizing - CRITICAL: Override Obsidian's default constraints */
            .modal.nexus-conversation-selection-dialog {
                max-width: min(1000px, 90vw) !important;
                width: min(1000px, 90vw) !important;
                height: auto !important;
                padding: 0 !important;
            }

            /* Modal title spacing */
            .modal.nexus-conversation-selection-dialog .modal-title {
                padding: 16px 24px !important;
                margin: 0 !important;
            }

            .modal.nexus-conversation-selection-dialog .modal-content {
                max-width: 100% !important;
                width: 100% !important;
                max-height: 85vh;
                overflow-y: visible;
                overflow-x: visible;
                display: flex;
                flex-direction: column;
                padding: 20px 24px 24px 24px;
            }

            /* Table container with independent scroll */
            .nexus-conversation-selection-dialog .nexus-table-container {
                max-height: 450px;
                overflow-y: auto;
                overflow-x: auto;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                margin-bottom: 20px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            /* Table styling */
            .nexus-conversation-selection-dialog table {
                font-size: 0.9em;
                width: 100%;
                min-width: 900px;
                border-collapse: collapse;
            }

            /* Table header - sticky */
            .nexus-conversation-selection-dialog thead {
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .nexus-conversation-selection-dialog th {
                background-color: var(--background-secondary);
                font-weight: 600;
                white-space: nowrap;
                position: sticky;
                top: 0;
            }

            /* Sortable headers */
            .nexus-conversation-selection-dialog th.sortable-header {
                cursor: pointer;
                user-select: none;
                transition: background-color 0.2s;
            }

            .nexus-conversation-selection-dialog th.sortable-header:hover {
                background-color: var(--background-modifier-hover);
            }

            .nexus-conversation-selection-dialog .sort-indicator {
                display: inline-block;
                margin-left: 6px;
                font-size: 0.8em;
                transition: opacity 0.2s;
            }

            /* Table cells */
            .nexus-conversation-selection-dialog td {
                padding: 10px 8px;
                border-bottom: 1px solid var(--background-modifier-border);
                vertical-align: middle;
            }

            /* Title column - allow wrapping */
            .nexus-conversation-selection-dialog th:nth-child(2),
            .nexus-conversation-selection-dialog td:nth-child(2) {
                max-width: 500px;
                white-space: normal;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            /* Other columns - no wrapping */
            .nexus-conversation-selection-dialog th:not(:nth-child(2)),
            .nexus-conversation-selection-dialog td:not(:nth-child(2)) {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Row hover effect */
            .nexus-conversation-selection-dialog tbody tr:hover {
                background-color: var(--background-modifier-hover);
                cursor: pointer;
            }

            /* Checkbox column */
            .nexus-conversation-selection-dialog td:first-child {
                text-align: center;
            }

            /* Status badges */
            .nexus-conversation-selection-dialog .status-badge {
                display: inline-block;
                padding: 4px 10px;
                border-radius: 12px;
                font-size: 0.85em;
                font-weight: 500;
                text-align: center;
            }

            .nexus-conversation-selection-dialog .status-new {
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
            }

            .nexus-conversation-selection-dialog .status-updated {
                background-color: var(--text-warning);
                color: var(--text-on-accent);
            }

            .nexus-conversation-selection-dialog .status-unchanged {
                background-color: var(--background-modifier-border);
                color: var(--text-muted);
            }

            /* Select dropdowns */
            .nexus-conversation-selection-dialog select {
                font-size: 14px;
                line-height: 1.4;
                height: auto;
                min-height: 36px;
                background-color: var(--background-primary);
                color: var(--text-normal);
                font-family: var(--font-interface);
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                padding: 8px 12px;
                cursor: pointer;
            }

            .nexus-conversation-selection-dialog select option {
                padding: 4px 8px;
                line-height: 1.4;
            }

            /* Custom select dropdowns with theme-aware arrows */
            .nexus-conversation-selection-dialog .nexus-custom-select {
                appearance: none;
                -webkit-appearance: none;
                -moz-appearance: none;
                padding-right: 32px;
                background-image: linear-gradient(45deg, transparent 50%, var(--text-muted) 50%),
                                  linear-gradient(135deg, var(--text-muted) 50%, transparent 50%);
                background-position: calc(100% - 14px) calc(50% - 2px),
                                     calc(100% - 10px) calc(50% - 2px);
                background-size: 4px 4px,
                                 4px 4px;
                background-repeat: no-repeat;
            }

            /* Buttons */
            .nexus-conversation-selection-dialog button {
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .nexus-conversation-selection-dialog button:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            /* Summary section */
            .nexus-conversation-selection-dialog .summary-section {
                background-color: var(--background-secondary);
                padding: 12px 16px;
                border-radius: 8px;
                margin-bottom: 20px;
            }

            /* Controls section */
            .nexus-conversation-selection-dialog .controls-section {
                background-color: var(--background-primary);
                padding: 12px;
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
            }

            /* Scrollbar styling for table container */
            .nexus-conversation-selection-dialog .nexus-table-container::-webkit-scrollbar {
                width: 10px;
                height: 10px;
            }

            .nexus-conversation-selection-dialog .nexus-table-container::-webkit-scrollbar-track {
                background: var(--background-secondary);
                border-radius: 5px;
            }

            .nexus-conversation-selection-dialog .nexus-table-container::-webkit-scrollbar-thumb {
                background: var(--background-modifier-border);
                border-radius: 5px;
            }

            .nexus-conversation-selection-dialog .nexus-table-container::-webkit-scrollbar-thumb:hover {
                background: var(--text-muted);
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(ConversationSelectionDialog, "ConversationSelectionDialog");

// src/dialogs/installation-welcome-dialog.ts
var import_obsidian29 = require("obsidian");
init_support_box();
init_i18n();
var InstallationWelcomeDialog = class extends import_obsidian29.Modal {
  constructor(app, version) {
    super(app);
    this.version = version;
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    modalEl.addClass("nexus-installation-welcome-dialog");
    contentEl.addClass("nexus-installation-welcome-dialog");
    titleEl.setText(t("welcome.title", { version: this.version }));
    const welcomeSection = contentEl.createDiv("welcome-section");
    welcomeSection.style.cssText = `
            text-align: center;
            margin-bottom: 24px;
        `;
    const welcomeIcon = welcomeSection.createDiv();
    welcomeIcon.innerHTML = t("welcome.icon");
    welcomeIcon.style.cssText = `
            font-size: 48px;
            margin-bottom: 12px;
        `;
    const welcomeTitle = welcomeSection.createEl("h2");
    welcomeTitle.textContent = t("welcome.heading");
    welcomeTitle.style.cssText = `
            margin: 0 0 12px 0;
            color: var(--text-normal);
        `;
    const welcomeText = welcomeSection.createDiv();
    welcomeText.textContent = t("welcome.description");
    welcomeText.style.cssText = `
            color: var(--text-muted);
            line-height: 1.6;
            font-size: 1.05em;
        `;
    createSupportBox(contentEl);
    const resourcesSection = contentEl.createDiv("resources-section");
    resourcesSection.style.cssText = `
            margin-top: 24px;
        `;
    const resourcesTitle = resourcesSection.createEl("h3");
    resourcesTitle.textContent = t("welcome.resources_title");
    resourcesTitle.style.cssText = `
            margin: 0 0 16px 0;
            color: var(--text-normal);
            font-size: 1.1em;
        `;
    const resourcesGrid = resourcesSection.createDiv("resources-grid");
    resourcesGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        `;
    const locale = window.moment.locale();
    const supported = ["fr", "de", "es", "it", "ru", "zh", "ja", "pt", "ko"];
    const docUrl = supported.includes(locale) ? `https://nexus-prod.dev/${locale}/nexus-ai-chat-importer` : "https://nexus-prod.dev/nexus-ai-chat-importer";
    const resources = [
      {
        icon: "\u{1F4D6}",
        title: t("welcome.resources.documentation.title"),
        description: t("welcome.resources.documentation.description"),
        url: docUrl
      },
      {
        icon: "\u{1F4DD}",
        title: t("welcome.resources.release_notes.title"),
        description: t("welcome.resources.release_notes.description"),
        url: "https://github.com/Superkikim/nexus-ai-chat-importer/blob/master/RELEASE_NOTES.md"
      },
      {
        icon: "\u{1F41B}",
        title: t("welcome.resources.report_issues.title"),
        description: t("welcome.resources.report_issues.description"),
        url: "https://github.com/superkikim/nexus-ai-chat-importer/issues"
      },
      {
        icon: "\u{1F4AC}",
        title: t("welcome.resources.community_forum.title"),
        description: t("welcome.resources.community_forum.description"),
        url: "https://forum.obsidian.md/t/plugin-nexus-ai-chat-importer-import-chatgpt-and-claude-conversations-to-your-vault/71664"
      }
    ];
    resources.forEach((resource) => {
      const card = this.createResourceCard(resourcesGrid, resource);
      resourcesGrid.appendChild(card);
    });
    const buttonContainer = contentEl.createDiv("button-container");
    buttonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            margin-top: 24px;
        `;
    const closeButton = buttonContainer.createEl("button", {
      text: t("welcome.buttons.get_started")
    });
    closeButton.addClass("mod-cta");
    closeButton.style.cssText = `
            padding: 10px 32px;
            font-size: 1.05em;
        `;
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  /**
   * Create a resource card
   */
  createResourceCard(container, resource) {
    const card = container.createEl("a", {
      href: resource.url
    });
    card.style.cssText = `
            display: block;
            padding: 16px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-normal);
            transition: all 0.2s;
            background: var(--background-secondary);
        `;
    card.addEventListener("mouseenter", () => {
      card.style.borderColor = "var(--interactive-accent)";
      card.style.transform = "translateY(-2px)";
      card.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.1)";
    });
    card.addEventListener("mouseleave", () => {
      card.style.borderColor = "var(--background-modifier-border)";
      card.style.transform = "translateY(0)";
      card.style.boxShadow = "none";
    });
    const icon = card.createDiv();
    icon.innerHTML = resource.icon;
    icon.style.cssText = `
            font-size: 32px;
            margin-bottom: 8px;
        `;
    const title = card.createDiv();
    title.textContent = resource.title;
    title.style.cssText = `
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-normal);
        `;
    const description = card.createDiv();
    description.textContent = resource.description;
    description.style.cssText = `
            font-size: 0.9em;
            color: var(--text-muted);
            line-height: 1.4;
        `;
    card.addEventListener("click", (e) => {
      e.preventDefault();
      window.open(resource.url, "_blank");
    });
    return card;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(InstallationWelcomeDialog, "InstallationWelcomeDialog");

// src/dialogs/new-version-modal.ts
var import_obsidian30 = require("obsidian");
init_support_box();
init_constants();
init_i18n();
var NewVersionModal = class extends import_obsidian30.Modal {
  constructor(app, plugin, version, fallbackMessage) {
    super(app);
    this.plugin = plugin;
    this.version = version;
    this.fallbackMessage = fallbackMessage;
  }
  onOpen() {
    const { titleEl, modalEl } = this;
    modalEl.classList.add("nexus-new-version-modal");
    titleEl.setText(t("upgrade.new_version_modal.title", { version: this.version }));
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
  }
  async createForm() {
    createSupportBox(this.contentEl);
    let message = this.fallbackMessage;
    try {
      const response = await fetch(`${GITHUB.RAW_BASE}/${this.version}/README.md`);
      if (response.ok) {
        const readmeText = await response.text();
        const overview = this.extractOverviewFromReadme(readmeText);
        if (overview) {
          message = overview;
        }
      }
    } catch (error) {
    }
    const contentDiv = this.contentEl.createDiv({ cls: "nexus-upgrade-content" });
    await import_obsidian30.MarkdownRenderer.render(
      this.app,
      message,
      contentDiv,
      "",
      this.plugin
    );
    this.addCloseButton();
    this.addStyles();
  }
  /**
   * Extract the "## Overview" section from README content.
   * Returns only the body under the heading (excluding the heading line itself).
   */
  extractOverviewFromReadme(readmeText) {
    const overviewRegex = /## Overview\s+([\s\S]*?)(?=^##\s|\Z)/m;
    const match = readmeText.match(overviewRegex);
    return match ? match[1].trim() : null;
  }
  addCloseButton() {
    const buttonContainer = this.contentEl.createDiv({ cls: "nexus-close-button-container" });
    const closeButton = buttonContainer.createEl("button", {
      text: t("upgrade.new_version_modal.buttons.got_it"),
      cls: "mod-cta nexus-close-button"
    });
    closeButton.onclick = () => {
      this.close();
    };
  }
  addStyles() {
    const styleEl = document.createElement("style");
    styleEl.textContent = `
            .modal.nexus-new-version-modal {
                max-width: 1050px !important;
                width: 1050px !important;
            }

            .nexus-upgrade-content {
                margin-bottom: 20px;
                line-height: 1.6;
            }

            /* Close Button Styles */
            .nexus-close-button-container {
                text-align: center;
                margin: 32px 0;
            }

            .nexus-close-button {
                padding: 16px 48px !important;
                font-size: 1.2em !important;
                font-weight: 700 !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
                transition: all 0.2s ease !important;
            }

            .nexus-close-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2) !important;
            }
        `;
    document.head.appendChild(styleEl);
  }
};
__name(NewVersionModal, "NewVersionModal");

// src/dialogs/upgrade-notice-1.3.2-dialog.ts
var UpgradeNotice132Dialog = class {
  static open(app, plugin) {
    const fallbackMessage = `## \u{1F504} What Changed

**Claude changed their export format.** If you imported Claude conversations recently and noticed missing code files or strange links, v1.3.2 fixes this.

**To get your missing files back:**
1. Delete the affected conversations from your vault
2. Re-import the same ZIP file
3. Everything will be there now \u2705

---

	## \u{1F41B} Bug Fixes
	
	- **Claude artifacts now work with the new export format**
	- **Fixed crashes during import** (missing logger errors)
	- **Fixed weird formatting** in conversations with multiple attachments
	- **Better messages** when re-importing conversations
	- **Minor fix in v1.3.3** \u2013 upgrade notice now only appears once per vault
	
	---

## \u{1F64F} Questions?

If something doesn't work as expected, please report it on the [forum thread](https://forum.obsidian.md/t/plugin-nexus-ai-chat-importer-import-chatgpt-and-claude-conversations-to-your-vault/71664).`;
    new NewVersionModal(
      app,
      plugin,
      plugin.manifest.version,
      fallbackMessage
    ).open();
  }
};
__name(UpgradeNotice132Dialog, "UpgradeNotice132Dialog");

// src/services/conversation-metadata-extractor.ts
init_utils();
init_logger();
var ConversationMetadataExtractor = class {
  constructor(providerRegistry, plugin) {
    this.providerRegistry = providerRegistry;
    this.plugin = plugin;
  }
  /**
   * Extract conversation metadata from ZIP file
   */
  async extractMetadataFromZip(zip, forcedProvider, sourceFileName, sourceFileIndex, existingConversations) {
    try {
      const rawConversations = await this.extractRawConversationsFromZip(zip);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [P0/extract] ${rawConversations.length} raw conversations found`);
      if (rawConversations.length === 0) {
        return [];
      }
      const provider = forcedProvider || this.providerRegistry.detectProvider(rawConversations);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [P0/detect] provider=${provider}`);
      if (provider === "unknown") {
        throw new Error("Could not detect conversation provider from data structure");
      }
      const metadata = this.extractMetadataByProvider(rawConversations, provider);
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [P0/metadata] ${metadata.length} metadata items extracted`);
      return metadata.map((conv) => {
        const enhanced = {
          ...conv,
          sourceFile: sourceFileName,
          sourceFileIndex
        };
        if (existingConversations) {
          const existing = existingConversations.get(conv.id);
          if (existing) {
            enhanced.existingUpdateTime = existing.updateTime;
            const comparison = compareTimestampsIgnoringSeconds(conv.updateTime, existing.updateTime);
            if (comparison > 0) {
              enhanced.existenceStatus = "updated";
              enhanced.hasNewerContent = true;
            } else {
              enhanced.existenceStatus = "unchanged";
              enhanced.hasNewerContent = false;
            }
          } else {
            enhanced.existenceStatus = "new";
            enhanced.hasNewerContent = true;
          }
        } else {
          enhanced.existenceStatus = "unknown";
        }
        return enhanced;
      });
    } catch (error) {
      throw new Error(`Failed to extract conversation metadata: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Extract raw conversation data from ZIP (provider-agnostic).
   * Fix 2 (DRY): delegates to extractRawConversations() from zip-content-reader.ts.
   */
  async extractRawConversationsFromZip(zip) {
    const { conversations } = await extractRawConversations(zip);
    return conversations;
  }
  /**
   * Extract metadata based on detected provider
   */
  extractMetadataByProvider(rawConversations, provider) {
    switch (provider) {
      case "chatgpt":
        return this.extractChatGPTMetadata(rawConversations);
      case "claude":
        return this.extractClaudeMetadata(rawConversations);
      case "lechat":
        return this.extractLeChatMetadata(rawConversations);
      case "gemini":
        return this.extractGeminiMetadata(rawConversations);
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
  /**
   * Extract metadata from ChatGPT conversations
   */
  extractChatGPTMetadata(conversations) {
    return conversations.filter((chat) => {
      if (!chat.id || chat.id.trim() === "") {
        logger.warn("Skipping ChatGPT conversation with missing ID:", chat.title || "Untitled");
        return false;
      }
      if (!chat.create_time || !chat.update_time) {
        logger.warn("Skipping ChatGPT conversation with missing timestamps:", chat.id);
        return false;
      }
      return true;
    }).map((chat) => ({
      id: chat.id,
      title: chat.title || "Untitled",
      createTime: chat.create_time,
      updateTime: chat.update_time,
      messageCount: this.countChatGPTMessages(chat),
      provider: "chatgpt",
      isStarred: chat.is_starred || false,
      isArchived: chat.is_archived || false
    })).filter((metadata) => {
      if (metadata.messageCount === 0) {
        return false;
      }
      return true;
    });
  }
  /**
   * Extract metadata from Claude conversations
   */
  extractClaudeMetadata(conversations) {
    return conversations.filter((chat) => {
      if (!chat.uuid || chat.uuid.trim() === "") {
        logger.warn("Skipping Claude conversation with missing UUID:", chat.name || "Untitled");
        return false;
      }
      if (!chat.created_at || !chat.updated_at) {
        logger.warn("Skipping Claude conversation with missing timestamps:", chat.uuid);
        return false;
      }
      return true;
    }).map((chat) => ({
      id: chat.uuid,
      title: chat.name || "Untitled",
      createTime: Math.floor(new Date(chat.created_at).getTime() / 1e3),
      updateTime: Math.floor(new Date(chat.updated_at).getTime() / 1e3),
      messageCount: this.countClaudeMessages(chat),
      provider: "claude",
      isStarred: chat.is_starred || false,
      isArchived: false
      // Claude doesn't have archived status
    })).filter((metadata) => {
      if (metadata.messageCount === 0) {
        return false;
      }
      return true;
    });
  }
  /**
   * Extract metadata from Le Chat conversations
   */
  extractLeChatMetadata(conversations) {
    return conversations.filter((chat) => {
      if (!Array.isArray(chat) || chat.length === 0) {
        logger.warn("Skipping invalid Le Chat conversation: not an array or empty");
        return false;
      }
      const firstMessage = chat[0];
      if (!firstMessage.chatId || !firstMessage.createdAt) {
        logger.warn("Skipping Le Chat conversation with missing chatId or createdAt");
        return false;
      }
      return true;
    }).map((chat) => {
      const sortedChat = [...chat].sort((a, b) => {
        const timeA = new Date(a.createdAt).getTime();
        const timeB = new Date(b.createdAt).getTime();
        return timeA - timeB;
      });
      const chatId = sortedChat[0].chatId;
      const firstUserMessage = sortedChat.find((msg) => msg.role === "user");
      let title = "Untitled";
      if (firstUserMessage && firstUserMessage.content) {
        const content = firstUserMessage.content.trim();
        title = content.length > 50 ? content.substring(0, 50).trim() + "..." : content;
      }
      const timestamps = sortedChat.map((msg) => new Date(msg.createdAt).getTime() / 1e3);
      const createTime = Math.floor(Math.min(...timestamps));
      const updateTime = Math.floor(Math.max(...timestamps));
      return {
        id: chatId,
        title,
        createTime,
        updateTime,
        messageCount: sortedChat.length,
        provider: "lechat",
        isStarred: false,
        isArchived: false
      };
    }).filter((metadata) => {
      if (metadata.messageCount === 0) {
        return false;
      }
      return true;
    });
  }
  /**
   * Extract metadata from Gemini activity entries
   */
  extractGeminiMetadata(entries) {
    return entries.filter((entry) => {
      if (!entry.time || !entry.title) {
        logger.warn("Skipping Gemini entry with missing time or title");
        return false;
      }
      const hasHtmlContent = entry.safeHtmlItem && entry.safeHtmlItem.length > 0;
      const hasAttachments = entry.attachedFiles && entry.attachedFiles.length > 0;
      if (!hasHtmlContent && !hasAttachments) {
        logger.debug("Skipping Gemini entry without content or attachments:", entry.title);
        return false;
      }
      return true;
    }).map((entry) => {
      const adapter = this.providerRegistry.getAdapter("gemini");
      if (!adapter) {
        throw new Error("Gemini adapter not found in registry");
      }
      const id = adapter.getId(entry);
      const title = adapter.getTitle(entry);
      const createTime = adapter.getCreateTime(entry);
      const updateTime = adapter.getUpdateTime(entry);
      return {
        id,
        title,
        createTime,
        updateTime,
        messageCount: 2,
        // Each Gemini entry = 1 user + 1 assistant message
        provider: "gemini",
        isStarred: false,
        isArchived: false
      };
    });
  }
  /**
   * Count messages in ChatGPT conversation (lightweight version)
   */
  countChatGPTMessages(chat) {
    if (!chat.mapping) {
      return 0;
    }
    let count = 0;
    for (const messageObj of Object.values(chat.mapping)) {
      const message = messageObj == null ? void 0 : messageObj.message;
      if (!message)
        continue;
      if (this.shouldIncludeChatGPTMessage(message)) {
        count++;
      }
    }
    return count;
  }
  /**
   * Count messages in Claude conversation (lightweight version)
   */
  countClaudeMessages(chat) {
    if (!chat.chat_messages || !Array.isArray(chat.chat_messages)) {
      return 0;
    }
    let count = 0;
    for (const message of chat.chat_messages) {
      if (this.shouldIncludeClaudeMessage(message)) {
        count++;
      }
    }
    return count;
  }
  /**
   * Lightweight version of ChatGPT message filtering
   */
  shouldIncludeChatGPTMessage(message) {
    var _a;
    if (!message || !message.author) {
      return false;
    }
    if (message.author.role === "system" || message.author.role === "tool") {
      return false;
    }
    if (((_a = message.metadata) == null ? void 0 : _a.is_visually_hidden_from_conversation) === true) {
      return false;
    }
    return isValidMessage(message);
  }
  /**
   * Lightweight version of Claude message filtering
   */
  shouldIncludeClaudeMessage(message) {
    if (!message || !message.uuid || !message.sender) {
      return false;
    }
    return message.sender === "human" || message.sender === "assistant";
  }
  /**
   * Extract metadata from multiple ZIP files (for multi-file selective import)
   * Follows the same logic as the working import process:
   * 1. Process files chronologically
   * 2. Build map of best versions per conversation ID
   * 3. Compare with vault and filter out unchanged conversations
   * 4. Only return NEW and UPDATED conversations for selection
   */
  async extractMetadataFromMultipleZips(files, forcedProvider, existingConversations) {
    const conversationMap = /* @__PURE__ */ new Map();
    const allConversationsFound = [];
    const fileStatsMap = /* @__PURE__ */ new Map();
    const conversationToFileMap = /* @__PURE__ */ new Map();
    const unrecognizedFiles = [];
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/start] Processing ${files.length} ZIPs for metadata extraction`);
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/${i + 1}/${files.length}] Starting ${file.name} (${(file.size / 1024 / 1024).toFixed(0)} MB, mobile=${!file.path})`);
      try {
        const archiveModeDecision = decideArchiveMode({ zipSizeBytes: file.size });
        if (archiveModeDecision.mode === "large-archive") {
          logger.info(
            `Metadata extraction: large archive detected for ${file.name} (reason: ${archiveModeDecision.reason}, size=${file.size})`
          );
        }
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/decompress] Loading ${file.name} (${file.size} bytes, mobile=${!file.path})`);
        const metadata = await (async () => {
          const zc = await loadZipSelective(
            file,
            (entryName) => entryName.endsWith(".json")
          );
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/decompress] ZIP loaded \u2014 ${Object.keys(zc.files).length} JSON entries`);
          return this.extractMetadataFromZip(zc, forcedProvider, file.name, i, void 0);
        })();
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/${i + 1}/${files.length}] Metadata extracted: ${metadata.length} conversations in ${file.name}`);
        await new Promise((resolve) => setTimeout(resolve, 0));
        allConversationsFound.push(...metadata);
        const totalInFile = metadata.length;
        let duplicatesInFile = 0;
        let uniqueFromFile = 0;
        for (const conversation of metadata) {
          const existing = conversationMap.get(conversation.id);
          if (!existing) {
            uniqueFromFile++;
            conversationMap.set(conversation.id, conversation);
            conversationToFileMap.set(conversation.id, file.name);
          } else {
            let shouldReplace = false;
            const comparison = compareTimestampsIgnoringSeconds(conversation.updateTime, existing.updateTime);
            if (comparison > 0) {
              shouldReplace = true;
            } else if (comparison === 0) {
              const currentFileIndex = conversation.sourceFileIndex || 0;
              const existingFileIndex = existing.sourceFileIndex || 0;
              if (currentFileIndex > existingFileIndex) {
                shouldReplace = true;
              }
            }
            if (shouldReplace) {
              const oldFileName = conversationToFileMap.get(conversation.id);
              const oldFileStats = fileStatsMap.get(oldFileName);
              if (oldFileStats) {
                oldFileStats.uniqueContributed--;
                oldFileStats.duplicates++;
              }
              uniqueFromFile++;
              conversationMap.set(conversation.id, conversation);
              conversationToFileMap.set(conversation.id, file.name);
            } else {
              duplicatesInFile++;
            }
          }
        }
        fileStatsMap.set(file.name, {
          fileName: file.name,
          totalConversations: totalInFile,
          duplicates: duplicatesInFile,
          uniqueContributed: uniqueFromFile,
          selectedForImport: 0,
          newConversations: 0,
          updatedConversations: 0,
          skippedConversations: 0
        });
      } catch (error) {
        const reason = error instanceof Error ? error.message : String(error);
        logger.error(`Error extracting metadata from ${file.name}:`, error);
        console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [meta/${i + 1}/${files.length}] FAILED ${file.name}: ${reason}`);
        unrecognizedFiles.push({ name: file.name, reason });
      }
    }
    const filterResult = this.filterConversationsForSelection(
      Array.from(conversationMap.values()),
      existingConversations
    );
    for (const conversation of filterResult.conversations) {
      const fileName = conversation.sourceFile;
      if (fileName && fileStatsMap.has(fileName)) {
        const stats = fileStatsMap.get(fileName);
        stats.selectedForImport++;
        if (conversation.existenceStatus === "new") {
          stats.newConversations++;
        } else if (conversation.existenceStatus === "updated") {
          stats.updatedConversations++;
        }
      }
    }
    for (const conversation of filterResult.ignoredConversations) {
      const fileName = conversation.sourceFile;
      if (fileName && fileStatsMap.has(fileName)) {
        const stats = fileStatsMap.get(fileName);
        stats.skippedConversations++;
      }
    }
    const analysisInfo = {
      totalConversationsFound: allConversationsFound.length,
      uniqueConversationsKept: conversationMap.size,
      duplicatesRemoved: allConversationsFound.length - conversationMap.size,
      hasMultipleFiles: files.length > 1,
      conversationsNew: filterResult.newCount,
      conversationsUpdated: filterResult.updatedCount,
      conversationsIgnored: filterResult.ignoredCount,
      unrecognizedFiles
    };
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [P0/compare] total=${allConversationsFound.length} unique=${conversationMap.size} duplicates=${analysisInfo.duplicatesRemoved} new=${filterResult.newCount} updated=${filterResult.updatedCount} unchanged=${filterResult.ignoredCount}`);
    return {
      conversations: filterResult.conversations,
      analysisInfo,
      fileStats: fileStatsMap
    };
  }
  /**
   * @deprecated - Old deduplication methods, replaced by new chronological approach
   * Kept for compatibility but no longer used in the main flow
   */
  deduplicateConversations(conversations) {
    return conversations;
  }
  /**
   * Filter conversations for selection dialog (same logic as working import process)
   * Only returns NEW and UPDATED conversations - filters out UNCHANGED completely
   */
  filterConversationsForSelection(bestVersions, existingConversations) {
    const conversationsForSelection = [];
    const ignoredConversations = [];
    let newCount = 0;
    let updatedCount = 0;
    let ignoredCount = 0;
    for (const conversation of bestVersions) {
      if (!existingConversations) {
        conversation.existenceStatus = "new";
        conversation.hasNewerContent = true;
        conversationsForSelection.push(conversation);
        newCount++;
        continue;
      }
      const vaultConversation = existingConversations.get(conversation.id);
      if (!vaultConversation) {
        conversation.existenceStatus = "new";
        conversation.hasNewerContent = true;
        conversationsForSelection.push(conversation);
        newCount++;
      } else {
        conversation.existingUpdateTime = vaultConversation.updateTime;
        const { moment: moment3 } = require("obsidian");
        const zipUpdateTimeISO = new Date(conversation.updateTime * 1e3).toISOString();
        const normalizedZipUpdateTime = moment3(zipUpdateTimeISO, moment3.ISO_8601, true).unix();
        const comparison = compareTimestampsIgnoringSeconds(normalizedZipUpdateTime, vaultConversation.updateTime);
        if (comparison > 0) {
          conversation.existenceStatus = "updated";
          conversation.hasNewerContent = true;
          conversationsForSelection.push(conversation);
          updatedCount++;
        } else {
          conversation.existenceStatus = "unchanged";
          ignoredConversations.push(conversation);
          ignoredCount++;
        }
      }
    }
    return {
      conversations: conversationsForSelection,
      ignoredConversations,
      newCount,
      updatedCount,
      ignoredCount
    };
  }
  /**
   * @deprecated - Old deduplication logic, replaced by new chronological approach
   */
  ensureCorrectExistenceStatus(keptConversation, currentConversation, existingConversation) {
    return keptConversation;
  }
  /**
   * Get total conversation count from ZIP without extracting all metadata
   */
  async getConversationCount(zip) {
    try {
      const rawConversations = await this.extractRawConversationsFromZip(zip);
      return rawConversations.length;
    } catch (error) {
      return 0;
    }
  }
};
__name(ConversationMetadataExtractor, "ConversationMetadataExtractor");

// src/dialogs/import-completion-dialog.ts
var import_obsidian31 = require("obsidian");
init_support_box();
init_logger();
init_i18n();
var logger5 = new Logger();
var ImportCompletionDialog = class extends import_obsidian31.Modal {
  constructor(app, stats, reportFilePath) {
    super(app);
    this.stats = stats;
    this.reportFilePath = reportFilePath;
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    modalEl.addClass("nexus-import-completion-dialog");
    contentEl.addClass("nexus-import-completion-dialog");
    titleEl.setText(t("import_completion.title"));
    const successMsg = contentEl.createDiv("success-message");
    successMsg.style.textAlign = "center";
    successMsg.style.marginBottom = "20px";
    successMsg.style.fontSize = "1.1em";
    successMsg.style.color = "var(--color-green)";
    successMsg.innerHTML = t("import_completion.success_message");
    this.createStatsSection(contentEl);
    if (this.stats.attachmentsTotal > 0) {
      this.createAttachmentsSection(contentEl);
    }
    this.createReportSection(contentEl);
    createSupportBox(contentEl);
    this.createActionButtons(contentEl);
    this.addCustomStyles();
  }
  createStatsSection(container) {
    const section = container.createDiv("stats-section");
    section.style.marginBottom = "20px";
    section.style.display = "grid";
    section.style.gridTemplateColumns = "repeat(3, 1fr)";
    section.style.gap = "12px";
    this.createStatCartouche(section, "\u{1F4C1}", this.stats.totalFiles.toString(), t("import_completion.stats.zip_files_processed"));
    this.createStatCartouche(section, "\u{1F4AC}", this.stats.totalConversations.toString(), t("import_completion.stats.unique_conversations"));
    this.createStatCartouche(section, "\u{1F501}", this.stats.duplicates.toString(), t("import_completion.stats.duplicates"), "var(--text-muted)");
    this.createStatCartouche(section, "\u2728", this.stats.created.toString(), t("import_completion.stats.new"), "var(--color-green)");
    this.createStatCartouche(section, "\u{1F504}", this.stats.updated.toString(), t("import_completion.stats.updated"), "var(--color-orange)");
    this.createStatCartouche(section, "\u23ED\uFE0F", this.stats.skipped.toString(), t("import_completion.stats.skipped"), "var(--text-muted)");
    if (this.stats.failed > 0) {
      this.createStatCartouche(section, "\u274C", this.stats.failed.toString(), t("import_completion.stats.failed"), "var(--color-red)");
    }
  }
  createStatCartouche(container, icon, value, label, color) {
    const cartouche = container.createDiv("stat-cartouche");
    cartouche.style.textAlign = "center";
    cartouche.style.padding = "12px";
    cartouche.style.backgroundColor = "var(--background-primary)";
    cartouche.style.borderRadius = "8px";
    cartouche.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
    const iconEl = cartouche.createDiv();
    iconEl.textContent = icon;
    iconEl.style.fontSize = "1.5em";
    iconEl.style.marginBottom = "4px";
    const valueEl = cartouche.createDiv();
    valueEl.textContent = value;
    valueEl.style.fontWeight = "600";
    valueEl.style.fontSize = "1.4em";
    valueEl.style.color = color || "var(--text-accent)";
    valueEl.style.marginBottom = "4px";
    const labelEl = cartouche.createDiv();
    labelEl.textContent = label;
    labelEl.style.fontSize = "0.85em";
    labelEl.style.color = "var(--text-muted)";
  }
  createAttachmentsSection(container) {
    const section = container.createDiv("attachments-section");
    section.style.marginBottom = "20px";
    section.style.padding = "12px";
    section.style.backgroundColor = "var(--background-secondary)";
    section.style.borderRadius = "6px";
    section.style.textAlign = "center";
    const percentage = Math.round(this.stats.attachmentsFound / this.stats.attachmentsTotal * 100);
    const icon = percentage === 100 ? "\u2705" : percentage > 50 ? "\u26A0\uFE0F" : "\u274C";
    const color = percentage === 100 ? "var(--color-green)" : percentage > 50 ? "var(--color-orange)" : "var(--color-red)";
    const attachmentText = section.createDiv();
    attachmentText.innerHTML = `${icon} <strong>${t("import_completion.attachments.label")}</strong> ${t("import_completion.attachments.summary", { found: String(this.stats.attachmentsFound), total: String(this.stats.attachmentsTotal), percentage: String(percentage) })}`;
    attachmentText.style.color = color;
    if (this.stats.attachmentsMissing > 0 || this.stats.attachmentsFailed > 0) {
      const details = section.createDiv();
      details.style.fontSize = "0.85em";
      details.style.color = "var(--text-muted)";
      details.style.marginTop = "4px";
      details.textContent = t("import_completion.attachments.missing_failed", { missing: String(this.stats.attachmentsMissing), failed: String(this.stats.attachmentsFailed) });
    }
  }
  createReportSection(container) {
    const section = container.createDiv("report-section");
    section.style.marginBottom = "20px";
    section.style.padding = "12px";
    section.style.backgroundColor = "var(--background-secondary)";
    section.style.borderRadius = "6px";
    const label = section.createDiv();
    label.textContent = t("import_completion.report.label");
    label.style.fontSize = "0.9em";
    label.style.color = "var(--text-muted)";
    label.style.marginBottom = "6px";
    const link = section.createEl("a");
    link.textContent = this.reportFilePath;
    link.style.color = "var(--text-accent)";
    link.style.textDecoration = "none";
    link.style.cursor = "pointer";
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.openReport();
    });
    link.addEventListener("mouseenter", () => {
      link.style.textDecoration = "underline";
    });
    link.addEventListener("mouseleave", () => {
      link.style.textDecoration = "none";
    });
  }
  createActionButtons(container) {
    const buttonContainer = container.createDiv("action-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const viewReportBtn = buttonContainer.createEl("button", { text: t("import_completion.buttons.view_report") });
    viewReportBtn.style.padding = "8px 16px";
    viewReportBtn.addEventListener("click", () => {
      this.openReport();
      this.close();
    });
    const okBtn = buttonContainer.createEl("button", { text: t("import_completion.buttons.ok") });
    okBtn.classList.add("mod-cta");
    okBtn.style.padding = "8px 16px";
    okBtn.addEventListener("click", () => this.close());
  }
  async openReport() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.reportFilePath);
      if (file) {
        await this.app.workspace.getLeaf(false).openFile(file);
      }
    } catch (error) {
      logger5.error("Failed to open report:", error);
    }
  }
  addCustomStyles() {
    const style = document.createElement("style");
    style.textContent = `
            /* Modal sizing */
            .modal.nexus-import-completion-dialog {
                max-width: min(700px, 90vw) !important;
                width: min(700px, 90vw) !important;
            }

            /* Modal title spacing */
            .modal.nexus-import-completion-dialog .modal-title {
                padding: 16px 24px !important;
                margin: 0 !important;
            }

            .modal.nexus-import-completion-dialog .modal-content {
                padding: 20px 24px 24px 24px;
            }

            /* Stat cartouches hover effect */
            .nexus-import-completion-dialog .stat-cartouche {
                transition: transform 0.2s, box-shadow 0.2s;
            }

            .nexus-import-completion-dialog .stat-cartouche:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            }

            /* Button hover effects */
            .nexus-import-completion-dialog button {
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .nexus-import-completion-dialog button:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
__name(ImportCompletionDialog, "ImportCompletionDialog");

// src/main.ts
init_utils();
var NexusAiChatImporterPlugin = class extends import_obsidian32.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.logger = new Logger();
    this.currentGeminiIndex = null;
    this.storageService = new StorageService(this);
    this.importService = new ImportService(this);
    this.fileService = new FileService(this);
    this.commandRegistry = new CommandRegistry(this);
    this.eventHandlers = new EventHandlers(this);
    this.upgradeManager = new IncrementalUpgradeManager(this);
  }
  async onload() {
    try {
      initLocale();
      await this.loadSettings();
      this.addSettingTab(new NexusAiChatImporterPluginSettingTab(this.app, this));
      this.commandRegistry.registerCommands();
      this.eventHandlers.registerEvents();
      const ribbonIconEl = this.addRibbonIcon(
        "message-square-plus",
        t("notices.ribbon_tooltip"),
        () => this.showProviderSelectionDialog()
      );
      ribbonIconEl.addClass("nexus-ai-chat-ribbon");
      const upgradeResult = await this.upgradeManager.checkAndPerformUpgrade();
      if (upgradeResult == null ? void 0 : upgradeResult.isFreshInstall) {
        new InstallationWelcomeDialog(this.app, this.manifest.version).open();
      }
      if ((upgradeResult == null ? void 0 : upgradeResult.showCompletionDialog) && (upgradeResult == null ? void 0 : upgradeResult.upgradedToVersion)) {
        await this.upgradeManager.showUpgradeCompleteDialog(upgradeResult.upgradedToVersion);
      }
      if (this.settings.previousVersion === "1.3.0" && !this.settings.hasSeenClaude132UpgradeNotice) {
        UpgradeNotice132Dialog.open(this.app, this);
        this.settings.hasSeenClaude132UpgradeNotice = true;
        await this.saveSettings();
      }
    } catch (error) {
      this.logger.error("Plugin loading failed:", error);
      throw error;
    }
  }
  async onunload() {
    try {
      this.eventHandlers.cleanup();
      await this.saveSettings();
    } catch (error) {
      this.logger.error("Plugin unloading failed:", error);
    }
  }
  async loadSettings() {
    try {
      const data = await this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, (data == null ? void 0 : data.settings) || {});
      const currentVersion = this.manifest.version;
      const storedCurrentVersion = this.settings.currentVersion;
      if (!storedCurrentVersion || storedCurrentVersion === "0.0.0") {
        const hasExistingConversations = await this.hasExistingNexusConversations();
        if (hasExistingConversations) {
          this.settings.previousVersion = "1.0.x";
          this.settings.currentVersion = currentVersion;
        } else {
          this.settings.previousVersion = currentVersion;
          this.settings.currentVersion = currentVersion;
        }
        await this.saveSettings();
      } else if (storedCurrentVersion !== currentVersion) {
        this.settings.previousVersion = storedCurrentVersion;
        this.settings.currentVersion = currentVersion;
        await this.saveSettings();
      }
      await this.storageService.loadData();
    } catch (error) {
      this.logger.error("loadSettings failed:", error);
      throw error;
    }
  }
  /**
   * Check if vault contains existing Nexus conversations
   */
  async hasExistingNexusConversations() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      return files.some((file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return (frontmatter == null ? void 0 : frontmatter.nexus) === this.manifest.id;
      });
    } catch (error) {
      this.logger.warn("Error checking for existing conversations:", error);
      return false;
    }
  }
  async saveSettings() {
    try {
      const existingData = await this.loadData() || {};
      let finalImportedArchives = this.storageService.getImportedArchives();
      if (existingData.importedArchives && Object.keys(existingData.importedArchives).length > 0) {
        const existingArchives = existingData.importedArchives;
        const storageArchives = this.storageService.getImportedArchives();
        finalImportedArchives = {
          ...existingArchives,
          ...storageArchives
        };
      }
      const mergedData = {
        ...existingData,
        settings: this.settings,
        importedArchives: finalImportedArchives,
        upgradeHistory: existingData.upgradeHistory || {
          completedUpgrades: {},
          completedOperations: {}
        }
      };
      await this.storageService.saveData(mergedData);
    } catch (error) {
      this.logger.error("saveSettings failed:", error);
    }
  }
  async resetCatalogs() {
    try {
      await this.storageService.resetCatalogs();
      await this.loadSettings();
    } catch (error) {
      this.logger.error("resetCatalogs failed:", error);
    }
  }
  getStorageService() {
    return this.storageService;
  }
  getImportService() {
    return this.importService;
  }
  getFileService() {
    return this.fileService;
  }
  getUpgradeManager() {
    return this.upgradeManager;
  }
  /**
   * Show provider selection dialog and then file selection
   * Ensures migration is complete before allowing import
   */
  async showProviderSelectionDialog() {
    const upgradeResult = await this.upgradeManager.checkAndPerformUpgrade();
    if (upgradeResult !== null && !upgradeResult.success) {
      return;
    }
    const providerRegistry = createProviderRegistry(this);
    new ProviderSelectionDialog(
      this.app,
      providerRegistry,
      (selectedProvider) => {
        this.showEnhancedFileSelectionDialog(selectedProvider);
      }
    ).open();
  }
  /**
   * Show enhanced file selection dialog with import mode choice
   */
  showEnhancedFileSelectionDialog(provider) {
    new EnhancedFileSelectionDialog(
      this.app,
      provider,
      (result) => {
        this.handleFileSelectionResult(result);
      },
      this
    ).open();
  }
  /**
   * Handle the result from enhanced file selection dialog
   */
  async handleFileSelectionResult(result) {
    const { files: rawFiles, mode, provider } = result;
    if (rawFiles.length === 0) {
      return;
    }
    const seenNames = /* @__PURE__ */ new Set();
    const files = rawFiles.filter((f) => seenNames.has(f.name) ? false : (seenNames.add(f.name), true));
    if (files.length < rawFiles.length) {
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleFileSelectionResult] Deduplicated: ${rawFiles.length} \u2192 ${files.length} files`);
    }
    const zipFiles = files.filter((file) => file.name.toLowerCase().endsWith(".zip"));
    const jsonFiles = files.filter((file) => file.name.toLowerCase().endsWith(".json"));
    if (provider === "gemini") {
      if (zipFiles.length === 0) {
        new import_obsidian32.Notice(t("notices.import_no_zip_gemini"));
        this.logger.warn("[Gemini] No ZIP files selected for import");
        return;
      }
      let index = null;
      if (jsonFiles.length > 0) {
        const latestIndexFile = jsonFiles.reduce((latest, current) => {
          return current.lastModified > latest.lastModified ? current : latest;
        });
        try {
          const content = await latestIndexFile.text();
          const parsed = JSON.parse(content);
          if (parsed && typeof parsed === "object" && Array.isArray(parsed.conversations)) {
            index = parsed;
            this.logger.info(
              `[Gemini] Loaded index file "${latestIndexFile.name}" with ${parsed.conversations.length} conversations`
            );
          } else {
            this.logger.warn(
              `[Gemini] JSON index file "${latestIndexFile.name}" does not look like a valid GeminiIndex (missing conversations array)`
            );
          }
        } catch (error) {
          this.logger.error("[Gemini] Failed to parse Gemini index JSON", error);
          new import_obsidian32.Notice(t("notices.import_gemini_json_failed"));
        }
      }
      this.currentGeminiIndex = index;
      this.importService.setGeminiIndex(index);
      const sortedZipFiles = this.sortFilesByTimestamp(zipFiles);
      if (mode === "all") {
        await this.handleImportAll(sortedZipFiles, provider);
      } else {
        await this.handleSelectiveImport(sortedZipFiles, provider);
      }
    } else {
      if (this.currentGeminiIndex) {
        this.currentGeminiIndex = null;
        this.importService.setGeminiIndex(null);
      }
      if (zipFiles.length === 0) {
        new import_obsidian32.Notice(t("notices.import_no_zip"));
        this.logger.warn(`[${provider}] No ZIP files selected for import`);
        return;
      }
      const sortedZipFiles = this.sortFilesByTimestamp(zipFiles);
      if (mode === "all") {
        await this.handleImportAll(sortedZipFiles, provider);
      } else {
        await this.handleSelectiveImport(sortedZipFiles, provider);
      }
    }
  }
  /**
   * Handle "Import All" mode with analysis and auto-selection
   */
  async handleImportAll(files, provider) {
    var _a, _b, _c, _d, _e;
    try {
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] START \u2014 ${files.length} ZIPs, provider=${provider}, mobile=${!((_a = files[0]) == null ? void 0 : _a.path)}`);
      new import_obsidian32.Notice(t("notices.import_analyzing", { count: String(files.length) }));
      const providerRegistry = createProviderRegistry(this);
      const metadataExtractor = new ConversationMetadataExtractor(providerRegistry, this);
      const storage = this.getStorageService();
      const existingConversations = await storage.scanExistingConversations();
      const extractionResult = await metadataExtractor.extractMetadataFromMultipleZips(
        files,
        provider,
        existingConversations
      );
      const operationReport = new ImportReport();
      if (this.settings.useCustomMessageTimestampFormat) {
        operationReport.setCustomTimestampFormat(this.settings.messageTimestampFormat);
      }
      if (extractionResult.conversations.length === 0) {
        new import_obsidian32.Notice(t("notices.import_no_new"));
        const reportPath2 = await this.writeConsolidatedReport(operationReport, provider, files, extractionResult.analysisInfo, extractionResult.fileStats, false);
        if (reportPath2) {
          this.showImportCompletionDialog(operationReport, reportPath2);
        }
        return;
      }
      const allIds = extractionResult.conversations.map((c) => c.id);
      const newCount = (_c = (_b = extractionResult.analysisInfo) == null ? void 0 : _b.conversationsNew) != null ? _c : 0;
      const updatedCount = (_e = (_d = extractionResult.analysisInfo) == null ? void 0 : _d.conversationsUpdated) != null ? _e : 0;
      new import_obsidian32.Notice(t("notices.import_starting", { count: String(allIds.length), new: String(newCount), updated: String(updatedCount) }));
      const conversationsByFile = /* @__PURE__ */ new Map();
      extractionResult.conversations.forEach((conv) => {
        if (conv.sourceFile) {
          if (!conversationsByFile.has(conv.sourceFile)) {
            conversationsByFile.set(conv.sourceFile, []);
          }
          conversationsByFile.get(conv.sourceFile).push(conv.id);
        }
      });
      if (provider === "chatgpt" && files.length > 1) {
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Building attachment map for ${files.length} ChatGPT ZIPs...`);
        await this.importService.buildAttachmentMapForMultiZip(files, provider);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Attachment map done`);
      }
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Starting import loop: ${files.length} files`);
      for (const file of files) {
        const conversationsForFile = conversationsByFile.get(file.name);
        if (conversationsForFile && conversationsForFile.length > 0) {
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Processing ${file.name} \u2014 ${conversationsForFile.length} conversations`);
          try {
            await this.importService.handleZipFile(file, provider, conversationsForFile, operationReport);
            console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Done: ${file.name}`);
          } catch (error) {
            this.logger.error(`Error processing file ${file.name}:`, error);
            console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] FAILED: ${file.name}:`, error instanceof Error ? error.message : error);
          }
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] GC yield before next file`);
          await new Promise((resolve) => setTimeout(resolve, 50));
        } else {
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleImportAll] Skipping ${file.name} \u2014 no conversations to import`);
        }
      }
      if (provider === "chatgpt" && files.length > 1) {
        this.importService.clearAttachmentMap();
      }
      const reportPath = await this.writeConsolidatedReport(operationReport, provider, files, extractionResult.analysisInfo, extractionResult.fileStats, false);
      if (reportPath) {
        this.showImportCompletionDialog(operationReport, reportPath);
      } else {
        new import_obsidian32.Notice(t("notices.import_completed_fallback", { created: String(operationReport.getCreatedCount()), updated: String(operationReport.getUpdatedCount()) }));
      }
    } catch (error) {
      this.logger.error("[IMPORT-ALL] Error in import all:", error);
      if (error instanceof Error) {
        this.logger.error("[IMPORT-ALL] Error message:", error.message);
        this.logger.error("[IMPORT-ALL] Error name:", error.name);
        this.logger.error("[IMPORT-ALL] Error stack:", error.stack);
      } else {
        this.logger.error("[IMPORT-ALL] Error (not Error instance):", String(error));
      }
      new import_obsidian32.Notice(t("notices.import_error", { error: error instanceof Error ? error.message : String(error) }));
    }
  }
  /**
   * Handle selective import workflow
   */
  async handleSelectiveImport(files, provider) {
    try {
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleSelectiveImport] START \u2014 ${files.length} ZIPs, provider=${provider}`);
      new import_obsidian32.Notice(t("notices.import_analyzing", { count: String(files.length) }));
      const providerRegistry = createProviderRegistry(this);
      const metadataExtractor = new ConversationMetadataExtractor(providerRegistry, this);
      const storage = this.getStorageService();
      const existingConversations = await storage.scanExistingConversations();
      const extractionResult = await metadataExtractor.extractMetadataFromMultipleZips(
        files,
        provider,
        existingConversations
      );
      if (extractionResult.conversations.length === 0) {
        new import_obsidian32.Notice(t("notices.import_no_new"));
        const operationReport = new ImportReport();
        const reportPath = await this.writeConsolidatedReport(
          operationReport,
          provider,
          files,
          extractionResult.analysisInfo,
          extractionResult.fileStats,
          true
          // isSelective
        );
        if (reportPath) {
          this.showImportCompletionDialog(operationReport, reportPath);
        }
        return;
      }
      new ConversationSelectionDialog(
        this.app,
        extractionResult.conversations,
        (result) => {
          this.handleConversationSelectionResult(result, files, provider, extractionResult.analysisInfo, extractionResult.fileStats);
        },
        this,
        extractionResult.analysisInfo
      ).open();
    } catch (error) {
      this.logger.error("[SELECTIVE-IMPORT] Error in selective import:", error);
      this.logger.error("[SELECTIVE-IMPORT] Full error details:", error);
      if (error instanceof Error) {
        this.logger.error("[SELECTIVE-IMPORT] Error stack:", error.stack);
      }
      new import_obsidian32.Notice(t("notices.import_error_analyzing", { error: error instanceof Error ? error.message : String(error) }));
    }
  }
  /**
   * Handle the result from conversation selection dialog
   */
  async handleConversationSelectionResult(result, files, provider, analysisInfo, fileStats) {
    const operationReport = new ImportReport();
    if (this.settings.useCustomMessageTimestampFormat) {
      operationReport.setCustomTimestampFormat(this.settings.messageTimestampFormat);
    }
    if (result.selectedIds.length === 0) {
      new import_obsidian32.Notice(t("notices.import_no_selected"));
      const reportPath2 = await this.writeConsolidatedReport(operationReport, provider, files, analysisInfo, fileStats, true);
      if (reportPath2) {
        this.showImportCompletionDialog(operationReport, reportPath2);
      }
      return;
    }
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] START \u2014 ${result.selectedIds.length} conversations selected across ${files.length} files`);
    new import_obsidian32.Notice(t("notices.import_starting_selected", { count: String(result.selectedIds.length), files: String(files.length) }));
    const conversationsByFile = await this.groupConversationsByFile(result, files);
    if (provider === "chatgpt" && files.length > 1) {
      console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Building attachment map for ${files.length} ChatGPT ZIPs...`);
      try {
        await this.importService.buildAttachmentMapForMultiZip(files, provider);
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Attachment map done`);
      } catch (error) {
        this.logger.error("Failed to build attachment map:", error);
        console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Attachment map FAILED:`, error instanceof Error ? error.message : error);
        new import_obsidian32.Notice(t("notices.attachment_map_failed"));
      }
    }
    console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Starting import loop: ${files.length} files`);
    for (const file of files) {
      const conversationsForFile = conversationsByFile.get(file.name);
      if (conversationsForFile && conversationsForFile.length > 0) {
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Processing ${file.name} \u2014 ${conversationsForFile.length} conversations`);
        try {
          await this.importService.handleZipFile(file, provider, conversationsForFile, operationReport);
          console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Done: ${file.name}`);
        } catch (error) {
          this.logger.error(`Error processing file ${file.name}:`, error);
          console.error(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] FAILED: ${file.name}:`, error instanceof Error ? error.message : error);
          new import_obsidian32.Notice(t("notices.import_error_file", { filename: file.name }));
        }
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] GC yield before next file`);
        await new Promise((resolve) => setTimeout(resolve, 50));
      } else {
        console.log(`[NexusAI][${new Date().toISOString().slice(11, 23)}] [handleConvSelection] Skipping ${file.name} \u2014 no conversations to import`);
      }
    }
    if (provider === "chatgpt" && files.length > 1) {
      this.importService.clearAttachmentMap();
    }
    const reportPath = await this.writeConsolidatedReport(operationReport, provider, files, analysisInfo, fileStats, true);
    if (reportPath) {
      this.showImportCompletionDialog(operationReport, reportPath);
    } else {
      new import_obsidian32.Notice(t("notices.import_completed_fallback", { created: String(operationReport.getCreatedCount()), updated: String(operationReport.getUpdatedCount()) }));
    }
  }
  /**
   * Write consolidated report for multi-file import
   */
  async writeConsolidatedReport(report, provider, files, analysisInfo, fileStats, isSelectiveImport) {
    var _a;
    const reportFolder = this.settings.reportFolder;
    const providerRegistry = createProviderRegistry(this);
    const adapter = providerRegistry.getAdapter(provider);
    let providerName = provider;
    if (adapter) {
      const strategy = adapter.getReportNamingStrategy();
      providerName = strategy.getProviderName();
      const columnInfo = strategy.getProviderSpecificColumn();
      report.setProviderSpecificColumnHeader(columnInfo.header);
    }
    const folderPath = `${reportFolder}/${providerName}`;
    const folderResult = await ensureFolderExists(folderPath, this.app.vault);
    if (!folderResult.success) {
      this.logger.error(`Failed to create or access log folder: ${folderPath}`, folderResult.error);
      new import_obsidian32.Notice(t("notices.report_failed"));
      return "";
    }
    const now = Date.now() / 1e3;
    const datePrefix = formatTimestamp(now, "prefix");
    const timeStr = formatTimestamp(now, "time").replace(/:/g, "").replace(/ /g, "");
    let logFilePath = `${folderPath}/${datePrefix}-${timeStr} - import report.md`;
    let counter = 2;
    while (await this.app.vault.adapter.exists(logFilePath)) {
      logFilePath = `${folderPath}/${datePrefix}-${timeStr}-${counter} - import report.md`;
      counter++;
    }
    const currentDate = new Date().toISOString();
    if (fileStats) {
      report.setFileStats(fileStats);
    }
    if (analysisInfo) {
      report.setAnalysisInfo(analysisInfo);
      if (((_a = analysisInfo.unrecognizedFiles) == null ? void 0 : _a.length) > 0) {
        for (const uf of analysisInfo.unrecognizedFiles) {
          report.addError(`Skipped (unrecognized): ${uf.name}`, uf.reason);
        }
      }
    }
    const stats = report.getCompletionStats();
    const processedFiles = [];
    const skippedFiles = [];
    if (stats.totalFiles > 0) {
      report.getProcessedFileNames().forEach((name) => processedFiles.push(name));
    }
    files.forEach((file) => {
      if (!processedFiles.includes(file.name)) {
        skippedFiles.push(file.name);
      }
    });
    const logContent = `---
importdate: ${currentDate}
provider: ${provider}
totalFilesAnalyzed: ${files.length}
totalFilesProcessed: ${processedFiles.length}
totalFilesSkipped: ${skippedFiles.length}
totalConversations: ${stats.totalConversations}
totalCreated: ${stats.created}
totalUpdated: ${stats.updated}
totalSkipped: ${stats.skipped}
totalFailed: ${stats.failed}
---

${report.generateReportContent(files, processedFiles, skippedFiles, analysisInfo, fileStats, isSelectiveImport)}
`;
    try {
      await this.app.vault.create(logFilePath, logContent);
      return logFilePath;
    } catch (error) {
      this.logger.error(`Failed to write import log to ${logFilePath}:`, error);
      this.logger.error("Full error:", error);
      this.logger.error("Log content length:", logContent.length);
      new import_obsidian32.Notice(t("notices.report_failed"));
      return "";
    }
  }
  /**
   * Show import completion dialog
   */
  showImportCompletionDialog(report, reportPath) {
    const stats = report.getCompletionStats();
    new ImportCompletionDialog(
      this.app,
      stats,
      reportPath
    ).open();
  }
  /**
   * Group selected conversations by their source file for multi-file import
   */
  async groupConversationsByFile(result, files) {
    const conversationsByFile = /* @__PURE__ */ new Map();
    try {
      const providerRegistry = createProviderRegistry(this);
      const metadataExtractor = new ConversationMetadataExtractor(providerRegistry, this);
      const storage = this.getStorageService();
      const existingConversations = await storage.scanExistingConversations();
      const extractionResult = await metadataExtractor.extractMetadataFromMultipleZips(
        files,
        void 0,
        // Let it auto-detect provider
        existingConversations
      );
      const selectedIdsSet = new Set(result.selectedIds);
      for (const conversation of extractionResult.conversations) {
        if (selectedIdsSet.has(conversation.id) && conversation.sourceFile) {
          const fileConversations = conversationsByFile.get(conversation.sourceFile) || [];
          fileConversations.push(conversation.id);
          conversationsByFile.set(conversation.sourceFile, fileConversations);
        }
      }
    } catch (error) {
      this.logger.error("Error grouping conversations by file:", error);
      conversationsByFile.set(files[0].name, result.selectedIds);
    }
    return conversationsByFile;
  }
  /**
   * Sort files by timestamp (same logic as ImportService)
   */
  sortFilesByTimestamp(files) {
    return files.sort((a, b) => {
      const timestampRegex = /(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2})/;
      const getTimestamp = /* @__PURE__ */ __name((filename) => {
        const match = filename.match(timestampRegex);
        if (!match) {
          this.logger.warn(`No timestamp found in filename: ${filename}`);
          return "0";
        }
        return match[1];
      }, "getTimestamp");
      return getTimestamp(a.name).localeCompare(getTimestamp(b.name));
    });
  }
};
__name(NexusAiChatImporterPlugin, "NexusAiChatImporterPlugin");
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/

/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof require && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// src/logger.ts
var LogLevel, Logger;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    LogLevel = /* @__PURE__ */ ((LogLevel2) => {
      LogLevel2[LogLevel2["INFO"] = 0] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 1] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 2] = "ERROR";
      return LogLevel2;
    })(LogLevel || {});
    Logger = class {
      logToConsole(level, message, details) {
        console.log(`[Nexus AI Chat Importer] [${LogLevel[level]}] ${message}`);
      }
      info(message, details) {
        console.log(`[Nexus AI Chat Importer] [INFO] ${message}`);
      }
      warn(message, details) {
        console.warn(`[Nexus AI Chat Importer] [WARN] ${message}`);
      }
      error(message, details) {
        console.error(`[Nexus AI Chat Importer] [ERROR] ${message}`);
      }
    };
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  addPrefix: () => addPrefix,
  checkConversationLink: () => checkConversationLink,
  createDatePrefix: () => createDatePrefix,
  doesFilePathExist: () => doesFilePathExist,
  ensureFolderExists: () => ensureFolderExists,
  formatTimestamp: () => formatTimestamp,
  formatTitle: () => formatTitle,
  generateConversationFileName: () => generateConversationFileName,
  generateFileName: () => generateFileName,
  generateUniqueFileName: () => generateUniqueFileName,
  generateYearMonthFolder: () => generateYearMonthFolder,
  getFileHash: () => getFileHash,
  isCustomError: () => isCustomError,
  isNexusRelated: () => isNexusRelated,
  isValidMessage: () => isValidMessage,
  old_getConversationId: () => old_getConversationId
});
function formatTimestamp(unixTime, format) {
  const date = (0, import_obsidian7.moment)(unixTime * 1e3);
  switch (format) {
    case "prefix":
      return date.format("YYYYMMDD");
    case "date":
      return date.format("L");
    case "time":
      return date.format("LT");
  }
}
function generateYearMonthFolder(unixTime) {
  const date = new Date(unixTime * 1e3);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  return `${year}/${month}`;
}
function formatTitle(title) {
  return title.trim() || "Untitled";
}
function generateFileName(title) {
  let fileName = formatTitle(title).normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[<>:"\/\\|?*\n\r]+/g, "").replace(/\.{2,}/g, ".").trim();
  fileName = fileName.replace(/^[^\w\d\s]+/, "");
  fileName = fileName.replace(/\s+/g, " ").trim();
  if (!fileName || fileName.length === 0) {
    fileName = "Untitled";
  }
  if (fileName.startsWith(".")) {
    fileName = fileName.substring(1);
  }
  if (!fileName || fileName.length === 0) {
    fileName = "Untitled";
  }
  return fileName;
}
function addPrefix(filename, timeStamp, dateFormat) {
  const timeStampStr = formatTimestamp(timeStamp, dateFormat);
  if (timeStampStr) {
    filename = `${timeStampStr} - ${filename}`;
  }
  return filename;
}
function createDatePrefix(timeStamp, dateFormat) {
  const date = new Date(timeStamp * 1e3);
  let prefix = "";
  if (dateFormat === "YYYY-MM-DD") {
    prefix = date.toISOString().split("T")[0];
  } else if (dateFormat === "YYYYMMDD") {
    prefix = date.toISOString().split("T")[0].replace(/-/g, "");
  }
  return prefix;
}
async function generateUniqueFileName(filePath, vaultAdapter) {
  let uniqueFileName = filePath;
  const baseName = filePath.replace(/\.md$/, "");
  let counter = 1;
  while (await vaultAdapter.exists(uniqueFileName)) {
    uniqueFileName = `${baseName} (${counter++}).md`;
  }
  return uniqueFileName;
}
async function doesFilePathExist(filePath, vault) {
  const file = vault.getAbstractFileByPath(filePath);
  return file !== null;
}
async function getFileHash(file) {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function generateConversationFileName(chatTitle, createTime, addDatePrefix, dateFormat) {
  const date = new Date(createTime * 1e3);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  let fileName = generateFileName(chatTitle);
  if (addDatePrefix) {
    const day = String(date.getDate()).padStart(2, "0");
    let prefix = "";
    if (dateFormat === "YYYY-MM-DD") {
      prefix = `${year}-${month}-${day}`;
    } else if (dateFormat === "YYYYMMDD") {
      prefix = `${year}${month}${day}`;
    }
    fileName = `${prefix} - ${fileName}`;
  }
  return fileName;
}
function isValidMessage(message) {
  return message && typeof message === "object" && message.content && typeof message.content === "object" && Array.isArray(message.content.parts) && message.content.parts.length > 0 && message.content.parts.some(
    (part) => {
      if (typeof part === "string" && part.trim() !== "") {
        return true;
      }
      if (typeof part === "object" && part !== null) {
        if (part.content_type === "audio_transcription" && part.text && part.text.trim() !== "") {
          return true;
        }
        if (part.content_type === "text" && part.text && part.text.trim() !== "") {
          return true;
        }
        if (part.content_type === "multimodal_text" && part.text && part.text.trim() !== "") {
          return true;
        }
      }
      return false;
    }
  );
}
function isCustomError(error) {
  return error && typeof error.message === "string";
}
async function ensureFolderExists(folderPath, vault) {
  const folders = folderPath.split("/").filter((p) => p.length);
  let currentPath = "";
  for (const folder of folders) {
    currentPath += folder + "/";
    const currentFolder = vault.getAbstractFileByPath(currentPath);
    if (!currentFolder) {
      try {
        await vault.createFolder(currentPath);
      } catch (error) {
        if (error.message !== "Folder already exists.") {
          logger.error(
            `Failed to create folder: ${currentPath}`,
            error.message
          );
          return {
            success: false,
            error: `Failed to create folder: ${currentPath}. Reason: ${error.message}`
          };
        }
      }
    }
  }
  return { success: true };
}
async function checkConversationLink(conversationId, provider = "chatgpt") {
  let url;
  switch (provider) {
    case "chatgpt":
      url = `https://chatgpt.com/c/${conversationId}`;
      break;
    case "claude":
      url = `https://claude.ai/chat/${conversationId}`;
      break;
    default:
      logger.error(`Unknown provider for link checking: ${provider}`);
      return false;
  }
  try {
    const response = await (0, import_obsidian8.requestUrl)({
      url,
      method: "HEAD"
    });
    return response.status >= 200 && response.status < 300;
  } catch (error) {
    logger.error(`Error fetching ${url}:`, error);
    return false;
  }
}
function old_getConversationId(app) {
  var _a;
  const activeFile = app.workspace.getActiveFile();
  if (activeFile) {
    const frontmatter = (_a = app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    return frontmatter == null ? void 0 : frontmatter.conversation_id;
  }
  return void 0;
}
function isNexusRelated(file, app) {
  var _a;
  const frontmatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
  return (frontmatter == null ? void 0 : frontmatter.nexus) === "nexus-ai-chat-importer";
}
var import_obsidian7, import_obsidian8, logger;
var init_utils = __esm({
  "src/utils.ts"() {
    "use strict";
    import_obsidian7 = require("obsidian");
    init_logger();
    import_obsidian8 = require("obsidian");
    logger = new Logger();
  }
});

// src/dialogs.ts
function displayModal(app, title, paragraphs, note) {
  const modal = new import_obsidian9.Modal(app);
  modal.contentEl.addClass("nexus-ai-chat-importer-modal");
  const titleEl = modal.contentEl.createEl("h2", {
    text: title,
    cls: "modal-title"
  });
  const contentContainer = modal.contentEl.createDiv({ cls: "modal-content" });
  paragraphs.forEach((paragraph, paragraphIndex) => {
    const paragraphWithSpacing = paragraph + "\n\n";
    const paragraphDiv = contentContainer.createDiv({ cls: "modal-paragraph" });
    const sections = paragraphWithSpacing.split("\n\n").filter((section) => section.trim() !== "");
    sections.forEach((section, sectionIndex) => {
      const sectionDiv = paragraphDiv.createDiv({ cls: "modal-section" });
      const lines = section.split("\n").filter((line) => line.trim() !== "");
      lines.forEach((line) => {
        const lineDiv = sectionDiv.createDiv({ cls: "modal-line" });
        let htmlContent = line.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="external-link" target="_blank">$1</a>').replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>").replace(/\*([^*]+)\*/g, "<em>$1</em>");
        if (line.trim().endsWith(":") && line.trim().length < 30) {
          lineDiv.innerHTML = `<strong class="section-header">${htmlContent}</strong>`;
        } else if (line.trim().startsWith("\u2022") || line.trim().startsWith("-")) {
          lineDiv.innerHTML = htmlContent;
          lineDiv.addClass("modal-list-item");
        } else {
          lineDiv.innerHTML = htmlContent;
        }
      });
      if (sectionIndex < sections.length - 1) {
        paragraphDiv.createDiv({ cls: "modal-section-break" });
      }
    });
  });
  if (note) {
    contentContainer.createDiv({ cls: "modal-major-break" });
    const noteDiv = contentContainer.createDiv({ cls: "modal-note" });
    let noteContent = note.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="external-link" target="_blank">$1</a>').replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>").replace(/\*([^*]+)\*/g, "<em>$1</em>");
    noteDiv.innerHTML = noteContent;
  }
  return modal;
}
function addButtons(modal, type, resolve, customLabels) {
  const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
  if (type === "information") {
    const buttonLabel = (customLabels == null ? void 0 : customLabels.button1) || "Understood";
    const button = buttonContainer.createEl("button", {
      text: buttonLabel,
      cls: "mod-cta"
      // Obsidian's primary button class
    });
    button.addEventListener("click", () => {
      modal.close();
      resolve(true);
    });
  } else {
    const noLabel = (customLabels == null ? void 0 : customLabels.button2) || "No";
    const yesLabel = (customLabels == null ? void 0 : customLabels.button1) || "Yes";
    const noButton = buttonContainer.createEl("button", {
      text: noLabel,
      cls: "mod-muted"
      // Obsidian's secondary button class
    });
    noButton.addEventListener("click", () => {
      modal.close();
      resolve(false);
    });
    const yesButton = buttonContainer.createEl("button", {
      text: yesLabel,
      cls: "mod-cta"
      // Obsidian's primary button class
    });
    yesButton.addEventListener("click", () => {
      modal.close();
      resolve(true);
    });
  }
}
async function showDialog(app, type, title, paragraphs, note, customLabels) {
  return new Promise((resolve) => {
    const modal = displayModal(app, title, paragraphs, note);
    addButtons(modal, type, resolve, customLabels);
    modal.open();
  });
}
var import_obsidian9;
var init_dialogs = __esm({
  "src/dialogs.ts"() {
    "use strict";
    import_obsidian9 = require("obsidian");
  }
});

// src/upgrade/utils/version-utils.ts
var VersionUtils;
var init_version_utils = __esm({
  "src/upgrade/utils/version-utils.ts"() {
    "use strict";
    VersionUtils = class {
      /**
       * Parse version string into components
       */
      static parseVersion(version) {
        const parts = version.split(".").map(Number);
        return {
          major: parts[0] || 0,
          minor: parts[1] || 0,
          patch: parts[2] || 0,
          original: version
        };
      }
      /**
       * Compare two versions
       * Returns: -1 (v1 < v2), 0 (v1 = v2), 1 (v1 > v2)
       */
      static compareVersions(version1, version2) {
        const v1 = this.parseVersion(version1);
        const v2 = this.parseVersion(version2);
        if (v1.major !== v2.major)
          return v1.major - v2.major;
        if (v1.minor !== v2.minor)
          return v1.minor - v2.minor;
        return v1.patch - v2.patch;
      }
      /**
       * Check if version is in range [min, max]
       */
      static isInRange(version, minVersion, maxVersion) {
        const isAboveMin = this.compareVersions(version, minVersion) >= 0;
        if (!maxVersion)
          return isAboveMin;
        const isBelowMax = this.compareVersions(version, maxVersion) <= 0;
        return isAboveMin && isBelowMax;
      }
      /**
       * Check if migration should run based on version range
       */
      static shouldRunMigration(fromVersion, toVersion, migrationFromVersion, migrationToVersion) {
        const userFrom = this.parseVersion(fromVersion);
        const userTo = this.parseVersion(toVersion);
        const migrationFrom = this.parseVersion(migrationFromVersion);
        const migrationTo = migrationToVersion ? this.parseVersion(migrationToVersion) : userTo;
        const wasInRange = this.compareVersions(fromVersion, migrationFromVersion) >= 0;
        const isUpgradingTo = this.compareVersions(toVersion, migrationTo.original) >= 0;
        return wasInRange && isUpgradingTo;
      }
      /**
       * Get all versions between two versions (for sequential migrations)
       */
      static getVersionsInRange(fromVersion, toVersion, availableVersions) {
        return availableVersions.filter(
          (v) => this.compareVersions(v, fromVersion) > 0 && this.compareVersions(v, toVersion) <= 0
        ).sort((a, b) => this.compareVersions(a, b));
      }
      /**
       * Format version for display
       */
      static formatVersion(version) {
        const parsed = this.parseVersion(version);
        return `v${parsed.major}.${parsed.minor}.${parsed.patch}`;
      }
    };
  }
});

// src/upgrade/upgrade-interface.ts
var logger2, UpgradeOperation, VersionUpgrade;
var init_upgrade_interface = __esm({
  "src/upgrade/upgrade-interface.ts"() {
    "use strict";
    init_version_utils();
    init_dialogs();
    init_logger();
    logger2 = new Logger();
    UpgradeOperation = class {
      /**
       * Check if operation can run (prerequisites)
       */
      async canRun(context) {
        return true;
      }
      /**
       * Verify operation completed successfully
       */
      async verify(context) {
        return true;
      }
    };
    VersionUpgrade = class {
      /**
       * Check if this upgrade should run for the version range
       */
      shouldRun(fromVersion, toVersion) {
        return VersionUtils.compareVersions(toVersion, this.version) >= 0 && VersionUtils.compareVersions(fromVersion, this.version) < 0;
      }
      /**
       * Execute all automatic operations
       */
      async executeAutomaticOperations(context) {
        const results = [];
        let allSuccess = true;
        for (const operation of this.automaticOperations) {
          try {
            if (await this.isOperationCompleted(operation.id, context)) {
              results.push({
                operationId: operation.id,
                result: { success: true, message: "Already completed" }
              });
              continue;
            }
            if (!await operation.canRun(context)) {
              results.push({
                operationId: operation.id,
                result: { success: false, message: "Prerequisites not met" }
              });
              allSuccess = false;
              continue;
            }
            const result = await operation.execute(context);
            results.push({ operationId: operation.id, result });
            if (result.success) {
              await this.markOperationCompleted(operation.id, context);
            } else {
              allSuccess = false;
            }
          } catch (error) {
            const errorResult = {
              success: false,
              message: `Operation failed: ${error}`,
              details: { error: String(error) }
            };
            results.push({ operationId: operation.id, result: errorResult });
            allSuccess = false;
          }
        }
        return { success: allSuccess, results };
      }
      /**
       * Show manual operations dialog and execute selected ones
       */
      async showManualOperationsDialog(context) {
        const availableOperations = [];
        for (const operation of this.manualOperations) {
          if (!await this.isOperationCompleted(operation.id, context) && await operation.canRun(context)) {
            availableOperations.push(operation);
          }
        }
        if (availableOperations.length === 0) {
          return { success: true, results: [] };
        }
        const paragraphs = [
          `**Version ${this.version} Manual Operations**`,
          "The following optional operations are available:",
          "",
          ...availableOperations.map((op) => `\u2022 **${op.name}**: ${op.description}`)
        ];
        const shouldExecute = await showDialog(
          context.plugin.app,
          "confirmation",
          `Optional Operations - v${this.version}`,
          paragraphs,
          "These operations are optional and can be run later from Settings \u2192 Migrations",
          { button1: "Run All Now", button2: "Skip (Run Later)" }
        );
        const results = [];
        if (shouldExecute) {
          for (const operation of availableOperations) {
            try {
              const result = await operation.execute(context);
              results.push({ operationId: operation.id, result });
              if (result.success) {
                await this.markOperationCompleted(operation.id, context);
              }
            } catch (error) {
              const errorResult = {
                success: false,
                message: `Operation failed: ${error}`,
                details: { error: String(error) }
              };
              results.push({ operationId: operation.id, result: errorResult });
            }
          }
        }
        return {
          success: results.every((r) => r.result.success),
          results
        };
      }
      /**
       * Get manual operations status for settings UI
       */
      async getManualOperationsStatus(context) {
        const status = [];
        for (const operation of this.manualOperations) {
          const completed = await this.isOperationCompleted(operation.id, context);
          const canRun = !completed && await operation.canRun(context);
          status.push({
            operation,
            completed,
            canRun
          });
        }
        return status;
      }
      /**
       * Execute single manual operation (from settings)
       */
      async executeManualOperation(operationId, context) {
        const operation = this.manualOperations.find((op) => op.id === operationId);
        if (!operation) {
          return { success: false, message: "Operation not found" };
        }
        if (await this.isOperationCompleted(operation.id, context)) {
          return { success: true, message: "Already completed" };
        }
        if (!await operation.canRun(context)) {
          return { success: false, message: "Prerequisites not met" };
        }
        try {
          const result = await operation.execute(context);
          if (result.success) {
            await this.markOperationCompleted(operation.id, context);
          }
          return result;
        } catch (error) {
          return {
            success: false,
            message: `Operation failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if operation was completed using structured upgrade history
       */
      async isOperationCompleted(operationId, context) {
        var _a, _b, _c;
        const data = await context.plugin.loadData();
        const operationKey = `operation_${this.version.replace(/\./g, "_")}_${operationId}`;
        return ((_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedOperations) == null ? void 0 : _b[operationKey]) == null ? void 0 : _c.completed) || false;
      }
      /**
       * Mark operation as completed using structured upgrade history
       */
      async markOperationCompleted(operationId, context) {
        const data = await context.plugin.loadData() || {};
        if (!data.upgradeHistory) {
          data.upgradeHistory = {
            completedUpgrades: {},
            completedOperations: {}
          };
        }
        const operationKey = `operation_${this.version.replace(/\./g, "_")}_${operationId}`;
        data.upgradeHistory.completedOperations[operationKey] = {
          operationId,
          version: this.version,
          date: new Date().toISOString(),
          completed: true
        };
        await context.plugin.saveData(data);
        logger2.info(`Marked operation ${operationId} (v${this.version}) as completed`);
      }
    };
  }
});

// src/upgrade/versions/upgrade-1.1.0.ts
var upgrade_1_1_0_exports = {};
__export(upgrade_1_1_0_exports, {
  Upgrade110: () => Upgrade110
});
var DeleteCatalogOperation, CleanMetadataOperation, Upgrade110;
var init_upgrade_1_1_0 = __esm({
  "src/upgrade/versions/upgrade-1.1.0.ts"() {
    "use strict";
    init_upgrade_interface();
    DeleteCatalogOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "delete-catalog";
        this.name = "Delete Old Catalog";
        this.description = "Remove legacy conversation catalog data";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const data = await context.plugin.loadData();
          const catalog = data == null ? void 0 : data.conversationCatalog;
          const hasData = catalog && typeof catalog === "object" && Object.keys(catalog).length > 0;
          console.debug(`[NEXUS-DEBUG] DeleteCatalog.canRun: catalog exists=${!!catalog}, hasData=${hasData}`);
          if (catalog) {
            console.debug(`[NEXUS-DEBUG] DeleteCatalog.canRun: catalog size=${Object.keys(catalog).length}`);
          }
          return hasData;
        } catch (error) {
          console.error(`[NEXUS-DEBUG] DeleteCatalog.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          console.debug(`[NEXUS-DEBUG] DeleteCatalog.execute starting`);
          const data = await context.plugin.loadData();
          const catalog = (data == null ? void 0 : data.conversationCatalog) || {};
          const catalogSize = Object.keys(catalog).length;
          if (catalogSize === 0) {
            console.debug(`[NEXUS-DEBUG] DeleteCatalog: No catalog to delete`);
            return {
              success: true,
              message: "No legacy catalog found to delete"
            };
          }
          const existingImportedArchives = data == null ? void 0 : data.importedArchives;
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: Preserving importedArchives:`, existingImportedArchives);
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: importedArchives type:`, typeof existingImportedArchives);
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: importedArchives keys:`, existingImportedArchives ? Object.keys(existingImportedArchives).length : 0);
          const cleanedData = {
            settings: data.settings || context.plugin.settings,
            // CRITICAL FIX: Force preservation of importedArchives
            importedArchives: existingImportedArchives || {},
            upgradeHistory: data.upgradeHistory || {
              completedUpgrades: {},
              completedOperations: {}
            },
            // Remove conversationCatalog - key change
            catalogDeletionDate: new Date().toISOString(),
            catalogDeletionStats: { entriesDeleted: catalogSize }
          };
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: cleanedData.importedArchives keys:`, Object.keys(cleanedData.importedArchives).length);
          await context.plugin.saveData(cleanedData);
          const verifyData = await context.plugin.loadData();
          const verifyArchives = (verifyData == null ? void 0 : verifyData.importedArchives) || {};
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: After save, importedArchives keys:`, Object.keys(verifyArchives).length);
          if (Object.keys(verifyArchives).length === 0 && Object.keys(existingImportedArchives || {}).length > 0) {
            console.error(`[NEXUS-DEBUG] DeleteCatalog: CRITICAL - importedArchives were lost during save!`);
            return {
              success: false,
              message: `Critical error: importedArchives were lost during migration`,
              details: {
                beforeCount: Object.keys(existingImportedArchives || {}).length,
                afterCount: Object.keys(verifyArchives).length
              }
            };
          }
          console.debug(`[NEXUS-DEBUG] DeleteCatalog: Successfully deleted ${catalogSize} entries and preserved ${Object.keys(verifyArchives).length} imported archives`);
          return {
            success: true,
            message: `Legacy catalog deleted: ${catalogSize} entries removed, ${Object.keys(verifyArchives).length} imported archives preserved`,
            details: { entriesDeleted: catalogSize, archivesPreserved: Object.keys(verifyArchives).length }
          };
        } catch (error) {
          console.error(`[NEXUS-DEBUG] DeleteCatalog.execute failed:`, error);
          return {
            success: false,
            message: `Failed to delete legacy catalog: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        try {
          const data = await context.plugin.loadData();
          const hasNoCatalog = !(data == null ? void 0 : data.conversationCatalog);
          const hasImportedArchives = (data == null ? void 0 : data.importedArchives) && Object.keys(data.importedArchives).length > 0;
          console.debug(`[NEXUS-DEBUG] DeleteCatalog.verify: hasNoCatalog=${hasNoCatalog}, hasImportedArchives=${hasImportedArchives}`);
          return hasNoCatalog;
        } catch (error) {
          console.error(`[NEXUS-DEBUG] DeleteCatalog.verify failed:`, error);
          return false;
        }
      }
    };
    CleanMetadataOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "clean-metadata";
        this.name = "Clean & Version Metadata";
        this.description = "Remove unnecessary metadata and add plugin version to conversation notes";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          const canRun = conversationFiles.length > 0;
          console.debug(`[NEXUS-DEBUG] CleanMetadata.canRun: found ${conversationFiles.length} conversation files, canRun=${canRun}`);
          return canRun;
        } catch (error) {
          console.error(`[NEXUS-DEBUG] CleanMetadata.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          console.debug(`[NEXUS-DEBUG] CleanMetadata.execute starting`);
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          if (conversationFiles.length === 0) {
            console.debug(`[NEXUS-DEBUG] CleanMetadata: No conversation files to clean`);
            return {
              success: true,
              message: "No conversation files found to clean",
              details: { processed: 0, cleaned: 0, errors: 0 }
            };
          }
          console.debug(`[NEXUS-DEBUG] CleanMetadata: Processing ${conversationFiles.length} conversation files`);
          let processed = 0;
          let cleaned = 0;
          let errors = 0;
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                const cleanedContent = this.cleanFrontmatterRobust(content, context.toVersion, file.basename);
                if (content !== cleanedContent) {
                  await context.plugin.app.vault.modify(file, cleanedContent);
                  cleaned++;
                }
              } catch (error) {
                errors++;
                console.error(`[NEXUS-DEBUG] Error cleaning metadata for ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          console.debug(`[NEXUS-DEBUG] CleanMetadata: Completed - processed:${processed}, cleaned:${cleaned}, errors:${errors}`);
          return {
            success: errors === 0,
            message: `Metadata cleanup completed: ${cleaned} files cleaned, ${errors} errors`,
            details: { processed, cleaned, errors }
          };
        } catch (error) {
          console.error(`[NEXUS-DEBUG] CleanMetadata.execute failed:`, error);
          return {
            success: false,
            message: `Metadata cleanup failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Clean frontmatter with robust parsing and safe alias generation
       */
      cleanFrontmatterRobust(content, pluginVersion, fileName) {
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontmatterMatch) {
          if (content.includes("nexus:") || content.includes("conversation_id:")) {
            console.warn(`[NEXUS-DEBUG] File ${fileName} appears to be Nexus but has malformed frontmatter`);
          }
          return content;
        }
        const frontmatterContent = frontmatterMatch[1];
        const restOfContent = content.substring(frontmatterMatch[0].length);
        const frontmatterData = {};
        const lines = frontmatterContent.split("\n");
        for (const line of lines) {
          const colonIndex = line.indexOf(":");
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            let value = line.substring(colonIndex + 1).trim();
            if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
              value = value.slice(1, -1);
            }
            frontmatterData[key] = value;
          }
        }
        const nexusId = "nexus-ai-chat-importer";
        if (frontmatterData.nexus !== nexusId) {
          return content;
        }
        const safeAlias = this.generateSafeAlias(fileName);
        const newFrontmatter = [];
        newFrontmatter.push(`nexus: ${nexusId}`);
        newFrontmatter.push(`plugin_version: "1.0.x"`);
        if (frontmatterData.provider) {
          newFrontmatter.push(`provider: ${frontmatterData.provider}`);
        }
        newFrontmatter.push(`aliases: "${safeAlias}"`);
        if (frontmatterData.conversation_id) {
          newFrontmatter.push(`conversation_id: ${frontmatterData.conversation_id}`);
        }
        if (frontmatterData.create_time) {
          newFrontmatter.push(`create_time: ${frontmatterData.create_time}`);
        }
        if (frontmatterData.update_time) {
          newFrontmatter.push(`update_time: ${frontmatterData.update_time}`);
        }
        const cleanedFrontmatter = newFrontmatter.join("\n");
        return `---
${cleanedFrontmatter}
---${restOfContent}`;
      }
      /**
       * Generate safe alias from filename (reuse the robust filename logic)
       */
      generateSafeAlias(fileName) {
        let cleanName = fileName.replace(/^\d{8}\s*-\s*/, "").replace(/^\d{4}-\d{2}-\d{2}\s*-\s*/, "");
        cleanName = cleanName.replace(/\.md$/, "");
        cleanName = cleanName.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[<>:"\/\\|?*\n\r]+/g, "").replace(/\.{2,}/g, ".").trim();
        cleanName = cleanName.replace(/^[^\w\d\s]+/, "");
        cleanName = cleanName.replace(/\s+/g, " ").trim();
        if (!cleanName || cleanName.length === 0) {
          cleanName = "Untitled";
        }
        if (cleanName.startsWith(".")) {
          cleanName = cleanName.substring(1);
        }
        if (!cleanName || cleanName.length === 0) {
          cleanName = "Untitled";
        }
        return cleanName;
      }
      async verify(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
              if (!frontmatterMatch)
                continue;
              const frontmatterContent = frontmatterMatch[1];
              if (!frontmatterContent.includes("plugin_version:")) {
                console.debug(`[NEXUS-DEBUG] CleanMetadata.verify: Missing plugin_version in ${file.path}`);
                return false;
              }
              const forbiddenFields = [
                "conversation_template_id:",
                "gizmo_id:",
                "gizmo_type:",
                "default_model_slug:",
                "is_archived:",
                "is_starred:",
                "current_node:",
                "memory_scope:"
              ];
              const hasUnwantedFields = forbiddenFields.some(
                (field) => frontmatterContent.includes(field)
              );
              if (hasUnwantedFields) {
                console.debug(`[NEXUS-DEBUG] CleanMetadata.verify: Found unwanted fields in ${file.path}`);
                return false;
              }
            } catch (error) {
              console.error(`[NEXUS-DEBUG] CleanMetadata.verify error for ${file.path}:`, error);
              return false;
            }
          }
          console.debug(`[NEXUS-DEBUG] CleanMetadata.verify: Passed verification`);
          return true;
        } catch (error) {
          console.error(`[NEXUS-DEBUG] CleanMetadata.verify failed:`, error);
          return false;
        }
      }
    };
    Upgrade110 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.1.0";
        this.automaticOperations = [
          new DeleteCatalogOperation(),
          new CleanMetadataOperation()
        ];
        this.manualOperations = [
          // No manual operations for 1.1.0 - all operations are automatic
          // Future versions can add manual operations here for truly optional tasks
        ];
      }
    };
  }
});

// src/upgrade/versions/upgrade-1.2.0.ts
var upgrade_1_2_0_exports = {};
__export(upgrade_1_2_0_exports, {
  NexusUpgradeModal: () => NexusUpgradeModal,
  Upgrade120: () => Upgrade120
});
var import_obsidian14, ConvertToCalloutsOperation, MoveYearFoldersOperation, FixReportLinksOperation, NexusUpgradeModal, OfferReimportOperation, Upgrade120;
var init_upgrade_1_2_0 = __esm({
  "src/upgrade/versions/upgrade-1.2.0.ts"() {
    "use strict";
    init_upgrade_interface();
    import_obsidian14 = require("obsidian");
    ConvertToCalloutsOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "convert-to-callouts";
        this.name = "Convert to Modern Callouts";
        this.description = "Transform old indentations (>, >>) to beautiful Nexus callouts";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          for (const file of conversationFiles.slice(0, 10)) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (this.hasOldIndentationFormat(content)) {
                return true;
              }
            } catch (error) {
              console.error(`Error checking file ${file.path}:`, error);
            }
          }
          return false;
        } catch (error) {
          console.error(`ConvertToCallouts.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          console.debug(`[NEXUS-DEBUG] ConvertToCallouts.execute starting`);
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          });
          let processed = 0;
          let converted = 0;
          let errors = 0;
          console.debug(`[NEXUS-DEBUG] ConvertToCallouts: Processing ${conversationFiles.length} files`);
          const batchSize = 10;
          for (let i = 0; i < conversationFiles.length; i += batchSize) {
            const batch = conversationFiles.slice(i, i + batchSize);
            for (const file of batch) {
              processed++;
              try {
                const content = await context.plugin.app.vault.read(file);
                if (!this.hasOldIndentationFormat(content)) {
                  continue;
                }
                const convertedContent = this.convertIndentationsToCallouts(content);
                if (content !== convertedContent) {
                  const finalContent = this.updatePluginVersion(convertedContent, "1.2.0");
                  await context.plugin.app.vault.modify(file, finalContent);
                  converted++;
                }
              } catch (error) {
                errors++;
                console.error(`[NEXUS-DEBUG] Error converting ${file.path}:`, error);
              }
            }
            if (i + batchSize < conversationFiles.length) {
              await new Promise((resolve) => setTimeout(resolve, 10));
            }
          }
          console.debug(`[NEXUS-DEBUG] ConvertToCallouts: Completed - processed:${processed}, converted:${converted}, errors:${errors}`);
          return {
            success: errors === 0,
            message: `Callout conversion completed: ${converted} files converted, ${errors} errors`,
            details: { processed, converted, errors }
          };
        } catch (error) {
          console.error(`[NEXUS-DEBUG] ConvertToCallouts.execute failed:`, error);
          return {
            success: false,
            message: `Callout conversion failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      /**
       * Check if content has old indentation format (v1.1.0)
       */
      hasOldIndentationFormat(content) {
        const oldPatterns = [
          /^### User, on .* at .*;\n>/m,
          // User messages with indentation
          /^#### Assistant, on .* at .*;\n>>/m,
          // Assistant messages with indentation
          /<div class="nexus-attachment-box">/,
          // Old attachment divs
          /<div class="nexus-artifact-box">/,
          // Old artifact divs
          />\[!note\] 📎 \*\*Attachment:\*\*/
          // Old note callouts for attachments
        ];
        return oldPatterns.some((pattern) => pattern.test(content));
      }
      /**
       * Convert old indentations to modern callouts
       */
      convertIndentationsToCallouts(content) {
        let converted = content;
        converted = converted.replace(
          /^### User, on (.*?) at (.*?);\n((?:> .*(?:\n|$))*)/gm,
          (match, date, time, quotedContent) => {
            const cleanContent = quotedContent.replace(/^> /gm, "> ");
            return `>[!nexus_user] **User** - ${date} at ${time}
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /^#### Assistant, on (.*?) at (.*?);\n((?:>> .*(?:\n|$))*)/gm,
          (match, date, time, quotedContent) => {
            const cleanContent = quotedContent.replace(/^>> /gm, "> ");
            return `>[!nexus_agent] **Assistant** - ${date} at ${time}
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /<div class="nexus-attachment-box">\s*\n\s*\*\*📎 Attachment:\*\* ([^(]+)\(([^)]+)\)([\s\S]*?)<\/div>/g,
          (match, fileName, fileType, content2) => {
            const cleanFileName = fileName.trim();
            let cleanContent = content2.trim();
            if (cleanContent.includes("**Content:**")) {
              cleanContent = cleanContent.replace(/\*\*Content:\*\*/g, "").trim();
            }
            if (cleanContent.includes("**Status:**")) {
              cleanContent = cleanContent.replace(/\*\*Status:\*\*/g, "").trim();
            }
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_attachment] **${cleanFileName}** (${fileType})
${cleanContent}`;
          }
        );
        converted = converted.replace(
          /<div class="nexus-artifact-box">\s*([\s\S]*?)\s*<\/div>/g,
          (match, content2) => {
            let cleanContent = content2.trim();
            const titleMatch = cleanContent.match(/\*\*([^*]+)\*\*/);
            const title = titleMatch ? titleMatch[1] : "Artifact";
            cleanContent = cleanContent.replace(/\*\*[^*]+\*\*/g, "").trim();
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_artifact] **${title}**
${cleanContent}`;
          }
        );
        converted = converted.replace(
          />\[!note\] 📎 \*\*Attachment:\*\* ([^(]+)\(([^)]+)\)(.*?)(?=\n\n|\n>|\n<!--|\n---|$)/gs,
          (match, fileName, fileType, content2) => {
            const cleanFileName = fileName.trim();
            let cleanContent = content2.trim();
            cleanContent = cleanContent.replace(/\n/g, "\n> ").trim();
            if (cleanContent && !cleanContent.startsWith(">")) {
              cleanContent = "> " + cleanContent;
            }
            return `>[!nexus_attachment] **${cleanFileName}** (${fileType})
${cleanContent}`;
          }
        );
        return converted;
      }
      /**
       * Update plugin_version in frontmatter
       */
      updatePluginVersion(content, version) {
        return content.replace(
          /^plugin_version: ".*?"$/m,
          `plugin_version: "${version}"`
        );
      }
      async verify(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const allFiles = context.plugin.app.vault.getMarkdownFiles();
          const conversationFiles = allFiles.filter((file) => {
            if (!file.path.startsWith(archiveFolder))
              return false;
            const relativePath = file.path.substring(archiveFolder.length + 1);
            if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
              return false;
            }
            return true;
          }).slice(0, 5);
          for (const file of conversationFiles) {
            try {
              const content = await context.plugin.app.vault.read(file);
              if (this.hasOldIndentationFormat(content)) {
                console.debug(`[NEXUS-DEBUG] ConvertToCallouts.verify: Still has old format in ${file.path}`);
                return false;
              }
              if (!content.includes('plugin_version: "1.2.0"')) {
                console.debug(`[NEXUS-DEBUG] ConvertToCallouts.verify: Missing v1.2.0 in ${file.path}`);
                return false;
              }
            } catch (error) {
              console.error(`Error verifying file ${file.path}:`, error);
              return false;
            }
          }
          return true;
        } catch (error) {
          console.error(`ConvertToCallouts.verify failed:`, error);
          return false;
        }
      }
    };
    MoveYearFoldersOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "move-year-folders";
        this.name = "Organize Conversations by Provider";
        this.description = "Move year folders to chatgpt provider structure";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const yearFolders = await this.findYearFolders(context, archiveFolder);
          return yearFolders.length > 0;
        } catch (error) {
          console.error(`MoveYearFolders.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          console.debug(`[NEXUS-DEBUG] MoveYearFolders.execute starting`);
          const archiveFolder = context.plugin.settings.archiveFolder;
          let movedFolders = 0;
          let errors = 0;
          const yearFolders = await this.findYearFolders(context, archiveFolder);
          for (const yearFolder of yearFolders) {
            try {
              const chatgptFolder = `${archiveFolder}/chatgpt`;
              await context.plugin.app.vault.adapter.mkdir(chatgptFolder);
              const newPath = `${chatgptFolder}/${yearFolder}`;
              const oldPath = `${archiveFolder}/${yearFolder}`;
              await context.plugin.app.vault.adapter.rename(oldPath, newPath);
              movedFolders++;
              console.debug(`[NEXUS-DEBUG] Moved ${yearFolder} to chatgpt/${yearFolder}`);
            } catch (error) {
              errors++;
              console.error(`[NEXUS-DEBUG] Error moving year folder ${yearFolder}:`, error);
            }
          }
          console.debug(`[NEXUS-DEBUG] MoveYearFolders: Completed - moved:${movedFolders}, errors:${errors}`);
          return {
            success: errors === 0,
            message: `Conversation organization completed: ${movedFolders} year folders moved to chatgpt structure, ${errors} errors`,
            details: { movedFolders, errors }
          };
        } catch (error) {
          console.error(`[NEXUS-DEBUG] MoveYearFolders.execute failed:`, error);
          return {
            success: false,
            message: `Conversation organization failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        try {
          const archiveFolder = context.plugin.settings.archiveFolder;
          const remainingYearFolders = await this.findYearFolders(context, archiveFolder);
          if (remainingYearFolders.length > 0) {
            console.debug(`[NEXUS-DEBUG] MoveYearFolders.verify: Still ${remainingYearFolders.length} year folders in old structure`);
            return false;
          }
          return true;
        } catch (error) {
          console.error(`MoveYearFolders.verify failed:`, error);
          return false;
        }
      }
      /**
       * Find year folders (YYYY) directly in archive folder
       */
      async findYearFolders(context, archiveFolder) {
        try {
          const folders = await context.plugin.app.vault.adapter.list(archiveFolder);
          return folders.folders.filter((folder) => {
            const folderName = folder.split("/").pop() || "";
            return /^\d{4}$/.test(folderName) && folderName !== "chatgpt";
          }).map((folder) => folder.split("/").pop() || "");
        } catch (error) {
          return [];
        }
      }
    };
    FixReportLinksOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "fix-report-links";
        this.name = "Fix Report Links";
        this.description = "Update conversation links in reports after folder reorganization";
        this.type = "automatic";
      }
      async canRun(context) {
        try {
          console.debug(`[NEXUS-DEBUG] FixReportLinks.canRun: STARTING`);
          const reportFolder = context.plugin.settings.reportFolder;
          const reportFiles = context.plugin.app.vault.getMarkdownFiles().filter(
            (file) => file.path.startsWith(`${reportFolder}/chatgpt/`)
          );
          console.debug(`[NEXUS-DEBUG] FixReportLinks.canRun: Found ${reportFiles.length} report files`);
          return reportFiles.length > 0;
        } catch (error) {
          console.error(`[NEXUS-DEBUG] FixReportLinks.canRun failed:`, error);
          return false;
        }
      }
      async execute(context) {
        try {
          console.debug(`[NEXUS-DEBUG] FixReportLinks.execute starting`);
          const reportFolder = context.plugin.settings.reportFolder;
          let fixedFiles = 0;
          let errors = 0;
          const reportFiles = context.plugin.app.vault.getMarkdownFiles().filter(
            (file) => file.path.startsWith(`${reportFolder}/chatgpt/`)
          );
          console.debug(`[NEXUS-DEBUG] FixReportLinks: Processing ${reportFiles.length} report files`);
          for (const file of reportFiles) {
            try {
              console.debug(`[NEXUS-DEBUG] FixReportLinks: Processing ${file.path}`);
              const content = await context.plugin.app.vault.read(file);
              const yearPattern = /\/(\d{4})\//g;
              const updatedContent = content.replace(yearPattern, "/chatgpt/$1/");
              if (updatedContent !== content) {
                await context.plugin.app.vault.modify(file, updatedContent);
                fixedFiles++;
                console.debug(`[NEXUS-DEBUG] Fixed year paths in report: ${file.path}`);
              } else {
                console.debug(`[NEXUS-DEBUG] No year paths to fix in: ${file.path}`);
              }
            } catch (error) {
              errors++;
              console.error(`[NEXUS-DEBUG] Error fixing paths in report ${file.path}:`, error);
            }
          }
          console.debug(`[NEXUS-DEBUG] FixReportLinks: Completed - fixed:${fixedFiles}, errors:${errors}`);
          return {
            success: errors === 0,
            message: `Report link correction completed: ${fixedFiles} reports updated, ${errors} errors`,
            details: { fixedFiles, errors }
          };
        } catch (error) {
          console.error(`[NEXUS-DEBUG] FixReportLinks.execute failed:`, error);
          return {
            success: false,
            message: `Report link correction failed: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        try {
          console.debug(`[NEXUS-DEBUG] FixReportLinks.verify: Verification complete (always true for simple replacement)`);
          return true;
        } catch (error) {
          console.error(`FixReportLinks.verify failed:`, error);
          return false;
        }
      }
    };
    NexusUpgradeModal = class extends import_obsidian14.Modal {
      constructor(app, plugin, version, resolve) {
        super(app);
        this.plugin = plugin;
        this.version = version;
        this.resolve = resolve;
      }
      onOpen() {
        const { containerEl, contentEl, titleEl } = this;
        containerEl.classList.add("nexus-upgrade-modal");
        titleEl.setText(`\u{1F680} Nexus AI Chat Importer ${this.version}`);
        this.createForm();
      }
      async onClose() {
        this.contentEl.empty();
      }
      async createForm() {
        let message = `\u{1F389} **Upgrade to v1.2.0**

Your conversations will be reorganized with provider structure and modern callouts.

**\u{1F4A1} To get ALL v1.2.0 features:** Reimport your original ChatGPT ZIP files.

---

## \u2615 Support My Work

[![Support me on Ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/nexusplugins)`;
        try {
          const response = await fetch("https://api.github.com/repos/Superkikim/nexus-ai-chat-importer/releases/tags/v1.2.0");
          if (response.ok) {
            const release = await response.json();
            if (release.body) {
              message = release.body;
            }
          }
        } catch (error) {
          console.debug("[NEXUS-DEBUG] Could not fetch release notes from GitHub, using fallback");
        }
        await import_obsidian14.MarkdownRenderer.render(
          this.app,
          message,
          this.contentEl,
          "",
          this.plugin
        );
        this.contentEl.createEl("div", { cls: "nexus-upgrade-buttons" }, (el) => {
          el.style.textAlign = "right";
          el.style.marginTop = "20px";
          el.style.paddingTop = "15px";
          el.style.borderTop = "1px solid var(--background-modifier-border)";
          const btnOk = el.createEl("button", {
            text: "Proceed",
            cls: "nexus-btn-primary"
          });
          btnOk.onclick = () => {
            this.close();
            this.resolve("ok");
          };
        });
      }
    };
    OfferReimportOperation = class extends UpgradeOperation {
      constructor() {
        super(...arguments);
        this.id = "offer-reimport";
        this.name = "Full Feature Reimport";
        this.description = "Optionally reimport conversations to get all v1.2.0 features (attachments, chronological order, etc.)";
        this.type = "manual";
      }
      async canRun(context) {
        return true;
      }
      async execute(context) {
        try {
          return {
            success: true,
            message: "Upgrade information provided to user",
            details: { action: "info_displayed" }
          };
        } catch (error) {
          console.error(`OfferReimport.execute failed:`, error);
          return {
            success: false,
            message: `Failed to complete reimport operation: ${error}`,
            details: { error: String(error) }
          };
        }
      }
      async verify(context) {
        return true;
      }
    };
    Upgrade120 = class extends VersionUpgrade {
      constructor() {
        super(...arguments);
        this.version = "1.2.0";
        this.automaticOperations = [
          new MoveYearFoldersOperation(),
          new FixReportLinksOperation(),
          new ConvertToCalloutsOperation()
        ];
        this.manualOperations = [
          new OfferReimportOperation()
        ];
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NexusAiChatImporterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian17 = require("obsidian");

// src/config/constants.ts
var DEFAULT_SETTINGS = {
  archiveFolder: "Nexus/Conversations",
  addDatePrefix: false,
  dateFormat: "YYYY-MM-DD",
  hasShownUpgradeNotice: false,
  hasCompletedUpgrade: false,
  // Version tracking - will be set from manifest in main.ts
  currentVersion: "0.0.0",
  previousVersion: "0.0.0",
  // Attachment defaults with "best effort" approach
  importAttachments: true,
  attachmentFolder: "Nexus/Attachments",
  reportFolder: "Nexus/Reports",
  skipMissingAttachments: false,
  showAttachmentDetails: true
};
var GITHUB = {
  RAW_BASE: "https://raw.githubusercontent.com/Superkikim/nexus-ai-chat-importer",
  REPO_BASE: "https://github.com/Superkikim/nexus-ai-chat-importer"
};

// src/ui/settings-tab.ts
var import_obsidian4 = require("obsidian");

// src/ui/settings/conversation-settings-section.ts
var import_obsidian = require("obsidian");

// src/ui/settings/base-settings-section.ts
var BaseSettingsSection = class {
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Section order (lower = higher up)
     */
    this.order = 100;
  }
  /**
   * Set redraw callback from main settings tab
   */
  setRedrawCallback(callback) {
    this.redrawCallback = callback;
  }
  /**
   * Trigger redraw of entire settings tab
   */
  redraw() {
    if (this.redrawCallback) {
      this.redrawCallback();
    }
  }
};

// src/ui/settings/conversation-settings-section.ts
var ConversationSettingsSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.title = "Conversation Settings";
    this.order = 10;
  }
  render(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Conversations folder").setDesc("Choose a folder to store AI chat conversations and import reports").addText(
      (text) => text.setPlaceholder("Enter folder name").setValue(this.plugin.settings.archiveFolder).onChange(async (value) => {
        this.plugin.settings.archiveFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Add date prefix to filenames").setDesc("Add creation date as a prefix to conversation filenames").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.addDatePrefix).onChange(async (value) => {
        this.plugin.settings.addDatePrefix = value;
        await this.plugin.saveSettings();
        this.redraw();
      })
    );
    if (this.plugin.settings.addDatePrefix) {
      new import_obsidian.Setting(containerEl).setName("Date format").setDesc("Choose the format for the date prefix").addDropdown(
        (dropdown) => dropdown.addOption("YYYY-MM-DD", "YYYY-MM-DD").addOption("YYYYMMDD", "YYYYMMDD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
          if (value === "YYYY-MM-DD" || value === "YYYYMMDD") {
            this.plugin.settings.dateFormat = value;
            await this.plugin.saveSettings();
          }
        })
      );
    }
  }
};

// src/ui/settings/attachment-settings-section.ts
var import_obsidian2 = require("obsidian");
var AttachmentSettingsSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.title = "Attachment Settings";
    this.order = 20;
  }
  render(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Import attachments").setDesc("Save attachment files to disk and link them in conversations (uses 'best effort' strategy)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.importAttachments).onChange(async (value) => {
        this.plugin.settings.importAttachments = value;
        await this.plugin.saveSettings();
        this.redraw();
      })
    );
    if (this.plugin.settings.importAttachments) {
      this.renderAttachmentOptions(containerEl);
      this.renderAttachmentInfo(containerEl);
    }
  }
  renderAttachmentOptions(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Attachment folder").setDesc("Choose a folder to store attachment files").addText(
      (text) => text.setPlaceholder("Enter attachment folder path").setValue(this.plugin.settings.attachmentFolder).onChange(async (value) => {
        this.plugin.settings.attachmentFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Handle missing attachments").setDesc("When attachments are missing from exports, create informative notes instead of skipping them").addToggle(
      (toggle) => toggle.setValue(!this.plugin.settings.skipMissingAttachments).onChange(async (value) => {
        this.plugin.settings.skipMissingAttachments = !value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show attachment details in reports").setDesc("Include detailed attachment processing statistics in import reports").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showAttachmentDetails).onChange(async (value) => {
        this.plugin.settings.showAttachmentDetails = value;
        await this.plugin.saveSettings();
      })
    );
  }
  renderAttachmentInfo(containerEl) {
    const noteEl = containerEl.createDiv({ cls: "setting-item-description" });
    noteEl.style.marginTop = "15px";
    noteEl.style.padding = "15px";
    noteEl.style.backgroundColor = "var(--background-secondary)";
    noteEl.style.borderRadius = "8px";
    noteEl.style.border = "1px solid var(--background-modifier-border)";
    noteEl.createEl("h4", { text: "\u{1F4CE} About Attachment Handling", cls: "setting-item-name" });
    const infoList = noteEl.createEl("ul");
    infoList.style.marginTop = "10px";
    infoList.style.paddingLeft = "20px";
    infoList.createEl("li").innerHTML = "<strong>Best Effort Strategy:</strong> Files found in exports are extracted and linked; missing files get informative notes.";
    infoList.createEl("li").innerHTML = "<strong>Platform Differences:</strong> ChatGPT exports may not include all attachments, especially from older conversations.";
    infoList.createEl("li").innerHTML = "<strong>Simple Organization:</strong> Files organized as <code>attachments/provider/category/</code> (e.g., <code>attachments/chatgpt/images/</code>).";
    infoList.createEl("li").innerHTML = "<strong>Sync Tip:</strong> Consider excluding the attachment folder from sync to avoid uploading large files.";
    const tipEl = noteEl.createDiv();
    tipEl.style.marginTop = "10px";
    tipEl.style.fontStyle = "italic";
    tipEl.innerHTML = "\u{1F4A1} <strong>Tip:</strong> Enable 'Show attachment details' to see exactly which files were found, missing, or failed during import.";
  }
};

// src/ui/settings/migrations-settings-section.ts
var import_obsidian3 = require("obsidian");
var MigrationsSettingsSection = class extends BaseSettingsSection {
  constructor() {
    super(...arguments);
    this.title = "Migrations";
    this.order = 30;
  }
  async render(containerEl) {
    const migrationsDesc = containerEl.createDiv({ cls: "setting-item-description" });
    migrationsDesc.style.marginBottom = "20px";
    migrationsDesc.innerHTML = `
            <p><strong>Manual Operations:</strong> Optional upgrade operations that can be run when convenient.</p>
            <p>Automatic operations (like removing old data) run automatically during upgrade and are not shown here.</p>
        `;
    try {
      const upgradeManager = this.plugin.getUpgradeManager();
      if (!(upgradeManager == null ? void 0 : upgradeManager.getManualOperationsForSettings)) {
        this.showNoMigrationsMessage(containerEl);
        return;
      }
      const operationsData = await this.getOperationsWithPersistentStatus(upgradeManager);
      if (operationsData.length === 0) {
        this.showNoMigrationsMessage(containerEl);
        return;
      }
      for (const versionData of operationsData) {
        await this.renderVersionOperations(containerEl, versionData, upgradeManager);
      }
    } catch (error) {
      console.error("[NEXUS-DEBUG] Error loading migrations:", error);
      this.showErrorMessage(containerEl, error);
    }
  }
  /**
   * Get operations status with persistent flags from plugin data
   */
  async getOperationsWithPersistentStatus(upgradeManager) {
    var _a, _b, _c;
    const operationsData = await upgradeManager.getManualOperationsForSettings();
    const pluginData = await this.plugin.loadData();
    for (const versionData of operationsData) {
      for (const operation of versionData.operations) {
        const operationKey = `operation_${versionData.version.replace(/\./g, "_")}_${operation.id}`;
        const isCompleted = ((_c = (_b = (_a = pluginData == null ? void 0 : pluginData.upgradeHistory) == null ? void 0 : _a.completedOperations) == null ? void 0 : _b[operationKey]) == null ? void 0 : _c.completed) || false;
        operation.completed = isCompleted;
        operation.canRun = !isCompleted && operation.canRun;
      }
    }
    return operationsData;
  }
  async renderVersionOperations(containerEl, versionData, upgradeManager) {
    const versionHeader = containerEl.createEl("h3", {
      text: `Version ${versionData.version}`,
      cls: "migrations-version-header"
    });
    versionHeader.style.marginTop = "25px";
    versionHeader.style.marginBottom = "15px";
    versionHeader.style.color = "var(--text-accent)";
    for (const operation of versionData.operations) {
      await this.renderOperation(containerEl, operation, versionData.version, upgradeManager);
    }
  }
  async renderOperation(containerEl, operation, version, upgradeManager) {
    new import_obsidian3.Setting(containerEl).setName(operation.name).setDesc(operation.description + (operation.completed ? " \u2705 Completed" : "")).addButton((button) => {
      if (operation.completed) {
        button.setButtonText("\u2705 Completed").setDisabled(true).setTooltip("This operation has been completed");
        button.buttonEl.addClass("mod-muted");
      } else if (!operation.canRun) {
        button.setButtonText("Cannot Run").setDisabled(true).setTooltip("Prerequisites not met for this operation");
      } else {
        button.setButtonText("Run").setTooltip(`Execute ${operation.name}`).onClick(async () => {
          await this.executeOperation(button, operation, version, upgradeManager);
        });
        button.buttonEl.addClass("mod-cta");
      }
    });
  }
  async executeOperation(buttonEl, operation, version, upgradeManager) {
    const originalText = buttonEl.buttonEl.textContent;
    buttonEl.setButtonText("Running...").setDisabled(true);
    try {
      console.debug(`[NEXUS-DEBUG] Executing manual operation: ${operation.id} (v${version})`);
      const result = await upgradeManager.executeManualOperation(version, operation.id);
      console.debug(`[NEXUS-DEBUG] Operation result:`, result);
      if (result.success) {
        buttonEl.setButtonText("\u2705 Completed");
        buttonEl.setTooltip("This operation has been completed");
        const buttonElement = buttonEl.buttonEl || buttonEl;
        if (buttonElement && buttonElement.removeClass) {
          buttonElement.removeClass("mod-cta");
          buttonElement.addClass("mod-muted");
        }
        operation.completed = true;
        operation.canRun = false;
      } else {
        buttonEl.setButtonText(originalText).setDisabled(false);
        this.showOperationResult(
          buttonEl.buttonEl.closest(".setting-item"),
          result.message,
          "error"
        );
      }
    } catch (error) {
      console.error(`[NEXUS-DEBUG] Operation execution failed:`, error);
      buttonEl.setButtonText(originalText).setDisabled(false);
      this.showOperationResult(
        buttonEl.buttonEl.closest(".setting-item"),
        `Operation failed: ${error}`,
        "error"
      );
    }
  }
  showOperationResult(settingEl, message, type) {
    if (!settingEl)
      return;
    const existingMsg = settingEl.querySelector(".operation-result");
    if (existingMsg)
      existingMsg.remove();
    const resultEl = document.createElement("div");
    resultEl.className = "operation-result";
    resultEl.textContent = message;
    resultEl.style.cssText = `
            margin-top: 8px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            background: ${type === "success" ? "var(--background-modifier-success)" : "var(--background-modifier-error)"};
            color: ${type === "success" ? "var(--text-success)" : "var(--text-error)"};
            border: 1px solid ${type === "success" ? "var(--text-success)" : "var(--text-error)"};
        `;
    settingEl.appendChild(resultEl);
    setTimeout(() => {
      if (resultEl.parentNode) {
        resultEl.remove();
      }
    }, 5e3);
  }
  showNoMigrationsMessage(containerEl) {
    const noMigrationsEl = containerEl.createDiv({ cls: "setting-item-description" });
    noMigrationsEl.style.marginTop = "15px";
    noMigrationsEl.style.padding = "15px";
    noMigrationsEl.style.backgroundColor = "var(--background-secondary)";
    noMigrationsEl.style.borderRadius = "8px";
    noMigrationsEl.style.textAlign = "center";
    noMigrationsEl.innerHTML = `
            <p style="margin: 0; color: var(--text-muted);">
                <strong>No manual operations available</strong><br>
                All upgrade operations have been completed automatically.
            </p>
        `;
  }
  showErrorMessage(containerEl, error) {
    const errorEl = containerEl.createDiv({ cls: "setting-item-description" });
    errorEl.style.marginTop = "15px";
    errorEl.style.padding = "15px";
    errorEl.style.backgroundColor = "var(--background-modifier-error)";
    errorEl.style.color = "var(--text-error)";
    errorEl.style.borderRadius = "8px";
    errorEl.innerHTML = `
            <p style="margin: 0;">
                <strong>Error loading migrations:</strong><br>
                ${error.message || error}
            </p>
        `;
  }
};

// src/ui/settings-tab.ts
var NexusAiChatImporterPluginSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.sections = [];
    this.initializeSections();
  }
  initializeSections() {
    this.sections = [
      new ConversationSettingsSection(this.plugin),
      new AttachmentSettingsSection(this.plugin),
      new MigrationsSettingsSection(this.plugin)
    ].sort((a, b) => a.order - b.order);
    this.sections.forEach((section) => {
      section.setRedrawCallback(() => this.display());
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderSections(containerEl);
  }
  async renderSections(containerEl) {
    for (const section of this.sections) {
      if (section.title) {
        containerEl.createEl("h2", { text: section.title });
      }
      await section.render(containerEl);
    }
  }
};

// src/commands/command-registry.ts
var import_obsidian5 = require("obsidian");
var CommandRegistry = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "nexus-ai-chat-importer-select-zip",
      name: "Import AI conversations",
      callback: () => {
        this.plugin.showProviderSelectionDialog();
      }
    });
  }
  showResetConfirmation() {
    const modal = new import_obsidian5.Modal(this.plugin.app);
    modal.contentEl.createEl("p", {
      text: "This will reset all import catalogs. This action cannot be undone."
    });
    const buttonDiv = modal.contentEl.createEl("div", {
      cls: "modal-button-container"
    });
    buttonDiv.createEl("button", { text: "Cancel" }).addEventListener("click", () => modal.close());
    buttonDiv.createEl("button", { text: "Reset", cls: "mod-warning" }).addEventListener("click", () => {
      this.plugin.resetCatalogs();
      modal.close();
    });
    modal.open();
  }
};

// src/events/event-handlers.ts
var import_obsidian6 = require("obsidian");
var EventHandlers = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerEvents() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", async (file) => {
        if (file instanceof import_obsidian6.TFile) {
          await this.plugin.getFileService().handleConversationFileDeletion(file);
        }
      })
    );
  }
  cleanup() {
  }
};

// src/services/import-service.ts
var import_obsidian12 = require("obsidian");
var import_jszip = __toESM(require_jszip_min());
init_utils();
init_dialogs();

// src/models/import-report.ts
var ImportReport = class {
  constructor() {
    this.created = [];
    this.updated = [];
    this.skipped = [];
    this.failed = [];
    this.globalErrors = [];
    this.summary = "";
    this.providerSpecificColumnHeader = "Attachments";
  }
  setProviderSpecificColumnHeader(header) {
    this.providerSpecificColumnHeader = header;
  }
  addSummary(zipFileName, counters) {
    const totalAttachments = this.getTotalAttachmentStats();
    const attachmentSummary = totalAttachments.total > 0 ? `
- **Attachments**: ${totalAttachments.found}/${totalAttachments.total} extracted (${totalAttachments.missing} missing, ${totalAttachments.failed} failed)` : "";
    this.summary = `## Summary
- **ZIP File**: ${zipFileName}
- **Created**: ${this.created.length} new conversations
- **Updated**: ${this.updated.length} conversations with ${counters.totalNonEmptyMessagesAdded} new messages
- **Skipped**: ${this.skipped.length} conversations (no changes)
- **Failed**: ${this.failed.length} conversations
- **Errors**: ${this.globalErrors.length} global errors${attachmentSummary}`;
  }
  getTotalAttachmentStats() {
    const total = { total: 0, found: 0, missing: 0, failed: 0 };
    [...this.created, ...this.updated].forEach((entry) => {
      if (entry.attachmentStats) {
        total.total += entry.attachmentStats.total;
        total.found += entry.attachmentStats.found;
        total.missing += entry.attachmentStats.missing;
        total.failed += entry.attachmentStats.failed;
      }
    });
    return total;
  }
  addCreated(title, filePath, createDate, updateDate, messageCount, attachmentStats, providerSpecificCount) {
    this.created.push({ title, filePath, createDate, updateDate, messageCount, attachmentStats, providerSpecificCount });
  }
  addUpdated(title, filePath, createDate, updateDate, newMessageCount, attachmentStats, providerSpecificCount) {
    this.updated.push({ title, filePath, createDate, updateDate, newMessageCount, attachmentStats, providerSpecificCount });
  }
  addSkipped(title, filePath, createDate, updateDate, messageCount, reason, attachmentStats, providerSpecificCount) {
    this.skipped.push({ title, filePath, createDate, updateDate, messageCount, reason, attachmentStats, providerSpecificCount });
  }
  addFailed(title, filePath, createDate, updateDate, errorMessage) {
    this.failed.push({ title, filePath, createDate, updateDate, errorMessage });
  }
  addError(message, details) {
    this.globalErrors.push({ message, details });
  }
  generateReportContent() {
    let content = "# Nexus AI Chat Importer Report\n\n";
    if (this.summary) {
      content += this.summary + "\n\n";
    }
    if (this.created.length > 0) {
      content += this.generateCreatedTable();
    }
    if (this.updated.length > 0) {
      content += this.generateUpdatedTable();
    }
    if (this.failed.length > 0) {
      content += this.generateFailedTable();
    }
    if (this.globalErrors.length > 0) {
      content += this.generateErrorTable();
    }
    return content;
  }
  generateCreatedTable() {
    let table = `## \u2728 Created Notes

`;
    table += `| | Title | Created | Messages | ${this.providerSpecificColumnHeader} |
`;
    table += "|:---:|:---|:---:|:---:|:---:|\n";
    this.created.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      const titleLink = `[[${entry.filePath}\\|${sanitizedTitle}]]`;
      const providerSpecificValue = entry.providerSpecificCount || 0;
      const providerSpecificDisplay = providerSpecificValue > 0 ? `\u2705 ${providerSpecificValue}` : providerSpecificValue;
      table += `| \u2728 | ${titleLink} | ${entry.createDate} | ${entry.messageCount || 0} | ${providerSpecificDisplay} |
`;
    });
    return table + "\n\n";
  }
  generateUpdatedTable() {
    let table = `## \u{1F504} Updated Notes

`;
    table += `| | Title | Updated | New Messages | New ${this.providerSpecificColumnHeader} |
`;
    table += "|:---:|:---|:---:|:---:|:---:|\n";
    this.updated.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      const titleLink = `[[${entry.filePath}\\|${sanitizedTitle}]]`;
      const providerSpecificValue = entry.providerSpecificCount || 0;
      const providerSpecificDisplay = providerSpecificValue > 0 ? `\u2705 ${providerSpecificValue}` : providerSpecificValue;
      table += `| \u{1F504} | ${titleLink} | ${entry.updateDate} | ${entry.newMessageCount || 0} | ${providerSpecificDisplay} |
`;
    });
    return table + "\n\n";
  }
  generateFailedTable() {
    let table = `## \u{1F6AB} Failed Imports

`;
    table += "| | Title | Date | Error |\n";
    table += "|:---:|:---|:---:|:---|\n";
    this.failed.forEach((entry) => {
      const sanitizedTitle = entry.title.replace(/\n/g, " ").trim();
      table += `| \u{1F6AB} | ${sanitizedTitle} | ${entry.createDate} | ${entry.errorMessage || "Unknown error"} |
`;
    });
    return table + "\n\n";
  }
  generateErrorTable() {
    let table = `## \u26A0\uFE0F Global Errors

`;
    table += "| | Error | Details |\n";
    table += "|:---:|:---|:---|\n";
    this.globalErrors.forEach((entry) => {
      table += `| \u26A0\uFE0F | ${entry.message} | ${entry.details} |
`;
    });
    return table + "\n\n";
  }
  formatAttachmentStatus(stats) {
    if (!stats || stats.total === 0) {
      return "0";
    }
    const { total, found, missing, failed } = stats;
    if (found === total) {
      return `\u2705 ${found}`;
    } else if (found === 0) {
      return `\u274C 0/${total}`;
    } else {
      return `\u26A0\uFE0F ${found}/${total}`;
    }
  }
  hasErrors() {
    return this.failed.length > 0 || this.globalErrors.length > 0;
  }
  getCreatedCount() {
    return this.created.length;
  }
  getUpdatedCount() {
    return this.updated.length;
  }
  getSkippedCount() {
    return this.skipped.length;
  }
};

// src/services/conversation-processor.ts
var import_obsidian11 = require("obsidian");

// src/formatters/message-formatter.ts
init_utils();
var _MessageFormatter = class {
  constructor(logger4) {
    this.logger = logger4;
  }
  formatMessages(messages) {
    return messages.filter((message) => message !== void 0).map((message) => this.formatMessage(message)).filter((formattedMessage) => formattedMessage !== "").join("\n\n");
  }
  formatMessage(message) {
    if (!message) {
      this.logger.error("Message is null or undefined:", message);
      return "";
    }
    const messageTime = formatTimestamp(message.timestamp, "date") + " at " + formatTimestamp(message.timestamp, "time");
    const authorName = message.role === "user" ? "User" : "Assistant";
    const calloutType = message.role === "user" ? _MessageFormatter.CALLOUTS.USER : _MessageFormatter.CALLOUTS.AGENT;
    let messageContent = `>[!${calloutType}] **${authorName}** - ${messageTime}
`;
    if (message.content) {
      messageContent += `> ${message.content.split("\n").join("\n> ")}`;
    } else {
      messageContent += `> [No content found]`;
    }
    if (message.attachments && message.attachments.length > 0) {
      messageContent += "\n\n" + this.formatAttachments(message.attachments);
    }
    messageContent += `
<!-- UID: ${message.id} -->
`;
    if (message.role === "assistant") {
      messageContent += "\n---\n";
    }
    return messageContent + "\n\n";
  }
  formatAttachments(attachments) {
    return attachments.map((attachment) => {
      return this.formatSingleAttachment(attachment);
    }).join("\n\n");
  }
  /**
   * Format single attachment with Nexus callout styling
   */
  formatSingleAttachment(attachment) {
    var _a, _b, _c;
    if (attachment.extractedContent && attachment.extractedContent.includes("nexus_attachment")) {
      return attachment.extractedContent;
    }
    let content = `>[!${_MessageFormatter.CALLOUTS.ATTACHMENT}] `;
    if ((_a = attachment.status) == null ? void 0 : _a.found) {
      content += `**${attachment.fileName}**`;
    } else {
      content += `**${attachment.fileName}** *(missing)*`;
    }
    if (attachment.fileType) {
      content += ` (${attachment.fileType})`;
    }
    if (attachment.fileSize) {
      content += ` - ${this.formatFileSize(attachment.fileSize)}`;
    }
    content += "\n";
    if (((_b = attachment.status) == null ? void 0 : _b.found) && attachment.url) {
      if (!attachment.url.startsWith("sandbox://")) {
        if (this.isImageFile(attachment)) {
          content += `> ![[${attachment.url}]]`;
        } else {
          content += `> [[${attachment.url}]]`;
        }
      } else {
        content += `> \u26A0\uFE0F File not available in archive. Visit the original conversation to access it`;
      }
    } else if (attachment.status && !attachment.status.found) {
      content += `> \u26A0\uFE0F ${this.getStatusMessage(attachment.status.reason)}`;
      if (attachment.status.note) {
        content += `
> **Note:** ${attachment.status.note}`;
      }
      if (attachment.status.reason === "missing_from_export") {
        const conversationUrl = ((_c = attachment.url) == null ? void 0 : _c.includes("chatgpt.com")) ? attachment.url : "https://chatgpt.com/";
        content += `
> [Open original conversation](${conversationUrl})`;
      }
    } else if (attachment.extractedContent && this.isDalleImage(attachment)) {
      content += `> ${this.isImageFile(attachment) ? "![[" + attachment.url + "]]" : "[[" + attachment.url + "]]"}`;
    } else if (attachment.extractedContent) {
      content += `> ${attachment.extractedContent}`;
    } else if (attachment.content && !attachment.extractedContent) {
      content += `> ${attachment.content}`;
    }
    let dallePrompt = "";
    if (attachment.extractedContent && this.isDalleImage(attachment)) {
      dallePrompt = `

>[!${_MessageFormatter.CALLOUTS.PROMPT}] **DALL-E Prompt**
> \`\`\`
> ${attachment.extractedContent}
> \`\`\``;
    }
    return content + dallePrompt;
  }
  /**
   * Check if attachment is a DALL-E generated image
   */
  isDalleImage(attachment) {
    return attachment.fileName.startsWith("dalle_") && attachment.fileName.includes("_") && attachment.fileType === "image/png";
  }
  /**
   * Get user-friendly status message
   */
  getStatusMessage(reason) {
    switch (reason) {
      case "missing_from_export":
        return "Not included in export";
      case "extraction_failed":
        return "Extraction failed";
      case "corrupted":
        return "File appears corrupted";
      case "unsupported_format":
        return "Unsupported file format";
      default:
        return "Processing issue";
    }
  }
  /**
   * Check if attachment is an image file for embedding
   */
  isImageFile(attachment) {
    var _a;
    if ((_a = attachment.fileType) == null ? void 0 : _a.startsWith("image/")) {
      return true;
    }
    const fileName = attachment.fileName.toLowerCase();
    const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".bmp", ".tiff"];
    return imageExtensions.some((ext) => fileName.endsWith(ext));
  }
  formatFileSize(bytes) {
    const sizes = ["Bytes", "KB", "MB", "GB"];
    if (bytes === 0)
      return "0 Bytes";
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + " " + sizes[i];
  }
};
var MessageFormatter = _MessageFormatter;
// Nexus custom callouts with icons
MessageFormatter.CALLOUTS = {
  USER: "nexus_user",
  // 👤 User messages
  AGENT: "nexus_agent",
  // 🤖 Assistant/Agent messages
  ATTACHMENT: "nexus_attachment",
  // 📎 Attachments
  ARTIFACT: "nexus_artifact",
  // 🛠️ Claude artifacts
  PROMPT: "nexus_prompt"
  // 💭 System prompts
};

// src/formatters/note-formatter.ts
init_utils();

// src/types/standard.ts
var URL_GENERATORS = {
  chatgpt: {
    generateChatUrl: (id) => `https://chat.openai.com/c/${id}`
  },
  claude: {
    generateChatUrl: (id) => `https://claude.ai/chat/${id}`
  }
};

// src/formatters/note-formatter.ts
var NoteFormatter = class {
  constructor(logger4, pluginId, pluginVersion) {
    this.logger = logger4;
    this.pluginId = pluginId;
    this.pluginVersion = pluginVersion;
    this.messageFormatter = new MessageFormatter(logger4);
  }
  generateMarkdownContent(conversation) {
    const formattedTitle = formatTitle(conversation.title);
    const createTimeStr = `${formatTimestamp(conversation.createTime, "date")} at ${formatTimestamp(conversation.createTime, "time")}`;
    const updateTimeStr = `${formatTimestamp(conversation.updateTime, "date")} at ${formatTimestamp(conversation.updateTime, "time")}`;
    let content = this.generateHeader(formattedTitle, conversation.id, createTimeStr, updateTimeStr, conversation);
    content += this.generateMessagesContent(conversation);
    return content;
  }
  generateHeader(title, conversationId, createTimeStr, updateTimeStr, conversation) {
    let chatUrl = conversation.chatUrl;
    if (!chatUrl && URL_GENERATORS[conversation.provider]) {
      chatUrl = URL_GENERATORS[conversation.provider].generateChatUrl(conversationId);
    }
    let frontmatter = `---
nexus: ${this.pluginId}
plugin_version: "${this.pluginVersion}"
provider: ${conversation.provider}
aliases: "${title}"
conversation_id: ${conversationId}
create_time: ${createTimeStr}
update_time: ${updateTimeStr}
---

`;
    let header = `# Title: ${title}

`;
    header += `Created: ${createTimeStr}
`;
    header += `Last Updated: ${updateTimeStr}
`;
    if (chatUrl) {
      header += `Chat URL: ${chatUrl}
`;
    }
    header += "\n\n";
    return frontmatter + header;
  }
  generateMessagesContent(conversation) {
    return this.messageFormatter.formatMessages(conversation.messages);
  }
};

// src/services/file-service.ts
var import_obsidian10 = require("obsidian");
var FileService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async writeToFile(filePath, content) {
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian10.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else if (file instanceof import_obsidian10.TFolder) {
        throw new Error(`Cannot write to '${filePath}'; it is a folder.`);
      } else {
        await this.plugin.app.vault.create(filePath, content);
      }
    } catch (error) {
      this.plugin.logger.error(`Error creating or modifying file '${filePath}'`, error.message);
      throw error;
    }
  }
  async handleConversationFileDeletion(file) {
    var _a;
    try {
      const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!(frontmatter == null ? void 0 : frontmatter.conversation_id) || (frontmatter == null ? void 0 : frontmatter.nexus) !== this.plugin.manifest.id) {
        return;
      }
      const storage = this.plugin.getStorageService();
      const catalog = storage.getConversationCatalog();
      for (const [id, record] of Object.entries(catalog)) {
        if (record.conversationId === frontmatter.conversation_id) {
          storage.deleteFromConversationCatalog(id);
          await this.plugin.saveSettings();
          break;
        }
      }
    } catch (error) {
      this.plugin.logger.error("Error handling conversation file deletion:", error);
    }
  }
  /**
   * Get file extension from filename (provider-agnostic utility)
   */
  getFileExtension(fileName) {
    const lastDot = fileName.lastIndexOf(".");
    return lastDot === -1 ? "" : fileName.substring(lastDot + 1).toLowerCase();
  }
  // TODO: Future enhancement - delete conversation attachments
  // async deleteConversationAttachments(conversationId: string): Promise<void> {
  //     // Implementation for deleting attachments when conversation is deleted
  // }
};

// src/services/conversation-processor.ts
init_utils();
var ConversationProcessor = class {
  constructor(plugin, providerRegistry) {
    this.plugin = plugin;
    this.counters = {
      totalExistingConversations: 0,
      totalNewConversationsToImport: 0,
      totalExistingConversationsToUpdate: 0,
      totalNewConversationsSuccessfullyImported: 0,
      totalConversationsActuallyUpdated: 0,
      totalConversationsProcessed: 0,
      totalNonEmptyMessagesToImport: 0,
      totalNonEmptyMessagesToAdd: 0,
      totalNonEmptyMessagesAdded: 0
    };
    this.currentProvider = "unknown";
    this.messageFormatter = new MessageFormatter(plugin.logger);
    this.fileService = new FileService(plugin);
    this.noteFormatter = new NoteFormatter(plugin.logger, plugin.manifest.id, plugin.manifest.version);
    this.providerRegistry = providerRegistry;
  }
  /**
   * Process raw conversations (provider agnostic entry point)
   */
  async processRawConversations(rawConversations, importReport, zip, isReprocess = false, forcedProvider) {
    const provider = forcedProvider || this.providerRegistry.detectProvider(rawConversations);
    if (provider === "unknown") {
      const errorMsg = forcedProvider ? `Forced provider '${forcedProvider}' is not available or registered` : `Could not detect conversation provider from data structure`;
      importReport.addError("Unknown provider", errorMsg);
      return importReport;
    }
    return this.processConversationsWithProvider(provider, rawConversations, importReport, zip, isReprocess);
  }
  /**
   * Get provider name for current processing session
   */
  getCurrentProvider() {
    return this.currentProvider || "unknown";
  }
  /**
   * Process conversations using the detected provider
   */
  async processConversationsWithProvider(provider, rawConversations, importReport, zip, isReprocess = false) {
    this.currentProvider = provider;
    const adapter = this.providerRegistry.getAdapter(provider);
    if (!adapter) {
      importReport.addError("Provider adapter not found", `No adapter found for provider: ${provider}`);
      return importReport;
    }
    const storage = this.plugin.getStorageService();
    const existingConversationsMap = await storage.scanExistingConversations();
    this.counters.totalExistingConversations = existingConversationsMap.size;
    for (const chat of rawConversations) {
      await this.processSingleChat(adapter, chat, existingConversationsMap, importReport, zip, isReprocess);
    }
    return importReport;
  }
  async processSingleChat(adapter, chat, existingConversations, importReport, zip, isReprocess = false) {
    try {
      const chatId = adapter.getId(chat);
      const existingEntry = existingConversations.get(chatId);
      if (existingEntry) {
        await this.handleExistingChat(adapter, chat, existingEntry, importReport, zip, isReprocess);
      } else {
        const filePath = await this.generateFilePathForChat(adapter, chat);
        await this.handleNewChat(adapter, chat, filePath, importReport, zip);
      }
      this.counters.totalConversationsProcessed++;
    } catch (error) {
      const errorMessage = error.message || "Unknown error occurred";
      const chatTitle = adapter.getTitle(chat) || "Untitled";
      importReport.addError(`Error processing chat: ${chatTitle}`, errorMessage);
    }
  }
  async handleExistingChat(adapter, chat, existingRecord, importReport, zip, isReprocess = false) {
    const chatTitle = adapter.getTitle(chat);
    const createTime = adapter.getCreateTime(chat);
    const updateTime = adapter.getUpdateTime(chat);
    const totalMessageCount = await this.countMessages(adapter, chat);
    const fileExists = await this.plugin.app.vault.adapter.exists(existingRecord.path);
    if (!fileExists) {
      await this.handleNewChat(adapter, chat, existingRecord.path, importReport, zip);
      return;
    }
    if (isReprocess) {
      this.plugin.logger.info(`Reprocessing conversation: ${chatTitle}`);
      this.counters.totalExistingConversationsToUpdate++;
      await this.updateExistingNote(adapter, chat, existingRecord.path, totalMessageCount, importReport, zip, true);
      return;
    }
    if (existingRecord.updateTime >= updateTime) {
      importReport.addSkipped(
        chatTitle,
        existingRecord.path,
        formatTimestamp(createTime, "date"),
        formatTimestamp(updateTime, "date"),
        totalMessageCount,
        "No Updates"
      );
    } else {
      this.counters.totalExistingConversationsToUpdate++;
      await this.updateExistingNote(adapter, chat, existingRecord.path, totalMessageCount, importReport, zip);
    }
  }
  async handleNewChat(adapter, chat, filePath, importReport, zip) {
    this.counters.totalNewConversationsToImport++;
    await this.createNewNote(adapter, chat, filePath, importReport, zip);
  }
  /**
   * Count messages in a chat using provider-specific logic
   */
  async countMessages(adapter, chat) {
    var _a;
    try {
      const standardConversation = await adapter.convertChat(chat);
      return ((_a = standardConversation.messages) == null ? void 0 : _a.length) || 0;
    } catch (error) {
      if (chat.mapping) {
        return Object.values(chat.mapping).filter((msg) => isValidMessage(msg.message)).length;
      } else if (chat.messages) {
        return Array.isArray(chat.messages) ? chat.messages.length : 0;
      }
      return 0;
    }
  }
  /**
   * Get provider-specific count (artifacts for Claude, attachments for ChatGPT)
   */
  getProviderSpecificCount(adapter, chat) {
    try {
      const strategy = adapter.getReportNamingStrategy();
      if (strategy && strategy.getProviderSpecificColumn) {
        const columnInfo = strategy.getProviderSpecificColumn();
        return columnInfo.getValue(adapter, chat);
      }
    } catch (error) {
    }
    return 0;
  }
  async updateExistingNote(adapter, chat, filePath, totalMessageCount, importReport, zip, forceUpdate = false) {
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian11.TFile) {
        let content = await this.plugin.app.vault.read(file);
        const originalContent = content;
        const chatUpdateTime = adapter.getUpdateTime(chat);
        const chatCreateTime = adapter.getCreateTime(chat);
        const chatTitle = adapter.getTitle(chat);
        content = this.updateMetadata(content, chatUpdateTime);
        const existingMessageIds = this.extractMessageUIDsFromNote(content);
        const newMessages = adapter.getNewMessages(chat, existingMessageIds);
        let attachmentStats = void 0;
        if (forceUpdate) {
          let standardConversation = await adapter.convertChat(chat);
          if (zip && this.plugin.settings.importAttachments && adapter.processMessageAttachments) {
            standardConversation.messages = await adapter.processMessageAttachments(
              standardConversation.messages,
              adapter.getId(chat),
              zip
            );
            attachmentStats = this.calculateAttachmentStats(standardConversation.messages);
          }
          const newContent = this.noteFormatter.generateMarkdownContent(standardConversation);
          await this.fileService.writeToFile(filePath, newContent);
          importReport.addUpdated(
            chatTitle,
            filePath,
            `${formatTimestamp(chatCreateTime, "date")} ${formatTimestamp(chatCreateTime, "time")}`,
            `${formatTimestamp(chatUpdateTime, "date")} ${formatTimestamp(chatUpdateTime, "time")}`,
            totalMessageCount,
            attachmentStats
          );
          this.counters.totalConversationsActuallyUpdated++;
          return;
        }
        if (newMessages.length > 0) {
          let standardMessages = await adapter.convertMessages(newMessages, adapter.getId(chat));
          if (zip && this.plugin.settings.importAttachments && adapter.processMessageAttachments) {
            standardMessages = await adapter.processMessageAttachments(
              standardMessages,
              adapter.getId(chat),
              zip
            );
          }
          attachmentStats = this.calculateAttachmentStats(standardMessages);
          content += "\n\n" + this.messageFormatter.formatMessages(standardMessages);
          this.counters.totalConversationsActuallyUpdated++;
          this.counters.totalNonEmptyMessagesAdded += newMessages.length;
        }
        if (content !== originalContent) {
          await this.fileService.writeToFile(filePath, content);
          importReport.addUpdated(
            chatTitle,
            filePath,
            `${formatTimestamp(chatCreateTime, "date")} ${formatTimestamp(chatCreateTime, "time")}`,
            `${formatTimestamp(chatUpdateTime, "date")} ${formatTimestamp(chatUpdateTime, "time")}`,
            newMessages.length,
            attachmentStats
          );
        } else {
          importReport.addSkipped(
            chatTitle,
            filePath,
            `${formatTimestamp(chatCreateTime, "date")} ${formatTimestamp(chatCreateTime, "time")}`,
            `${formatTimestamp(chatUpdateTime, "date")} ${formatTimestamp(chatUpdateTime, "time")}`,
            totalMessageCount,
            "No changes needed"
          );
        }
      }
    } catch (error) {
      this.plugin.logger.error("Error updating note", error.message);
    }
  }
  async createNewNote(adapter, chat, filePath, importReport, zip) {
    try {
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
      const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
      if (!folderResult.success) {
        throw new Error(folderResult.error || "Failed to ensure folder exists.");
      }
      let standardConversation = await adapter.convertChat(chat);
      let attachmentStats = { total: 0, found: 0, missing: 0, failed: 0 };
      if (zip && this.plugin.settings.importAttachments && adapter.processMessageAttachments) {
        standardConversation.messages = await adapter.processMessageAttachments(
          standardConversation.messages,
          adapter.getId(chat),
          zip
        );
        attachmentStats = this.calculateAttachmentStats(standardConversation.messages);
      }
      const content = this.noteFormatter.generateMarkdownContent(standardConversation);
      await this.fileService.writeToFile(filePath, content);
      const messageCount = await this.countMessages(adapter, chat);
      const createTime = adapter.getCreateTime(chat);
      const updateTime = adapter.getUpdateTime(chat);
      const chatTitle = adapter.getTitle(chat);
      const providerSpecificCount = this.getProviderSpecificCount(adapter, chat);
      importReport.addCreated(
        chatTitle,
        filePath,
        `${formatTimestamp(createTime, "date")} ${formatTimestamp(createTime, "time")}`,
        `${formatTimestamp(updateTime, "date")} ${formatTimestamp(updateTime, "time")}`,
        messageCount,
        attachmentStats,
        providerSpecificCount
      );
      this.counters.totalNewConversationsSuccessfullyImported++;
      this.counters.totalNonEmptyMessagesToImport += messageCount;
    } catch (error) {
      this.plugin.logger.error("Error creating new note", error.message);
      const createTime = adapter.getCreateTime(chat);
      const updateTime = adapter.getUpdateTime(chat);
      const chatTitle = adapter.getTitle(chat);
      importReport.addFailed(
        chatTitle,
        filePath,
        formatTimestamp(createTime, "date") + " " + formatTimestamp(createTime, "time"),
        formatTimestamp(updateTime, "date") + " " + formatTimestamp(updateTime, "time"),
        error.message
      );
      throw error;
    }
  }
  updateMetadata(content, updateTime) {
    const updateTimeStr = `${formatTimestamp(updateTime, "date")} at ${formatTimestamp(updateTime, "time")}`;
    content = content.replace(/^update_time: .*$/m, `update_time: ${updateTimeStr}`);
    content = content.replace(/^Last Updated: .*$/m, `Last Updated: ${updateTimeStr}`);
    return content;
  }
  extractMessageUIDsFromNote(content) {
    const uidRegex = /<!-- UID: (.*?) -->/g;
    const uids = [];
    let match;
    while ((match = uidRegex.exec(content)) !== null) {
      uids.push(match[1]);
    }
    return uids;
  }
  async generateFilePathForChat(adapter, chat) {
    const createTime = adapter.getCreateTime(chat);
    const chatTitle = adapter.getTitle(chat);
    const providerName = adapter.getProviderName();
    const date = new Date(createTime * 1e3);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const folderPath = `${this.plugin.settings.archiveFolder}/${providerName}/${year}/${month}`;
    const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(folderResult.error || "Failed to ensure folder exists.");
    }
    let fileName = generateConversationFileName(
      chatTitle,
      createTime,
      this.plugin.settings.addDatePrefix,
      this.plugin.settings.dateFormat
    ) + ".md";
    let filePath = `${folderPath}/${fileName}`;
    if (await doesFilePathExist(filePath, this.plugin.app.vault)) {
      filePath = await generateUniqueFileName(filePath, this.plugin.app.vault.adapter);
    }
    return filePath;
  }
  getCounters() {
    return this.counters;
  }
  /**
   * Calculate attachment statistics from processed messages
   */
  calculateAttachmentStats(messages) {
    var _a, _b, _c;
    const stats = { total: 0, found: 0, missing: 0, failed: 0 };
    for (const message of messages) {
      if (message.attachments) {
        for (const attachment of message.attachments) {
          stats.total++;
          if ((_a = attachment.status) == null ? void 0 : _a.found) {
            stats.found++;
          } else if (((_b = attachment.status) == null ? void 0 : _b.reason) === "missing_from_export") {
            stats.missing++;
          } else if (((_c = attachment.status) == null ? void 0 : _c.reason) === "extraction_failed") {
            stats.failed++;
          }
        }
      }
    }
    return stats;
  }
};

// src/models/errors.ts
var NexusAiChatImporterError = class extends Error {
  constructor(message, details) {
    super(message);
    this.details = details;
    this.name = "NexusAiChatImporterError";
  }
};

// src/providers/provider-adapter.ts
var DefaultProviderRegistry = class {
  constructor() {
    this.adapters = {};
  }
  register(providerName, adapter) {
    this.adapters[providerName] = adapter;
  }
  getAdapter(provider) {
    return this.adapters[provider];
  }
  detectProvider(rawConversations) {
    for (const [name, adapter] of Object.entries(this.adapters)) {
      try {
        if (adapter.detect(rawConversations))
          return name;
      } catch (_) {
      }
    }
    return "unknown";
  }
};

// src/providers/chatgpt/chatgpt-converter.ts
init_utils();
var ChatGPTConverter = class {
  /**
   * Convert ChatGPT Chat to StandardConversation
   */
  static convertChat(chat) {
    const messages = this.extractMessagesFromMapping(chat);
    return {
      id: chat.id || "",
      title: chat.title || "Untitled",
      provider: "chatgpt",
      createTime: chat.create_time || 0,
      updateTime: chat.update_time || 0,
      messages,
      metadata: {
        conversation_template_id: chat.conversation_template_id,
        gizmo_id: chat.gizmo_id,
        gizmo_type: chat.gizmo_type,
        default_model_slug: chat.default_model_slug,
        is_archived: chat.is_archived,
        is_starred: chat.is_starred,
        current_node: chat.current_node,
        memory_scope: chat.memory_scope
      }
    };
  }
  /**
   * Convert array of ChatGPT ChatMessages to StandardMessages
   */
  static convertMessages(chatMessages, conversationId) {
    return chatMessages.filter((msg) => isValidMessage(msg)).map((msg) => this.convertMessage(msg, conversationId));
  }
  /**
   * Convert single ChatGPT ChatMessage to StandardMessage
   */
  static convertMessage(chatMessage, conversationId) {
    var _a;
    const contentResult = this.extractContent(chatMessage, conversationId);
    return {
      id: chatMessage.id || "",
      role: ((_a = chatMessage.author) == null ? void 0 : _a.role) === "user" ? "user" : "assistant",
      content: contentResult.content,
      timestamp: chatMessage.create_time || 0,
      attachments: contentResult.attachments || []
    };
  }
  /**
   * Extract messages from ChatGPT mapping structure with DALL-E prompt association
   */
  static extractMessagesFromMapping(chat) {
    var _a, _b, _c, _d;
    const messages = [];
    const dallePrompts = /* @__PURE__ */ new Map();
    const conversationId = chat.id;
    const mappingValues = Object.values(chat.mapping);
    for (const messageObj of mappingValues) {
      const message = messageObj == null ? void 0 : messageObj.message;
      if (!message || ((_a = message.author) == null ? void 0 : _a.role) !== "assistant")
        continue;
      if (this.isDallePromptMessage(message)) {
        const prompt = this.extractPromptFromJson(message);
        if (prompt) {
          const children = messageObj.children || [];
          for (const childId of children) {
            const childObj = chat.mapping[childId];
            if (((_c = (_b = childObj == null ? void 0 : childObj.message) == null ? void 0 : _b.author) == null ? void 0 : _c.role) === "tool" && this.hasRealDalleImage(childObj.message)) {
              dallePrompts.set(childId, prompt);
              break;
            }
          }
        }
      }
    }
    for (const messageObj of mappingValues) {
      const message = messageObj == null ? void 0 : messageObj.message;
      if (!message)
        continue;
      if (((_d = message.author) == null ? void 0 : _d.role) === "tool" && this.hasRealDalleImage(message)) {
        const prompt = dallePrompts.get(messageObj.id || "");
        const dalleMessage = this.createDalleAssistantMessage(message, prompt);
        if (dalleMessage) {
          messages.push(dalleMessage);
        }
      } else if (this.shouldIncludeMessage(message)) {
        messages.push(this.convertMessage(message, conversationId));
      }
    }
    if (messages.length <= 1)
      return messages;
    return messages.sort((a, b) => {
      if (a.timestamp !== b.timestamp) {
        return a.timestamp - b.timestamp;
      }
      return a.id.localeCompare(b.id);
    });
  }
  /**
   * Check if message is a DALL-E JSON prompt message
   */
  static isDallePromptMessage(message) {
    var _a, _b;
    if (((_a = message.author) == null ? void 0 : _a.role) !== "assistant")
      return false;
    if (((_b = message.content) == null ? void 0 : _b.parts) && Array.isArray(message.content.parts) && message.content.parts.length === 1 && typeof message.content.parts[0] === "string") {
      const content = message.content.parts[0].trim();
      return content.startsWith("{") && content.includes('"prompt"');
    }
    return false;
  }
  /**
   * Extract prompt from DALL-E JSON message
   */
  static extractPromptFromJson(message) {
    var _a;
    try {
      if (((_a = message.content) == null ? void 0 : _a.parts) && message.content.parts[0]) {
        const jsonStr = message.content.parts[0];
        const parsed = JSON.parse(jsonStr);
        return parsed.prompt || null;
      }
    } catch (error) {
    }
    return null;
  }
  /**
   * Determine if a message should be included in the conversation - ENHANCED VERSION
   */
  static shouldIncludeMessage(message) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!message || !message.author) {
      return false;
    }
    if (message.author.role === "system") {
      return false;
    }
    if (message.author.role === "tool") {
      return false;
    }
    if (((_a = message.metadata) == null ? void 0 : _a.is_visually_hidden_from_conversation) === true) {
      return false;
    }
    if (((_b = message.metadata) == null ? void 0 : _b.is_user_system_message) === true) {
      return false;
    }
    if (((_c = message.content) == null ? void 0 : _c.content_type) === "user_editable_context") {
      return false;
    }
    if (message.author.role === "assistant") {
      if (((_d = message.content) == null ? void 0 : _d.parts) && Array.isArray(message.content.parts) && message.content.parts.every(
        (part) => typeof part === "string" && part.trim() === ""
      )) {
        return false;
      }
      if (this.isDallePromptMessage(message)) {
        return false;
      }
      if (((_e = message.content) == null ? void 0 : _e.content_type) === "code") {
        return false;
      }
      if (((_f = message.content) == null ? void 0 : _f.content_type) === "system_error") {
        return false;
      }
      if (((_g = message.content) == null ? void 0 : _g.content_type) === "execution_output") {
        return false;
      }
      if (((_h = message.content) == null ? void 0 : _h.content_type) === "multimodal_text") {
        if (((_i = message.content) == null ? void 0 : _i.parts) && Array.isArray(message.content.parts)) {
          const hasTextContent = message.content.parts.some((part) => {
            if (typeof part === "string" && part.trim() !== "") {
              return true;
            }
            if (typeof part === "object" && part !== null && "text" in part) {
              return typeof part.text === "string" && part.text.trim() !== "";
            }
            return false;
          });
          if (!hasTextContent) {
            return false;
          }
        }
      }
    }
    if (message.author.role === "user") {
      const excludedContentTypes = [
        "user_editable_context"
        // Already covered above but double-check
      ];
      if (((_j = message.content) == null ? void 0 : _j.content_type) && excludedContentTypes.includes(message.content.content_type)) {
        return false;
      }
    }
    return isValidMessage(message);
  }
  /**
   * Check if message contains REAL DALL-E image (not user upload)
   */
  static hasRealDalleImage(message) {
    var _a;
    if (!((_a = message.content) == null ? void 0 : _a.parts) || !Array.isArray(message.content.parts)) {
      return false;
    }
    return message.content.parts.some((part) => {
      var _a2;
      if (typeof part !== "object" || part === null)
        return false;
      const contentPart = part;
      return contentPart.content_type === "image_asset_pointer" && contentPart.asset_pointer && ((_a2 = contentPart.metadata) == null ? void 0 : _a2.dalle) && contentPart.metadata.dalle !== null;
    });
  }
  /**
   * Create Assistant (DALL-E) message from tool message with associated prompt
   */
  static createDalleAssistantMessage(toolMessage, associatedPrompt) {
    var _a, _b;
    if (!((_a = toolMessage.content) == null ? void 0 : _a.parts) || !Array.isArray(toolMessage.content.parts)) {
      return null;
    }
    const attachments = [];
    for (const part of toolMessage.content.parts) {
      if (typeof part === "object" && part !== null) {
        const contentPart = part;
        if (contentPart.content_type === "image_asset_pointer" && contentPart.asset_pointer && ((_b = contentPart.metadata) == null ? void 0 : _b.dalle) && contentPart.metadata.dalle !== null) {
          let fileId = contentPart.asset_pointer;
          if (fileId.includes("://")) {
            fileId = fileId.split("://")[1];
          }
          const genId = contentPart.metadata.dalle.gen_id || "unknown";
          const width = contentPart.width || 1024;
          const height = contentPart.height || 1024;
          const fileName = `dalle_${genId}_${width}x${height}.png`;
          const dalleAttachment = {
            fileName,
            fileSize: contentPart.size_bytes,
            fileType: "image/png",
            fileId,
            // Use associated prompt from JSON message, fallback to metadata
            extractedContent: associatedPrompt || contentPart.metadata.dalle.prompt
          };
          attachments.push(dalleAttachment);
        }
      }
    }
    if (attachments.length === 0) {
      return null;
    }
    return {
      id: toolMessage.id || "",
      role: "assistant",
      content: "Image g\xE9n\xE9r\xE9e par DALL-E",
      timestamp: toolMessage.create_time || 0,
      attachments
    };
  }
  /**
   * Extract content and attachments from ChatGPT message parts
   */
  static extractContent(chatMessage, conversationId) {
    var _a;
    if (!((_a = chatMessage.content) == null ? void 0 : _a.parts) || !Array.isArray(chatMessage.content.parts)) {
      return { content: "" };
    }
    const contentParts = [];
    const attachments = [];
    for (const part of chatMessage.content.parts) {
      let textContent = "";
      if (typeof part === "string" && part.trim() !== "") {
        if (part.trim().startsWith("{") && part.trim().endsWith("}")) {
          try {
            const parsed = JSON.parse(part);
            if (parsed.type && parsed.content && typeof parsed.content === "string") {
              const codeType = parsed.type;
              const codeContent = parsed.content;
              if (codeContent.trim() !== "") {
                const language = codeType.includes("/") ? codeType.split("/")[1] : codeType;
                textContent = `\`\`\`${language}
${codeContent}
\`\`\``;
              }
            } else {
              textContent = part;
            }
          } catch (e) {
            textContent = part;
          }
        } else {
          textContent = part;
        }
      } else if (typeof part === "object" && part !== null) {
        if ("type" in part && "content" in part && typeof part.content === "string") {
          const codeType = part.type;
          const codeContent = part.content;
          if (codeContent.trim() !== "") {
            const language = codeType.includes("/") ? codeType.split("/")[1] : codeType;
            textContent = `\`\`\`${language}
${codeContent}
\`\`\``;
          }
        } else if ("content_type" in part && "text" in part && typeof part.text === "string") {
          if (part.content_type === "audio_transcription" && part.text.trim() !== "") {
            textContent = part.text;
          } else if (part.content_type === "text" && part.text.trim() !== "") {
            textContent = part.text;
          } else if (part.content_type === "multimodal_text" && part.text.trim() !== "") {
            textContent = part.text;
          }
        } else if ("content_type" in part && part.content_type === "image_asset_pointer" && "asset_pointer" in part) {
          const attachment = this.extractImageAttachment(part, conversationId);
          if (attachment) {
            attachments.push(attachment);
          }
        }
      }
      if (textContent) {
        textContent = this.cleanChatGPTArtifacts(textContent, conversationId);
        if (textContent.trim() !== "") {
          contentParts.push(textContent);
        }
      }
    }
    const finalContent = contentParts.join("\n");
    if (chatMessage.attachments) {
      for (const att of chatMessage.attachments) {
        attachments.push({
          fileName: att.file_name,
          fileType: att.file_type || "application/octet-stream",
          fileSize: att.file_size,
          extractedContent: att.extracted_content
        });
      }
    }
    return {
      content: finalContent,
      attachments: attachments.length > 0 ? attachments : void 0
    };
  }
  /**
   * Extract image attachment from content part
   */
  static extractImageAttachment(part, conversationId) {
    var _a;
    if (!part.asset_pointer)
      return null;
    let fileId = part.asset_pointer;
    if (fileId.includes("://")) {
      fileId = fileId.split("://")[1];
    }
    let fileName = `image_${fileId}`;
    if (part.width && part.height) {
      fileName = `image_${fileId}_${part.width}x${part.height}`;
    }
    const fileType = ((_a = part.metadata) == null ? void 0 : _a.mime_type) || "image/png";
    const extension = fileType.split("/")[1] || "png";
    fileName += `.${extension}`;
    return {
      fileName,
      fileType,
      fileSize: part.size_bytes,
      fileId
    };
  }
  /**
   * Clean ChatGPT artifacts, citations, and control characters - SMART LINKING
   */
  static cleanChatGPTArtifacts(text, conversationId) {
    if (!text || typeof text !== "string")
      return "";
    const chatUrl = conversationId ? `https://chat.openai.com/c/${conversationId}` : "https://chat.openai.com";
    let cleanText = text;
    for (const { pattern, replacement } of this.CLEANUP_PATTERNS) {
      cleanText = cleanText.replace(pattern, replacement(chatUrl));
    }
    return cleanText.trim();
  }
};
// Pre-compiled regex patterns for performance
ChatGPTConverter.CLEANUP_PATTERNS = [
  // SMART: Replace sandbox links with actual links to original conversation
  { pattern: /📄 \[([^\]]+)\]\(sandbox:\/[^)]+\)/g, replacement: (chatUrl) => `\u{1F4C4} [$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /📄 ([^-\n]+) - File not available in archive/g, replacement: (chatUrl) => `\u{1F4C4} [$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /\[([^\]]+)\]\(sandbox:\/[^)]+\)/g, replacement: (chatUrl) => `[$1](${chatUrl}) *(visit original conversation to download)*` },
  { pattern: /([^-\n]+) - File not available in archive\. Visit the original conversation to access it/g, replacement: (chatUrl) => `[$1](${chatUrl}) *(visit original conversation to download)*` },
  // Remove patterns (static replacements)
  { pattern: /cite[a-zA-Z0-9_\-]+/g, replacement: () => "" },
  { pattern: /link[a-zA-Z0-9_\-]+/g, replacement: () => "" },
  { pattern: /turn\d+search\d+/g, replacement: () => "" },
  { pattern: /[\uE000-\uF8FF]/g, replacement: () => "" },
  // Unicode control characters
  { pattern: / {2,}/g, replacement: () => " " },
  // Multiple spaces
  { pattern: /\n{3,}/g, replacement: () => "\n\n" }
  // Multiple newlines
];

// src/providers/chatgpt/chatgpt-attachment-extractor.ts
init_utils();
var ChatGPTAttachmentExtractor = class {
  // Cache for ZIP file lookups
  constructor(plugin, logger4) {
    this.plugin = plugin;
    this.logger = logger4;
    this.zipFileCache = /* @__PURE__ */ new Map();
  }
  /**
   * Extract and save ChatGPT attachments using "best effort" strategy
   * - If file exists in ZIP: extract and link
   * - If file missing: create informative note
   */
  async extractAttachments(zip, conversationId, attachments) {
    if (!this.plugin.settings.importAttachments || attachments.length === 0) {
      return attachments.map((att) => ({ ...att, status: { processed: false, found: false } }));
    }
    const processedAttachments = [];
    for (const attachment of attachments) {
      try {
        const result = await this.processAttachmentBestEffort(zip, conversationId, attachment);
        processedAttachments.push(result);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger.error(`Failed to process ChatGPT attachment: ${attachment.fileName}`, errorMessage);
        processedAttachments.push({
          ...attachment,
          status: {
            processed: false,
            found: false,
            reason: "extraction_failed",
            note: `Processing failed: ${errorMessage}`
          }
        });
      }
    }
    return processedAttachments;
  }
  /**
   * Process single attachment with best effort strategy
   */
  async processAttachmentBestEffort(zip, conversationId, attachment) {
    const zipFile = await this.findChatGPTFileById(zip, attachment);
    if (!zipFile) {
      return {
        ...attachment,
        status: {
          processed: true,
          found: false,
          reason: "missing_from_export",
          note: "This file was referenced in the conversation but not included in the ChatGPT export. This can happen with older conversations or certain file types."
        }
      };
    }
    try {
      const extractResult = await this.extractSingleAttachment(zip, conversationId, attachment, zipFile);
      if (extractResult) {
        return {
          ...attachment,
          fileName: extractResult.finalFileName,
          // Update with actual extracted filename
          fileType: extractResult.actualFileType,
          // Update with detected file type
          url: extractResult.localPath,
          status: {
            processed: true,
            found: true,
            localPath: extractResult.localPath
          }
        };
      } else {
        return {
          ...attachment,
          status: {
            processed: true,
            found: false,
            reason: "extraction_failed",
            note: "File was found in export but could not be extracted to disk."
          }
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error(`Error extracting ChatGPT attachment: ${attachment.fileName}`, errorMessage);
      return {
        ...attachment,
        status: {
          processed: true,
          found: true,
          // File exists but extraction failed
          reason: "extraction_failed",
          note: `Extraction failed: ${errorMessage}`
        }
      };
    }
  }
  /**
   * Extract single attachment to disk with conflict resolution and format detection
   */
  async extractSingleAttachment(zip, conversationId, attachment, zipFile) {
    const fileContent = await zipFile.async("uint8array");
    const formatInfo = this.detectFileFormat(fileContent);
    let finalFileName = attachment.fileName;
    if (zipFile.name.endsWith(".dat") && formatInfo.extension) {
      const baseName = attachment.fileName.replace(/\.(dat|png|jpg|jpeg|gif|webp)$/i, "");
      finalFileName = `${baseName}.${formatInfo.extension}`;
    }
    let targetPath = this.generateLocalPath(conversationId, {
      ...attachment,
      fileName: finalFileName,
      fileType: formatInfo.mimeType || attachment.fileType
    });
    const folderPath = targetPath.substring(0, targetPath.lastIndexOf("/"));
    const folderResult = await ensureFolderExists(folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create ChatGPT attachment folder: ${folderResult.error}`);
    }
    targetPath = await this.resolveFileConflict(targetPath);
    await this.plugin.app.vault.adapter.writeBinary(targetPath, fileContent);
    return {
      localPath: targetPath,
      finalFileName,
      actualFileType: formatInfo.mimeType || attachment.fileType || "application/octet-stream"
    };
  }
  /**
   * Detect file format from magic bytes (especially for .dat files)
   */
  detectFileFormat(fileContent) {
    if (fileContent.length < 4) {
      this.logger.warn("File too small for format detection");
      return { extension: null, mimeType: null };
    }
    const header = Array.from(fileContent.slice(0, 12)).map((b) => b.toString(16).padStart(2, "0")).join("");
    if (header.startsWith("89504e47")) {
      return { extension: "png", mimeType: "image/png" };
    }
    if (header.startsWith("ffd8ff")) {
      return { extension: "jpg", mimeType: "image/jpeg" };
    }
    if (header.startsWith("47494638")) {
      return { extension: "gif", mimeType: "image/gif" };
    }
    if (header.startsWith("52494646") && header.substring(16, 24) === "57454250") {
      return { extension: "webp", mimeType: "image/webp" };
    }
    if (header.startsWith("52494646")) {
      return { extension: "webp", mimeType: "image/webp" };
    }
    return { extension: null, mimeType: null };
  }
  /**
   * Resolve file conflicts by adding numeric suffix
   */
  async resolveFileConflict(originalPath) {
    let finalPath = originalPath;
    let counter = 1;
    while (await this.plugin.app.vault.adapter.exists(finalPath)) {
      const lastDot = originalPath.lastIndexOf(".");
      if (lastDot === -1) {
        finalPath = `${originalPath}_${counter}`;
      } else {
        const nameWithoutExt = originalPath.substring(0, lastDot);
        const extension = originalPath.substring(lastDot);
        finalPath = `${nameWithoutExt}_${counter}${extension}`;
      }
      counter++;
    }
    return finalPath;
  }
  /**
   * Find file in ZIP - ENHANCED WITH COMPREHENSIVE SEARCH + CACHING
   */
  async findChatGPTFileById(zip, attachment) {
    if (!attachment.fileId) {
      this.logger.warn("No fileId provided for attachment:", attachment.fileName);
      return null;
    }
    const cacheKey = `${attachment.fileId}_${attachment.fileName}`;
    if (this.zipFileCache.has(cacheKey)) {
      return this.zipFileCache.get(cacheKey);
    }
    let zipFile = zip.file(attachment.fileName);
    if (zipFile) {
      this.zipFileCache.set(cacheKey, zipFile);
      return zipFile;
    }
    const foundFile = await this.searchZipByFileId(zip, attachment.fileId);
    this.zipFileCache.set(cacheKey, foundFile);
    return foundFile;
  }
  /**
   * Search entire ZIP for file by exact ID
   */
  async searchZipByFileId(zip, fileId) {
    for (const [path, file] of Object.entries(zip.files)) {
      if (file.dir)
        continue;
      if (path.includes(fileId)) {
        return file;
      }
    }
    return null;
  }
  /**
   * Generate local path for ChatGPT attachment using attachmentFolder setting
   */
  generateLocalPath(conversationId, attachment) {
    const category = this.categorizeFile(attachment);
    const safeFileName = this.sanitizeFileName(attachment.fileName);
    return `${this.plugin.settings.attachmentFolder}/chatgpt/${category}/${safeFileName}`;
  }
  /**
   * Categorize file based on MIME type or extension
   */
  categorizeFile(attachment) {
    if (attachment.fileType) {
      if (attachment.fileType.startsWith("image/"))
        return "images";
      if (attachment.fileType.startsWith("audio/"))
        return "audio";
      if (attachment.fileType.startsWith("video/"))
        return "video";
      if (attachment.fileType === "application/pdf")
        return "documents";
      if (attachment.fileType.includes("text/") || attachment.fileType.includes("markdown"))
        return "documents";
    }
    const ext = this.plugin.getFileService().getFileExtension(attachment.fileName);
    const audioExts = ["wav", "mp3", "ogg", "m4a", "flac"];
    const imageExts = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
    const docExts = ["pdf", "doc", "docx", "txt", "md", "rtf"];
    const videoExts = ["mp4", "avi", "mov", "mkv"];
    if (audioExts.includes(ext))
      return "audio";
    if (imageExts.includes(ext))
      return "images";
    if (docExts.includes(ext))
      return "documents";
    if (videoExts.includes(ext))
      return "video";
    return "files";
  }
  /**
   * Sanitize filename and handle potential conflicts
   */
  sanitizeFileName(fileName) {
    let cleanName = fileName.replace(/[<>:"\/\\|?*]/g, "_").replace(/\s+/g, "_").trim();
    return cleanName;
  }
  /**
   * Clear ZIP file cache (call between different ZIP files)
   */
  clearCache() {
    this.zipFileCache.clear();
  }
  /**
   * Get attachment processing statistics
   */
  getStatistics(attachments) {
    return {
      total: attachments.length,
      found: attachments.filter((a) => {
        var _a, _b;
        return ((_a = a.status) == null ? void 0 : _a.found) && ((_b = a.status) == null ? void 0 : _b.processed);
      }).length,
      missing: attachments.filter((a) => {
        var _a, _b;
        return !((_a = a.status) == null ? void 0 : _a.found) && ((_b = a.status) == null ? void 0 : _b.reason) === "missing_from_export";
      }).length,
      failed: attachments.filter((a) => {
        var _a;
        return ((_a = a.status) == null ? void 0 : _a.reason) === "extraction_failed";
      }).length
    };
  }
};

// src/providers/chatgpt/chatgpt-report-naming.ts
var ChatGPTReportNamingStrategy = class {
  /**
   * Extract date prefix from ChatGPT ZIP filename
   * Examples:
   * - "3b00abafb9222a9580aa7cbb198166ed0c61634222cce9571bb079a2886aeed5-2025-04-25-14-40-42-ff19c2fd898d44d9bc5945ee80c199ca.zip"
   * - "chatgpt-export-2025-04-25.zip"
   * - "conversations-2025-04-25-14-40-42.zip"
   */
  extractReportPrefix(zipFileName) {
    const now = new Date();
    const importYear = now.getFullYear();
    const importMonth = String(now.getMonth() + 1).padStart(2, "0");
    const importDay = String(now.getDate()).padStart(2, "0");
    const importDate = `${importYear}.${importMonth}.${importDay}`;
    const dateRegex = /(\d{4})-(\d{2})-(\d{2})/;
    const match = zipFileName.match(dateRegex);
    let archiveDate;
    if (match) {
      const [, year, month, day] = match;
      archiveDate = `${year}.${month}.${day}`;
    } else {
      archiveDate = importDate;
    }
    return `imported-${importDate}-archive-${archiveDate}`;
  }
  /**
   * Get ChatGPT provider name
   */
  getProviderName() {
    return "chatgpt";
  }
  getProviderSpecificColumn() {
    return {
      header: "Attachments",
      getValue: (adapter, chat) => {
        let attachmentCount = 0;
        if (chat.mapping) {
          Object.values(chat.mapping).forEach((node) => {
            var _a, _b;
            if ((_b = (_a = node.message) == null ? void 0 : _a.metadata) == null ? void 0 : _b.attachments) {
              attachmentCount += node.message.metadata.attachments.length;
            }
          });
        }
        return attachmentCount;
      }
    };
  }
};

// src/providers/chatgpt/chatgpt-adapter.ts
init_utils();
var ChatGPTAdapter = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.attachmentExtractor = new ChatGPTAttachmentExtractor(plugin, plugin.logger);
    this.reportNamingStrategy = new ChatGPTReportNamingStrategy();
  }
  detect(rawConversations) {
    if (rawConversations.length === 0)
      return false;
    const sample = rawConversations[0];
    return !!(sample.mapping && sample.create_time && sample.update_time && sample.title);
  }
  getId(chat) {
    return chat.id || "";
  }
  getTitle(chat) {
    return chat.title || "Untitled";
  }
  getCreateTime(chat) {
    return chat.create_time || 0;
  }
  getUpdateTime(chat) {
    return chat.update_time || 0;
  }
  convertChat(chat) {
    return ChatGPTConverter.convertChat(chat);
  }
  convertMessages(messages, conversationId) {
    return ChatGPTConverter.convertMessages(messages, conversationId);
  }
  getProviderName() {
    return "chatgpt";
  }
  getNewMessages(chat, existingMessageIds) {
    var _a;
    const newMessages = [];
    for (const messageObj of Object.values(chat.mapping)) {
      if ((messageObj == null ? void 0 : messageObj.id) && !existingMessageIds.includes(messageObj.id)) {
        const message = messageObj.message;
        if (!message)
          continue;
        if (((_a = message.author) == null ? void 0 : _a.role) === "tool" && this.hasRealDalleImage(message)) {
          const dalleMessage = this.createDalleAssistantMessage(message);
          if (dalleMessage) {
            newMessages.push(dalleMessage);
          }
        } else if (this.shouldIncludeMessage(message)) {
          newMessages.push(message);
        }
      }
    }
    return newMessages;
  }
  async processMessageAttachments(messages, conversationId, zip) {
    const processedMessages = [];
    for (const message of messages) {
      if (message.attachments && message.attachments.length > 0) {
        const processedAttachments = await this.attachmentExtractor.extractAttachments(
          zip,
          conversationId,
          message.attachments
        );
        processedMessages.push({
          ...message,
          attachments: processedAttachments
        });
      } else {
        processedMessages.push(message);
      }
    }
    return processedMessages;
  }
  getReportNamingStrategy() {
    return this.reportNamingStrategy;
  }
  getProviderName() {
    return "chatgpt";
  }
  /**
   * Check if message contains REAL DALL-E image (not user upload)
   */
  hasRealDalleImage(message) {
    var _a;
    if (!((_a = message.content) == null ? void 0 : _a.parts) || !Array.isArray(message.content.parts)) {
      return false;
    }
    return message.content.parts.some((part) => {
      var _a2;
      if (typeof part !== "object" || part === null)
        return false;
      return part.content_type === "image_asset_pointer" && part.asset_pointer && ((_a2 = part.metadata) == null ? void 0 : _a2.dalle) && part.metadata.dalle !== null;
    });
  }
  /**
   * Create Assistant (DALL-E) message from tool message
   */
  createDalleAssistantMessage(toolMessage) {
    var _a, _b;
    if (!((_a = toolMessage.content) == null ? void 0 : _a.parts) || !Array.isArray(toolMessage.content.parts)) {
      return null;
    }
    const attachments = [];
    for (const part of toolMessage.content.parts) {
      if (typeof part === "object" && part !== null) {
        if (part.content_type === "image_asset_pointer" && part.asset_pointer && ((_b = part.metadata) == null ? void 0 : _b.dalle) && part.metadata.dalle !== null) {
          let fileId = part.asset_pointer;
          if (fileId.includes("://")) {
            fileId = fileId.split("://")[1];
          }
          const genId = part.metadata.dalle.gen_id || "unknown";
          const width = part.width || 1024;
          const height = part.height || 1024;
          const fileName = `dalle_${genId}_${width}x${height}.png`;
          const dalleAttachment = {
            fileName,
            fileSize: part.size_bytes,
            fileType: "image/png",
            fileId,
            extractedContent: part.metadata.dalle.prompt
          };
          attachments.push(dalleAttachment);
        }
      }
    }
    if (attachments.length === 0) {
      return null;
    }
    return {
      id: toolMessage.id || "",
      author: { role: "assistant" },
      content: {
        parts: ["Image g\xE9n\xE9r\xE9e par DALL-E"],
        content_type: "text"
      },
      create_time: toolMessage.create_time || 0,
      attachments
    };
  }
  /**
   * Determine if a message should be included - same logic as ChatGPTConverter
   */
  shouldIncludeMessage(message) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (!message || !message.author) {
      return false;
    }
    if (message.author.role === "system") {
      return false;
    }
    if (message.author.role === "tool") {
      return false;
    }
    if (((_a = message.metadata) == null ? void 0 : _a.is_visually_hidden_from_conversation) === true) {
      return false;
    }
    if (((_b = message.metadata) == null ? void 0 : _b.is_user_system_message) === true) {
      return false;
    }
    if (((_c = message.content) == null ? void 0 : _c.content_type) === "user_editable_context") {
      return false;
    }
    if (message.author.role === "assistant") {
      if (((_d = message.content) == null ? void 0 : _d.parts) && Array.isArray(message.content.parts) && message.content.parts.every(
        (part) => typeof part === "string" && part.trim() === ""
      )) {
        return false;
      }
      if (((_e = message.content) == null ? void 0 : _e.parts) && Array.isArray(message.content.parts) && message.content.parts.length === 1 && typeof message.content.parts[0] === "string") {
        const content = message.content.parts[0].trim();
        if (content.startsWith("{") && content.includes('"prompt"')) {
          return false;
        }
      }
      const excludedContentTypes = ["code", "system_error", "execution_output"];
      if (((_f = message.content) == null ? void 0 : _f.content_type) && excludedContentTypes.includes(message.content.content_type)) {
        return false;
      }
      if (((_g = message.content) == null ? void 0 : _g.content_type) === "multimodal_text") {
        if (((_h = message.content) == null ? void 0 : _h.parts) && Array.isArray(message.content.parts)) {
          const hasTextContent = message.content.parts.some((part) => {
            if (typeof part === "string" && part.trim() !== "") {
              return true;
            }
            if (typeof part === "object" && part !== null && "text" in part) {
              return typeof part.text === "string" && part.text.trim() !== "";
            }
            return false;
          });
          if (!hasTextContent) {
            return false;
          }
        }
      }
    }
    if (message.author.role === "user") {
      const excludedContentTypes = ["user_editable_context"];
      if (((_i = message.content) == null ? void 0 : _i.content_type) && excludedContentTypes.includes(message.content.content_type)) {
        return false;
      }
    }
    return isValidMessage(message);
  }
};

// src/providers/claude/claude-converter.ts
var ClaudeConverter = class {
  static setPlugin(plugin) {
    this.plugin = plugin;
  }
  static async convertChat(chat) {
    const createTime = chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0;
    const messages = await this.convertMessages(chat.chat_messages, chat.uuid, chat.name, createTime);
    return {
      id: chat.uuid,
      title: chat.name || "Untitled",
      createTime: chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0,
      updateTime: chat.updated_at ? Math.floor(new Date(chat.updated_at).getTime() / 1e3) : 0,
      messages,
      provider: "claude",
      conversationUrl: `https://claude.ai/chat/${chat.uuid}`,
      model: chat.model || "claude-3",
      summary: chat.summary || ""
    };
  }
  static async convertMessages(messages, conversationId, conversationTitle, conversationCreateTime) {
    const standardMessages = [];
    if (!messages || messages.length === 0) {
      return standardMessages;
    }
    const allArtifacts = [];
    for (let msgIndex = 0; msgIndex < messages.length; msgIndex++) {
      const message = messages[msgIndex];
      if (message.content) {
        for (let blockIndex = 0; blockIndex < message.content.length; blockIndex++) {
          const block = message.content[blockIndex];
          if (block.type === "tool_use" && block.name === "artifacts" && block.input) {
            const command = block.input.command || "create";
            const versionUuid = block.input.version_uuid;
            if (command !== "view" && versionUuid) {
              allArtifacts.push({
                artifact: block.input,
                messageIndex: msgIndex,
                blockIndex
              });
            }
          }
        }
      }
    }
    const artifactVersionMap = await this.processAllArtifacts(allArtifacts, conversationId, conversationTitle, conversationCreateTime);
    for (const message of messages) {
      if (!this.shouldIncludeMessage(message)) {
        continue;
      }
      const { text, attachments } = await this.processContentBlocksForDisplay(
        message.content,
        artifactVersionMap,
        conversationId,
        conversationTitle,
        conversationCreateTime
      );
      const fileAttachments = this.processFileAttachments(message.files);
      const standardMessage = {
        id: message.uuid,
        role: message.sender === "human" ? "user" : "assistant",
        content: text || message.text || "",
        timestamp: Math.floor(new Date(message.created_at).getTime() / 1e3),
        attachments: [...attachments, ...fileAttachments]
      };
      standardMessages.push(standardMessage);
    }
    return this.sortMessagesByTimestamp(standardMessages);
  }
  static shouldIncludeMessage(message) {
    if (message.sender === "human" || message.sender === "assistant") {
      if (!message.text && (!message.content || message.content.length === 0)) {
        return false;
      }
      return true;
    }
    return false;
  }
  /**
   * Sort messages by timestamp with UUID as secondary sort for chronological order
   */
  static sortMessagesByTimestamp(messages) {
    if (messages.length <= 1)
      return messages;
    return messages.sort((a, b) => {
      if (a.timestamp !== b.timestamp) {
        return a.timestamp - b.timestamp;
      }
      return a.id.localeCompare(b.id);
    });
  }
  /**
   * Process ALL artifacts from entire conversation and create files
   */
  static async processAllArtifacts(allArtifacts, conversationId, conversationTitle, conversationCreateTime) {
    const artifactVersionMap = /* @__PURE__ */ new Map();
    const versionCounters = /* @__PURE__ */ new Map();
    const artifactContents = /* @__PURE__ */ new Map();
    const artifactLanguages = /* @__PURE__ */ new Map();
    console.log(`Claude converter: Processing ${allArtifacts.length} artifacts from entire conversation`);
    for (const { artifact } of allArtifacts) {
      const artifactId = artifact.id || "unknown";
      const command = artifact.command || "create";
      const currentVersion = (versionCounters.get(artifactId) || 0) + 1;
      versionCounters.set(artifactId, currentVersion);
      let finalContent = "";
      if (command === "create" || command === "rewrite") {
        finalContent = artifact.content || "";
        artifactContents.set(artifactId, finalContent);
        const detectedLanguage = this.detectLanguageFromContent(finalContent, artifact.type);
        artifactLanguages.set(artifactId, detectedLanguage);
      } else if (command === "update") {
        const previousContent = artifactContents.get(artifactId) || "";
        if (artifact.old_str && artifact.new_str) {
          finalContent = previousContent.replace(artifact.old_str, artifact.new_str);
        } else if (artifact.content && artifact.content.length > 0) {
          finalContent = artifact.content;
        } else {
          finalContent = previousContent;
        }
        artifactContents.set(artifactId, finalContent);
      }
      console.log(`Saving ${artifactId} v${currentVersion} (${command}, ${finalContent.length} chars)`);
      try {
        const storedLanguage = artifactLanguages.get(artifactId);
        const languageToUse = storedLanguage || this.detectLanguageFromContent(finalContent, artifact.type);
        await this.saveSingleArtifactVersionWithContent(
          artifactId,
          artifact,
          currentVersion,
          finalContent,
          conversationId,
          conversationTitle,
          conversationCreateTime,
          languageToUse
        );
        artifactVersionMap.set(artifact.version_uuid, {
          versionNumber: currentVersion,
          title: artifact.title || artifactId
        });
      } catch (error) {
        console.error(`Failed to save ${artifactId} v${currentVersion}:`, error);
      }
    }
    return artifactVersionMap;
  }
  /**
   * Process content blocks for display (with artifact links)
   */
  static async processContentBlocksForDisplay(contentBlocks, artifactVersionMap, conversationId, conversationTitle, conversationCreateTime) {
    const textParts = [];
    const attachments = [];
    if (!contentBlocks || contentBlocks.length === 0) {
      return { text: "", attachments: [] };
    }
    for (const block of contentBlocks) {
      switch (block.type) {
        case "text":
          if (block.text) {
            textParts.push(block.text);
          }
          break;
        case "thinking":
          break;
        case "tool_use":
          if (block.name === "artifacts" && block.input) {
            const command = block.input.command || "create";
            const versionUuid = block.input.version_uuid;
            if (command === "view") {
              break;
            }
            if (versionUuid && artifactVersionMap.has(versionUuid)) {
              const versionInfo = artifactVersionMap.get(versionUuid);
              const artifactId = block.input.id || "unknown";
              const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
              const versionFile = `${conversationFolder}/${artifactId}_v${versionInfo.versionNumber}`;
              const specificLink = `>[!${this.CALLOUTS.ARTIFACT}] **${versionInfo.title}** v${versionInfo.versionNumber}
> \u{1F3A8} [[${versionFile}|View Artifact]]`;
              textParts.push(specificLink);
            }
          } else if (block.name === "web_search") {
            break;
          } else if (block.name && block.input) {
            const code = block.input.code || JSON.stringify(block.input, null, 2);
            textParts.push(`**[Tool: ${block.name}]**
\`\`\`
${code}
\`\`\``);
          }
          break;
        case "tool_result":
          break;
      }
    }
    return {
      text: textParts.join("\n\n"),
      attachments
    };
  }
  static async processContentBlocks(contentBlocks, conversationId, conversationTitle, conversationCreateTime, versionCounters, artifactSummaries) {
    const textParts = [];
    const attachments = [];
    const artifactVersionsMap = /* @__PURE__ */ new Map();
    if (!contentBlocks || contentBlocks.length === 0) {
      return { text: "", attachments: [] };
    }
    for (const block of contentBlocks) {
      if (block.type === "tool_use" && block.name === "artifacts" && block.input) {
        const artifactId = block.input.id || "unknown";
        const content = block.input.content || "";
        const command = block.input.command || "create";
        const versionUuid = block.input.version_uuid;
        if (command === "update" && content.length === 0 || command === "view") {
          continue;
        }
        const isSignificant = command === "create" || command === "rewrite" || command === "update" && content.length > 100;
        if (isSignificant && versionUuid) {
          console.log(`Claude converter: Found significant artifact version - ID: ${artifactId}, Command: ${command}, Content length: ${content.length}, UUID: ${versionUuid}`);
          if (!artifactVersionsMap.has(artifactId)) {
            artifactVersionsMap.set(artifactId, []);
          }
          artifactVersionsMap.get(artifactId).push(block.input);
        } else {
          console.log(`Claude converter: Skipped artifact - ID: ${artifactId}, Command: ${command}, Content length: ${content.length}, Significant: ${isSignificant}, Has UUID: ${!!versionUuid}`);
        }
      }
    }
    if (!versionCounters)
      versionCounters = /* @__PURE__ */ new Map();
    if (!artifactSummaries)
      artifactSummaries = /* @__PURE__ */ new Map();
    const artifactContents = /* @__PURE__ */ new Map();
    for (const block of contentBlocks) {
      switch (block.type) {
        case "text":
          if (block.text) {
            textParts.push(block.text);
          }
          break;
        case "thinking":
          break;
        case "tool_use":
          if (block.name === "repl" || block.name === "str_replace_editor" || block.name === "bash") {
            break;
          }
          if (block.name === "artifacts" && block.input) {
            const artifactId = block.input.id || "unknown";
            const command = block.input.command || "create";
            const versionUuid = block.input.version_uuid;
            if (command === "view") {
              break;
            }
            if (versionUuid) {
              const currentVersion = (versionCounters.get(artifactId) || 0) + 1;
              versionCounters.set(artifactId, currentVersion);
              let finalContent = "";
              if (command === "create" || command === "rewrite") {
                finalContent = block.input.content || "";
                artifactContents.set(artifactId, finalContent);
              } else if (command === "update") {
                const previousContent = artifactContents.get(artifactId) || "";
                if (block.input.old_str && block.input.new_str) {
                  finalContent = previousContent.replace(block.input.old_str, block.input.new_str);
                } else if (block.input.content && block.input.content.length > 0) {
                  finalContent = block.input.content;
                } else {
                  finalContent = previousContent;
                }
                artifactContents.set(artifactId, finalContent);
              }
              console.log(`Processing ${artifactId} v${currentVersion} (${command}, ${finalContent.length} chars)`);
              try {
                await this.saveSingleArtifactVersionWithContent(
                  artifactId,
                  block.input,
                  currentVersion,
                  finalContent,
                  conversationId,
                  conversationTitle,
                  conversationCreateTime
                );
                const title = block.input.title || artifactId;
                const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
                const versionFile = `${conversationFolder}/${artifactId}_v${currentVersion}`;
                const specificLink = `>[!${this.CALLOUTS.ARTIFACT}] **${title}** v${currentVersion}
> \u{1F3A8} [[${versionFile}|View Artifact]]`;
                textParts.push(specificLink);
              } catch (error) {
                console.error(`Failed to save ${artifactId} v${currentVersion}:`, error);
                textParts.push(`>[!${this.CALLOUTS.ARTIFACT}] **${block.input.title || artifactId}** v${currentVersion}
> \u274C Error saving artifact`);
              }
            }
          } else if (block.name === "web_search") {
            break;
          } else if (block.name && block.input) {
            const code = block.input.code || JSON.stringify(block.input, null, 2);
            textParts.push(`**[Tool: ${block.name}]**
\`\`\`
${code}
\`\`\``);
          }
          break;
        case "tool_result":
          break;
      }
    }
    return {
      text: textParts.join("\n\n"),
      attachments
    };
  }
  static processFileAttachments(files) {
    const attachments = [];
    if (!files || files.length === 0) {
      return attachments;
    }
    for (const file of files) {
      if (file && file.file_name) {
        attachments.push({
          fileName: file.file_name,
          fileSize: 0,
          // Size not provided in Claude export
          fileType: this.getFileTypeFromName(file.file_name),
          fileId: file.file_name,
          // Use filename as ID
          extractedContent: ""
        });
      }
    }
    return attachments;
  }
  static getFileTypeFromName(fileName) {
    var _a;
    const extension = (_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (extension) {
      case "png":
      case "jpg":
      case "jpeg":
      case "gif":
      case "webp":
        return `image/${extension}`;
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "md":
        return "text/markdown";
      case "json":
        return "application/json";
      default:
        return "application/octet-stream";
    }
  }
  /**
   * Save a single artifact version with computed content
   */
  static async saveSingleArtifactVersionWithContent(artifactId, artifactData, versionNumber, finalContent, conversationId, conversationTitle, conversationCreateTime, forcedLanguage) {
    if (!this.plugin) {
      throw new Error("Plugin not available");
    }
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
    const folderResult = await ensureFolderExists2(conversationFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create artifacts folder: ${folderResult.error}`);
    }
    const safeArtifactId = artifactId.replace(/[\/\\:*?"<>|]/g, "_");
    const fileName = `${safeArtifactId}_v${versionNumber}.md`;
    const filePath = `${conversationFolder}/${fileName}`;
    const shouldSkip = await this.shouldSkipArtifactVersion(filePath, artifactData.version_uuid);
    if (shouldSkip) {
      return;
    }
    await this.saveIndividualArtifactVersion(
      artifactData,
      filePath,
      versionNumber,
      finalContent,
      conversationId,
      conversationTitle,
      conversationCreateTime,
      forcedLanguage
    );
  }
  /**
   * Save a single artifact version (legacy method)
   */
  static async saveSingleArtifactVersion(artifactId, artifactData, versionNumber, conversationId, conversationTitle, conversationCreateTime) {
    if (!this.plugin) {
      throw new Error("Plugin not available");
    }
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
    const folderResult = await ensureFolderExists2(conversationFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create artifacts folder: ${folderResult.error}`);
    }
    const safeArtifactId = artifactId.replace(/[\/\\:*?"<>|]/g, "_");
    const fileName = `${safeArtifactId}_v${versionNumber}.md`;
    const filePath = `${conversationFolder}/${fileName}`;
    const shouldSkip = await this.shouldSkipArtifactVersion(filePath, artifactData.version_uuid);
    if (shouldSkip) {
      return;
    }
    await this.saveIndividualArtifactVersion(
      artifactData,
      filePath,
      versionNumber,
      artifactData.content || "",
      conversationId,
      conversationTitle,
      conversationCreateTime,
      void 0
      // No forced language for legacy method
    );
  }
  /**
   * Create artifact summary for conversation
   */
  static createArtifactSummary(artifactId, info, conversationId) {
    const title = info.title || artifactId;
    const totalVersions = info.totalVersions || 1;
    const latestVersion = info.latestVersion || 1;
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
    const latestFile = `${conversationFolder}/${artifactId}_v${latestVersion}`;
    let summary = `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}**`;
    if (totalVersions > 1) {
      summary += ` (${totalVersions} versions)`;
    }
    summary += `

\u{1F4CE} **[[${latestFile}|View Latest Version]]**`;
    if (totalVersions > 1) {
      summary += ` | **[[${conversationFolder}/|All Versions]]**`;
    }
    summary += `</div>`;
    return summary;
  }
  /**
   * Save ALL versions of an artifact (legacy method)
   */
  static async saveAllArtifactVersions(artifactId, versions, conversationId, conversationTitle, conversationCreateTime) {
    var _a, _b, _c;
    if (!this.plugin) {
      console.error("Claude converter: Plugin not available for artifact saving");
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_a = versions[0]) == null ? void 0 : _a.title) || artifactId}** (Error: Plugin not available)</div>`;
    }
    if (versions.length === 0) {
      console.error("Claude converter: No versions provided for artifact", artifactId);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${artifactId}** (Error: No versions found)</div>`;
    }
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
    const folderResult = await ensureFolderExists2(conversationFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      console.error("Claude converter: Failed to create artifacts folder", folderResult.error);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_b = versions[0]) == null ? void 0 : _b.title) || artifactId}** (Error: Could not create folder)</div>`;
    }
    const savedVersions = [];
    let latestVersion = "";
    let currentContent = "";
    for (let i = 0; i < versions.length; i++) {
      const version = versions[i];
      const versionNumber = i + 1;
      const fileName = `${artifactId}_v${versionNumber}.md`;
      const filePath = `${conversationFolder}/${fileName}`;
      try {
        const shouldSkip = await this.shouldSkipArtifactVersion(filePath, version.version_uuid);
        if (shouldSkip) {
          console.log(`Skipping existing artifact version: ${filePath}`);
          savedVersions.push(filePath);
          latestVersion = filePath;
          if (version.command === "create" || version.command === "rewrite") {
            currentContent = version.content || "";
          }
          continue;
        }
        let versionContent = "";
        if (version.command === "create" || version.command === "rewrite") {
          versionContent = version.content || "";
          currentContent = versionContent;
        } else if (version.command === "update") {
          if (version.content && version.content.length > 0) {
            versionContent = version.content;
            currentContent = versionContent;
          } else {
            versionContent = currentContent;
          }
        }
        console.log(`Saving artifact version ${versionNumber}: ${filePath} (${versionContent.length} chars)`);
        await this.saveIndividualArtifactVersion(
          version,
          filePath,
          versionNumber,
          versionContent,
          conversationId,
          conversationTitle,
          conversationCreateTime,
          void 0
          // No forced language for legacy method
        );
        savedVersions.push(filePath);
        latestVersion = filePath;
      } catch (error) {
        console.error(`Failed to save artifact version ${versionNumber} to ${filePath}:`, error);
      }
    }
    if (savedVersions.length === 0) {
      console.error("Claude converter: No versions were saved for artifact", artifactId);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_c = versions[0]) == null ? void 0 : _c.title) || artifactId}** (Error: No versions could be saved)</div>`;
    }
    return this.formatArtifactSummary(versions[0], savedVersions, latestVersion, conversationFolder);
  }
  /**
   * Save all versions of an artifact and return summary for conversation (legacy method)
   */
  static async saveArtifactVersions(artifactId, versions, conversationId, conversationTitle, conversationCreateTime) {
    var _a, _b, _c;
    if (!this.plugin) {
      console.error("Claude converter: Plugin not available for artifact saving");
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_a = versions[0]) == null ? void 0 : _a.title) || artifactId}** (Error: Plugin not available)</div>`;
    }
    if (versions.length === 0) {
      console.error("Claude converter: No versions provided for artifact", artifactId);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${artifactId}** (Error: No versions found)</div>`;
    }
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const conversationFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts/${conversationId}`;
    const folderResult = await ensureFolderExists2(conversationFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      console.error("Claude converter: Failed to create artifacts folder", folderResult.error);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_b = versions[0]) == null ? void 0 : _b.title) || artifactId}** (Error: Could not create folder)</div>`;
    }
    const savedVersions = [];
    let latestVersion = "";
    for (let i = 0; i < versions.length; i++) {
      const version = versions[i];
      const versionNumber = i + 1;
      const safeArtifactId = artifactId.replace(/[\/\\:*?"<>|]/g, "_");
      const fileName = `${safeArtifactId}_v${versionNumber}.md`;
      const filePath = `${conversationFolder}/${fileName}`;
      try {
        const shouldSkip = await this.shouldSkipArtifactVersion(filePath, version.version_uuid);
        if (shouldSkip) {
          savedVersions.push(filePath);
          latestVersion = filePath;
          continue;
        }
        await this.saveArtifactVersion(version, filePath, versionNumber, conversationId, conversationTitle, conversationCreateTime);
        savedVersions.push(filePath);
        latestVersion = filePath;
      } catch (error) {
        console.error(`Failed to save artifact version ${versionNumber} to ${filePath}:`, error);
      }
    }
    if (savedVersions.length === 0) {
      console.error("Claude converter: No versions were saved for artifact", artifactId);
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${((_c = versions[0]) == null ? void 0 : _c.title) || artifactId}** (Error: No versions could be saved)</div>`;
    }
    return this.formatArtifactSummary(versions[0], savedVersions, latestVersion, conversationFolder);
  }
  /**
   * Format artifact summary for conversation display
   */
  static formatArtifactSummary(firstVersion, savedVersions, latestVersion, conversationFolder) {
    const title = (firstVersion == null ? void 0 : firstVersion.title) || "Untitled Artifact";
    const versionCount = savedVersions.length;
    if (!latestVersion) {
      console.error("Claude converter: No latest version available for artifact summary");
      return `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}** (Error: No accessible version)</div>`;
    }
    let formattedContent = `<div class="nexus-artifact-box">**\u{1F3A8} Artifact: ${title}**`;
    if (versionCount > 1) {
      formattedContent += ` (${versionCount} versions)`;
    }
    const latestVersionLink = latestVersion.replace(/\.md$/, "");
    formattedContent += `

\u{1F4CE} **[[${latestVersionLink}|View Latest Version]]**`;
    if (versionCount > 1) {
      formattedContent += ` | **[[${conversationFolder}/|All Versions]]**`;
    }
    formattedContent += `</div>`;
    return formattedContent;
  }
  /**
   * Format Claude artifacts as links to separate files only (legacy method for single artifacts)
   */
  static async formatArtifact(artifactInput, conversationId, conversationTitle, conversationCreateTime) {
    const title = artifactInput.title || "Untitled Artifact";
    let language = artifactInput.language || "text";
    const command = artifactInput.command || "create";
    const artifactId = artifactInput.id || "unknown";
    const content = artifactInput.content || "";
    if ((language.toLowerCase() === "text" || !language || language === "undefined") && content) {
      const detectedLanguage = this.detectLanguageFromContent(content, artifactInput.type);
      if (detectedLanguage !== "text") {
        language = detectedLanguage;
      }
    }
    let formattedContent = `<div class="nexus-artifact-box">

**\u{1F3A8} Artifact: ${title}**

`;
    if (command === "edit") {
      formattedContent += `*[Artifact edited]*

`;
    }
    formattedContent += `> **Language:** ${language}`;
    if (artifactInput.language !== language) {
      formattedContent += ` (detected from content, original: ${artifactInput.language})`;
    }
    formattedContent += `
`;
    formattedContent += `> **Type:** ${artifactInput.type || "code"}
`;
    formattedContent += `> **ID:** ${artifactId}

`;
    if (content && this.plugin) {
      try {
        const filePath = await this.saveArtifactToFile(artifactId, title, language, content, conversationId, conversationTitle, conversationCreateTime);
        formattedContent += `\u{1F4CE} **[View Artifact](${filePath})**

`;
      } catch (error) {
        formattedContent += `\u274C **Error saving artifact:** ${error instanceof Error ? error.message : "Unknown error"}

`;
      }
    }
    formattedContent += `</div>

`;
    return formattedContent;
  }
  /**
   * Save a single artifact version with specific content
   */
  static async saveIndividualArtifactVersion(artifactInput, filePath, versionNumber, versionContent, conversationId, conversationTitle, conversationCreateTime, forcedLanguage) {
    const title = artifactInput.title || "Untitled Artifact";
    let language = artifactInput.language || "text";
    const command = artifactInput.command || "create";
    const artifactId = artifactInput.id || "unknown";
    const versionUuid = artifactInput.version_uuid;
    if (forcedLanguage) {
      language = forcedLanguage;
    } else if ((language.toLowerCase() === "text" || !language || language === "undefined") && versionContent) {
      const detectedLanguage = this.detectLanguageFromContent(versionContent, artifactInput.type);
      if (detectedLanguage !== "text") {
        language = detectedLanguage;
      }
    }
    let conversationLink = "";
    if (conversationId && conversationTitle && conversationCreateTime) {
      const createDate = new Date(conversationCreateTime * 1e3);
      const year = createDate.getFullYear();
      const month = String(createDate.getMonth() + 1).padStart(2, "0");
      const { generateConversationFileName: generateConversationFileName2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
      const fileName = generateConversationFileName2(
        conversationTitle,
        conversationCreateTime,
        this.plugin.settings.addDatePrefix,
        this.plugin.settings.dateFormat
      );
      const conversationPath = `${this.plugin.settings.archiveFolder}/claude/${year}/${month}/${fileName}`;
      conversationLink = `[[${conversationPath}|${conversationTitle}]]`;
    }
    let markdownContent = `---
nexus: nexus-ai-chat-importer
plugin_version: ${this.plugin.manifest.version}
provider: claude
artifact_id: ${artifactId}
version_uuid: ${versionUuid}
version_number: ${versionNumber}
command: ${command}
conversation_id: ${conversationId || "unknown"}
format: ${language}
aliases: ["${title}", "${artifactId}_v${versionNumber}"]
---

# ${title} (Version ${versionNumber})

**Type:** Claude Artifact
**Language:** ${language}`;
    if (artifactInput.language !== language) {
      markdownContent += ` (detected from content, original: ${artifactInput.language})`;
    }
    markdownContent += `
**Command:** ${command}
**Version:** ${versionNumber}
**ID:** ${artifactId}
**UUID:** ${versionUuid}`;
    if (conversationLink) {
      markdownContent += `
**Conversation:** ${conversationLink}`;
    }
    markdownContent += `

## Content

`;
    if (language.toLowerCase() === "markdown") {
      markdownContent += versionContent;
    } else {
      markdownContent += `\`\`\`${language}
${versionContent}
\`\`\``;
    }
    try {
      await this.plugin.app.vault.create(filePath, markdownContent);
    } catch (error) {
      console.error(`Failed to create artifact file ${filePath}:`, error);
      throw error;
    }
  }
  /**
   * Save a single artifact version (legacy method)
   */
  static async saveArtifactVersion(artifactInput, filePath, versionNumber, conversationId, conversationTitle, conversationCreateTime) {
    const title = artifactInput.title || "Untitled Artifact";
    let language = artifactInput.language || "text";
    const command = artifactInput.command || "create";
    const artifactId = artifactInput.id || "unknown";
    const content = artifactInput.content || "";
    const versionUuid = artifactInput.version_uuid;
    if ((language.toLowerCase() === "text" || !language || language === "undefined") && content) {
      const detectedLanguage = this.detectLanguageFromContent(content, artifactInput.type);
      if (detectedLanguage !== "text") {
        language = detectedLanguage;
      }
    }
    let conversationLink = "";
    if (conversationId && conversationTitle && conversationCreateTime) {
      const createDate = new Date(conversationCreateTime * 1e3);
      const year = createDate.getFullYear();
      const month = String(createDate.getMonth() + 1).padStart(2, "0");
      const { generateConversationFileName: generateConversationFileName2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
      const fileName = generateConversationFileName2(
        conversationTitle,
        conversationCreateTime,
        this.plugin.settings.addDatePrefix,
        this.plugin.settings.dateFormat
      );
      const conversationPath = `${this.plugin.settings.archiveFolder}/claude/${year}/${month}/${fileName}`;
      conversationLink = `[[${conversationPath}|${conversationTitle}]]`;
    }
    let markdownContent = `---
nexus: nexus-ai-chat-importer
plugin_version: ${this.plugin.manifest.version}
provider: claude
artifact_id: ${artifactId}
version_uuid: ${versionUuid}
version_number: ${versionNumber}
command: ${command}
conversation_id: ${conversationId || "unknown"}
format: ${language}
aliases: ["${title}", "${artifactId}_v${versionNumber}"]
---

# ${title} (Version ${versionNumber})

**Type:** Claude Artifact
**Language:** ${language}`;
    if (artifactInput.language !== language) {
      markdownContent += ` (detected from content, original: ${artifactInput.language})`;
    }
    markdownContent += `
**Command:** ${command}
**Version:** ${versionNumber}
**ID:** ${artifactId}
**UUID:** ${versionUuid}`;
    if (conversationLink) {
      markdownContent += `
**Conversation:** ${conversationLink}`;
    }
    markdownContent += `

## Content

`;
    if (language.toLowerCase() === "markdown") {
      markdownContent += content;
    } else {
      markdownContent += `\`\`\`${language}
${content}
\`\`\``;
    }
    try {
      await this.plugin.app.vault.create(filePath, markdownContent);
    } catch (error) {
      console.error(`Failed to create artifact file ${filePath}:`, error);
      throw error;
    }
  }
  /**
   * Save artifact as markdown note in attachments/artifacts/ folder (legacy method)
   */
  static async saveArtifactToFile(artifactId, title, language, content, conversationId, conversationTitle, conversationCreateTime) {
    const safeTitle = title.replace(/[^a-zA-Z0-9\-_]/g, "_");
    const fileName = `${safeTitle}_${artifactId}.md`;
    const artifactFolder = `${this.plugin.settings.attachmentFolder}/claude/artifacts`;
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const folderResult = await ensureFolderExists2(artifactFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create artifacts folder: ${folderResult.error}`);
    }
    const filePath = `${artifactFolder}/${fileName}`;
    let conversationLink = "";
    if (conversationId && conversationTitle && conversationCreateTime) {
      const createDate = new Date(conversationCreateTime * 1e3);
      const year = createDate.getFullYear();
      const month = String(createDate.getMonth() + 1).padStart(2, "0");
      const { generateConversationFileName: generateConversationFileName2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
      const fileName2 = generateConversationFileName2(
        conversationTitle,
        conversationCreateTime,
        this.plugin.settings.addDatePrefix,
        this.plugin.settings.dateFormat
      );
      const conversationPath = `${this.plugin.settings.archiveFolder}/claude/${year}/${month}/${fileName2}`;
      conversationLink = `[[${conversationPath}|${conversationTitle}]]`;
    }
    let markdownContent = `---
nexus: nexus-ai-chat-importer
plugin_version: ${this.plugin.manifest.version}
provider: claude
aliases: ["${title}", "${artifactId}"]
conversation_id: ${conversationId || "unknown"}
format: ${language}
---

# ${title}

**Type:** Claude Artifact
**Language:** ${language}
**ID:** ${artifactId}`;
    if (conversationLink) {
      markdownContent += `
**Conversation:** ${conversationLink}`;
    }
    markdownContent += `

## Content

`;
    if (language.toLowerCase() === "markdown") {
      markdownContent += content;
    } else {
      markdownContent += `\`\`\`${language}
${content}
\`\`\``;
    }
    await this.plugin.app.vault.create(filePath, markdownContent);
    return filePath;
  }
  /**
   * Check if we should skip saving this artifact version (already exists)
   */
  static async shouldSkipArtifactVersion(filePath, versionUuid) {
    try {
      const existingFile = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (!existingFile) {
        return false;
      }
      const existingContent = await this.plugin.app.vault.read(existingFile);
      if (existingContent.includes(`version_uuid: ${versionUuid}`)) {
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  /**
   * Determine if we should replace the current artifact with a new one
   * Priority: create > rewrite > update (with content) > view
   */
  static shouldReplaceArtifact(current, candidate) {
    const currentCommand = current.command || "create";
    const candidateCommand = candidate.command || "create";
    const currentContent = (current.content || "").length;
    const candidateContent = (candidate.content || "").length;
    const commandPriority = {
      "create": 4,
      "rewrite": 3,
      "update": 2,
      "view": 1
    };
    const currentPriority = commandPriority[currentCommand] || 1;
    const candidatePriority = commandPriority[candidateCommand] || 1;
    if (candidatePriority > currentPriority) {
      return true;
    }
    if (candidatePriority === currentPriority) {
      return candidateContent > currentContent;
    }
    return false;
  }
  /**
   * Auto-detect language from content and artifact type
   */
  static detectLanguageFromContent(content, artifactType) {
    if (!content || content.trim().length === 0)
      return "text";
    if (artifactType) {
      if (artifactType.includes("react") || artifactType.includes("jsx"))
        return "jsx";
      if (artifactType.includes("vue"))
        return "vue";
      if (artifactType.includes("svelte"))
        return "svelte";
      if (artifactType.includes("html"))
        return "html";
      if (artifactType.includes("css"))
        return "css";
      if (artifactType.includes("json"))
        return "json";
      if (artifactType.includes("xml"))
        return "xml";
      if (artifactType.includes("svg"))
        return "xml";
    }
    const trimmedContent = content.trim();
    if (trimmedContent.startsWith("<?php"))
      return "php";
    if (trimmedContent.startsWith("#!/bin/bash") || trimmedContent.startsWith("#!/bin/sh"))
      return "bash";
    if (trimmedContent.startsWith("<!DOCTYPE html") || trimmedContent.includes("<html"))
      return "html";
    if (trimmedContent.includes("import React") || trimmedContent.includes('from "react"') || trimmedContent.includes("useState") || trimmedContent.includes("useEffect") || trimmedContent.includes("className=") || trimmedContent.includes("jsx")) {
      return "jsx";
    }
    if (trimmedContent.startsWith("{") && trimmedContent.endsWith("}")) {
      try {
        JSON.parse(trimmedContent);
        return "json";
      } catch (e) {
      }
    }
    if (trimmedContent.startsWith("<svg") || trimmedContent.includes("xmlns")) {
      return "xml";
    }
    if (trimmedContent.includes("# ") || trimmedContent.includes("## ") || trimmedContent.includes("**") || trimmedContent.includes("```")) {
      return "markdown";
    }
    if (trimmedContent.includes("def ") || trimmedContent.includes("import ") || trimmedContent.includes("from ") || trimmedContent.includes("class ")) {
      return "python";
    }
    if (trimmedContent.includes("function ") || trimmedContent.includes("const ") || trimmedContent.includes("let ") || trimmedContent.includes("var ") || trimmedContent.includes("=>")) {
      return "javascript";
    }
    if (trimmedContent.includes("{") && trimmedContent.includes(":") && trimmedContent.includes(";") && trimmedContent.includes("}")) {
      return "css";
    }
    if (trimmedContent.toUpperCase().includes("SELECT ") || trimmedContent.toUpperCase().includes("INSERT ") || trimmedContent.toUpperCase().includes("UPDATE ") || trimmedContent.toUpperCase().includes("CREATE TABLE")) {
      return "sql";
    }
    return "text";
  }
  /**
   * Get file extension from language
   */
  static getExtensionFromLanguage(language) {
    switch (language.toLowerCase()) {
      case "python":
        return "py";
      case "javascript":
        return "js";
      case "typescript":
        return "ts";
      case "html":
        return "html";
      case "css":
        return "css";
      case "markdown":
        return "md";
      case "json":
        return "json";
      case "yaml":
        return "yml";
      case "xml":
        return "xml";
      case "sql":
        return "sql";
      case "bash":
        return "sh";
      case "shell":
        return "sh";
      case "php":
        return "php";
      default:
        return "txt";
    }
  }
  /**
   * Count unique artifacts in a conversation (by artifact ID, not versions)
   */
  static countArtifacts(chat) {
    var _a;
    const uniqueArtifacts = /* @__PURE__ */ new Set();
    for (const message of chat.chat_messages) {
      if (message.content) {
        for (const block of message.content) {
          if (block.type === "tool_use" && block.name === "artifacts" && ((_a = block.input) == null ? void 0 : _a.id)) {
            uniqueArtifacts.add(block.input.id);
          }
        }
      }
    }
    return uniqueArtifacts.size;
  }
};
// Nexus custom callouts with icons
ClaudeConverter.CALLOUTS = {
  USER: "nexus_user",
  // 👤 User messages
  AGENT: "nexus_agent",
  // 🤖 Assistant/Agent messages
  ATTACHMENT: "nexus_attachment",
  // 📎 Attachments
  ARTIFACT: "nexus_artifact",
  // 🛠️ Claude artifacts
  PROMPT: "nexus_prompt"
  // 💭 System prompts
};

// src/providers/claude/claude-attachment-extractor.ts
var ClaudeAttachmentExtractor = class {
  constructor(plugin, logger4) {
    this.plugin = plugin;
    this.logger = logger4;
  }
  /**
   * Extract attachments from Claude ZIP archive
   * NOTE: Claude exports typically do NOT include the actual files, only references
   * This method handles the "files not found" case gracefully
   */
  async extractAttachments(zip, conversationId, attachments) {
    if (!this.plugin.settings.importAttachments || attachments.length === 0) {
      return attachments.map((att) => ({
        ...att,
        extractedContent: `File: ${att.fileName} (attachment import disabled)`
      }));
    }
    const processedAttachments = [];
    for (const attachment of attachments) {
      try {
        const processedAttachment = await this.processAttachment(zip, conversationId, attachment);
        processedAttachments.push(processedAttachment);
      } catch (error) {
        this.logger.error(`Failed to process Claude attachment ${attachment.fileName}:`, error);
        processedAttachments.push({
          ...attachment,
          extractedContent: `\u274C **File: ${attachment.fileName}**

Error processing attachment: ${error instanceof Error ? error.message : "Unknown error"}`
        });
      }
    }
    return processedAttachments;
  }
  /**
   * Process a single Claude attachment
   * Claude exports typically don't include files, so we create informative placeholders
   */
  async processAttachment(zip, conversationId, attachment) {
    const fileName = attachment.fileName;
    const zipFile = this.findFileInZip(zip, fileName);
    if (!zipFile) {
      return this.createFileNotFoundPlaceholder(attachment, conversationId);
    }
    if (this.isImageFile(fileName)) {
      return await this.processImageAttachment(zipFile, attachment, conversationId);
    } else if (this.isTextFile(fileName)) {
      return await this.processTextAttachment(zipFile, attachment);
    } else {
      return await this.processBinaryAttachment(zipFile, attachment, conversationId);
    }
  }
  /**
   * Create simple placeholder for missing files (normal for Claude)
   */
  createFileNotFoundPlaceholder(attachment, conversationId) {
    const fileName = attachment.fileName;
    const conversationUrl = `https://claude.ai/chat/${conversationId}`;
    const fileType = this.getFileTypeFromExtension(fileName);
    const placeholder = `>[!nexus_attachment] **${fileName}** (${fileType})
> \u26A0\uFE0F Not included in archive. [Open original conversation](${conversationUrl})`;
    return {
      ...attachment,
      extractedContent: placeholder
    };
  }
  /**
   * Get file type from extension
   */
  getFileTypeFromExtension(fileName) {
    var _a;
    const extension = (_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (extension) {
      case "png":
      case "jpg":
      case "jpeg":
      case "gif":
      case "webp":
        return `image/${extension}`;
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "md":
        return "text/markdown";
      case "json":
        return "application/json";
      default:
        return "application/octet-stream";
    }
  }
  /**
   * Find a file in the ZIP archive
   * Claude files might be in root or in subdirectories
   */
  findFileInZip(zip, fileName) {
    let file = zip.file(fileName);
    if (file)
      return file;
    const commonPaths = ["attachments/", "files/", "uploads/"];
    for (const path of commonPaths) {
      file = zip.file(path + fileName);
      if (file)
        return file;
    }
    const allFiles = Object.keys(zip.files);
    for (const filePath of allFiles) {
      if (filePath.endsWith(fileName) || filePath.includes(fileName)) {
        return zip.file(filePath);
      }
    }
    return null;
  }
  /**
   * Process image attachment
   */
  async processImageAttachment(zipFile, attachment, conversationId) {
    try {
      const imageData = await zipFile.async("base64");
      const fileName = this.generateUniqueFileName(attachment.fileName, conversationId);
      if (this.plugin.settings.importAttachments) {
        const filePath = await this.saveAttachmentToVault(fileName, imageData, true, "images");
        return {
          ...attachment,
          fileName,
          extractedContent: `![${attachment.fileName}](${filePath})`
        };
      } else {
        return {
          ...attachment,
          extractedContent: `Image: ${attachment.fileName} (not imported - attachment import disabled)`
        };
      }
    } catch (error) {
      this.logger.error(`Error processing Claude image ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error processing image: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Process text attachment
   */
  async processTextAttachment(zipFile, attachment) {
    try {
      const textContent = await zipFile.async("string");
      return {
        ...attachment,
        extractedContent: `\`\`\`
${textContent}
\`\`\``
      };
    } catch (error) {
      this.logger.error(`Error processing Claude text file ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error reading text file: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Process binary attachment
   */
  async processBinaryAttachment(zipFile, attachment, conversationId) {
    try {
      if (this.plugin.settings.importAttachments) {
        const binaryData = await zipFile.async("base64");
        const fileName = this.generateUniqueFileName(attachment.fileName, conversationId);
        const filePath = await this.saveAttachmentToVault(fileName, binaryData, true, "documents");
        return {
          ...attachment,
          fileName,
          extractedContent: `[${attachment.fileName}](${filePath})`
        };
      } else {
        return {
          ...attachment,
          extractedContent: `File: ${attachment.fileName} (not imported - attachment import disabled)`
        };
      }
    } catch (error) {
      this.logger.error(`Error processing Claude binary file ${attachment.fileName}:`, error);
      return {
        ...attachment,
        extractedContent: `Error processing file: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Check if file is an image
   */
  isImageFile(fileName) {
    const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".bmp"];
    return imageExtensions.some((ext) => fileName.toLowerCase().endsWith(ext));
  }
  /**
   * Check if file is a text file
   */
  isTextFile(fileName) {
    const textExtensions = [".txt", ".md", ".json", ".csv", ".xml", ".html", ".css", ".js", ".ts", ".py", ".java", ".cpp", ".c", ".h"];
    return textExtensions.some((ext) => fileName.toLowerCase().endsWith(ext));
  }
  /**
   * Generate unique filename to avoid conflicts
   */
  generateUniqueFileName(originalFileName, conversationId) {
    const timestamp = Date.now();
    const shortConversationId = conversationId.substring(0, 8);
    const extension = originalFileName.includes(".") ? originalFileName.split(".").pop() : "";
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    return extension ? `claude_${shortConversationId}_${timestamp}_${baseName}.${extension}` : `claude_${shortConversationId}_${timestamp}_${baseName}`;
  }
  /**
   * Save attachment to vault using attachmentFolder setting
   */
  async saveAttachmentToVault(fileName, data, isBase64, category = "files") {
    const attachmentFolder = `${this.plugin.settings.attachmentFolder}/claude/${category}`;
    const { ensureFolderExists: ensureFolderExists2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const folderResult = await ensureFolderExists2(attachmentFolder, this.plugin.app.vault);
    if (!folderResult.success) {
      throw new Error(`Failed to create Claude attachment folder: ${folderResult.error}`);
    }
    const filePath = `${attachmentFolder}/${fileName}`;
    if (isBase64) {
      const binaryString = atob(data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      await this.plugin.app.vault.createBinary(filePath, bytes.buffer);
    } else {
      await this.plugin.app.vault.create(filePath, data);
    }
    return filePath;
  }
};

// src/providers/claude/claude-report-naming.ts
var ClaudeReportNamingStrategy = class {
  getProviderName() {
    return "claude";
  }
  extractReportPrefix(zipFileName) {
    const now = new Date();
    const importYear = now.getFullYear();
    const importMonth = String(now.getMonth() + 1).padStart(2, "0");
    const importDay = String(now.getDate()).padStart(2, "0");
    const importDate = `${importYear}.${importMonth}.${importDay}`;
    const claudeBatchPattern = /data-(\d{4})-(\d{2})-(\d{2})-\d{2}-\d{2}-\d{2}-batch-\d{4}/;
    const batchMatch = zipFileName.match(claudeBatchPattern);
    if (batchMatch) {
      const [, year, month, day] = batchMatch;
      const archiveDate = `${year}.${month}.${day}`;
      return `imported-${importDate}-archive-${archiveDate}`;
    }
    const legacyPattern = /(\d{4})-(\d{2})-(\d{2})/;
    const legacyMatch = zipFileName.match(legacyPattern);
    if (legacyMatch) {
      const [, year, month, day] = legacyMatch;
      const archiveDate = `${year}.${month}.${day}`;
      return `imported-${importDate}-archive-${archiveDate}`;
    }
    return `imported-${importDate}-archive-${importDate}`;
  }
  getProviderSpecificColumn() {
    return {
      header: "Artifacts",
      getValue: (adapter, chat) => adapter.countArtifacts ? adapter.countArtifacts(chat) : 0
    };
  }
};

// src/providers/claude/claude-adapter.ts
var ClaudeAdapter = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.attachmentExtractor = new ClaudeAttachmentExtractor(plugin, plugin.logger);
    this.reportNamingStrategy = new ClaudeReportNamingStrategy();
  }
  detect(rawConversations) {
    if (rawConversations.length === 0)
      return false;
    const sample = rawConversations[0];
    return !!(sample.uuid && "name" in sample && sample.chat_messages && Array.isArray(sample.chat_messages) && sample.created_at && sample.updated_at && sample.account);
  }
  getId(chat) {
    return chat.uuid || "";
  }
  getTitle(chat) {
    return chat.name || "Untitled";
  }
  getCreateTime(chat) {
    return chat.created_at ? Math.floor(new Date(chat.created_at).getTime() / 1e3) : 0;
  }
  getUpdateTime(chat) {
    return chat.updated_at ? Math.floor(new Date(chat.updated_at).getTime() / 1e3) : 0;
  }
  async convertChat(chat) {
    ClaudeConverter.setPlugin(this.plugin);
    return await ClaudeConverter.convertChat(chat);
  }
  async convertMessages(messages, conversationId, conversationTitle, conversationCreateTime) {
    ClaudeConverter.setPlugin(this.plugin);
    return await ClaudeConverter.convertMessages(messages, conversationId, conversationTitle, conversationCreateTime);
  }
  getProviderName() {
    return "claude";
  }
  getNewMessages(chat, existingMessageIds) {
    const newMessages = [];
    for (const message of chat.chat_messages) {
      if (message.uuid && !existingMessageIds.includes(message.uuid)) {
        if (this.shouldIncludeMessage(message)) {
          newMessages.push(message);
        }
      }
    }
    return newMessages;
  }
  async processMessageAttachments(messages, conversationId, zip) {
    const processedMessages = [];
    for (const message of messages) {
      if (message.attachments && message.attachments.length > 0) {
        const processedAttachments = await this.attachmentExtractor.extractAttachments(
          zip,
          conversationId,
          message.attachments
        );
        processedMessages.push({
          ...message,
          attachments: processedAttachments
        });
      } else {
        processedMessages.push(message);
      }
    }
    return processedMessages;
  }
  getReportNamingStrategy() {
    return this.reportNamingStrategy;
  }
  getProviderName() {
    return "claude";
  }
  countArtifacts(chat) {
    return ClaudeConverter.countArtifacts(chat);
  }
  shouldIncludeMessage(message) {
    if (message.sender === "human" || message.sender === "assistant") {
      if (!message.text && (!message.content || message.content.length === 0)) {
        return false;
      }
      return true;
    }
    return false;
  }
};

// src/providers/provider-registry.ts
function createProviderRegistry(plugin) {
  const registry = new DefaultProviderRegistry();
  registry.register("chatgpt", new ChatGPTAdapter(plugin));
  registry.register("claude", new ClaudeAdapter(plugin));
  return registry;
}

// src/services/import-service.ts
var ImportService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.importReport = new ImportReport();
    this.providerRegistry = createProviderRegistry(plugin);
    this.conversationProcessor = new ConversationProcessor(plugin, this.providerRegistry);
  }
  async selectZipFile() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".zip";
    input.multiple = true;
    input.onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length > 0) {
        const sortedFiles = this.sortFilesByTimestamp(files);
        for (const file of sortedFiles) {
          await this.handleZipFile(file);
        }
      }
    };
    input.click();
  }
  sortFilesByTimestamp(files) {
    return files.sort((a, b) => {
      const timestampRegex = /(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2})/;
      const getTimestamp = (filename) => {
        const match = filename.match(timestampRegex);
        if (!match) {
          this.plugin.logger.warn(`No timestamp found in filename: ${filename}`);
          return "0";
        }
        return match[1];
      };
      return getTimestamp(a.name).localeCompare(getTimestamp(b.name));
    });
  }
  async handleZipFile(file, forcedProvider) {
    this.importReport = new ImportReport();
    const storage = this.plugin.getStorageService();
    try {
      const fileHash = await getFileHash(file);
      const foundByHash = storage.isArchiveImported(fileHash);
      const foundByName = storage.isArchiveImported(file.name);
      const isReprocess = foundByHash || foundByName;
      if (isReprocess) {
        const shouldReimport = await showDialog(
          this.plugin.app,
          "confirmation",
          "Already processed",
          [
            `File ${file.name} has already been imported.`,
            `Do you want to reprocess it?`,
            `**Note:** This will recreate notes from before v1.1.0 to add attachment support.`
          ],
          void 0,
          { button1: "Let's do this", button2: "Forget it" }
        );
        if (!shouldReimport) {
          new import_obsidian12.Notice("Import cancelled.");
          return;
        }
      }
      const zip = await this.validateZipFile(file, forcedProvider);
      await this.processConversations(zip, file, isReprocess, forcedProvider);
      storage.addImportedArchive(fileHash, file.name);
      await this.plugin.saveSettings();
    } catch (error) {
      const message = error instanceof NexusAiChatImporterError ? error.message : error instanceof Error ? error.message : "An unknown error occurred";
      this.plugin.logger.error("Error handling zip file", { message });
    } finally {
      await this.writeImportReport(file.name);
      new import_obsidian12.Notice(
        this.importReport.hasErrors() ? "An error occurred during import. Please check the log file for details." : "Import completed. Log file created in the archive folder."
      );
    }
  }
  async validateZipFile(file, forcedProvider) {
    try {
      const zip = new import_jszip.default();
      const content = await zip.loadAsync(file);
      const fileNames = Object.keys(content.files);
      if (forcedProvider) {
        if (!fileNames.includes("conversations.json")) {
          throw new NexusAiChatImporterError(
            "Invalid ZIP structure",
            `Missing required file: conversations.json for ${forcedProvider} provider.`
          );
        }
      } else {
        const hasConversationsJson = fileNames.includes("conversations.json");
        const hasUsersJson = fileNames.includes("users.json");
        const hasProjectsJson = fileNames.includes("projects.json");
        const isChatGPTFormat = hasConversationsJson && !hasUsersJson && !hasProjectsJson;
        const isClaudeFormat = hasConversationsJson && hasUsersJson;
        if (!isChatGPTFormat && !isClaudeFormat) {
          throw new NexusAiChatImporterError(
            "Invalid ZIP structure",
            "This ZIP file doesn't match any supported chat export format. Expected either ChatGPT format (conversations.json) or Claude format (conversations.json + users.json)."
          );
        }
      }
      return zip;
    } catch (error) {
      if (error instanceof NexusAiChatImporterError) {
        throw error;
      } else {
        throw new NexusAiChatImporterError(
          "Error validating zip file",
          error.message
        );
      }
    }
  }
  async processConversations(zip, file, isReprocess, forcedProvider) {
    try {
      const rawConversations = await this.extractRawConversationsFromZip(zip);
      if (forcedProvider) {
        this.validateProviderMatch(rawConversations, forcedProvider);
      }
      const report = await this.conversationProcessor.processRawConversations(rawConversations, this.importReport, zip, isReprocess, forcedProvider);
      this.importReport = report;
      this.importReport.addSummary(
        file.name,
        this.conversationProcessor.getCounters()
      );
    } catch (error) {
      if (error instanceof NexusAiChatImporterError) {
        this.plugin.logger.error("Error processing conversations", error.message);
      } else if (typeof error === "object" && error instanceof Error) {
        this.plugin.logger.error("General error processing conversations", error.message);
      } else {
        this.plugin.logger.error("Unknown error processing conversations", "An unknown error occurred");
      }
    }
  }
  /**
   * Extract raw conversation data without knowing provider specifics
   * TODO: Make this provider-aware when adding Claude support
   */
  async extractRawConversationsFromZip(zip) {
    const conversationsJson = await zip.file("conversations.json").async("string");
    return JSON.parse(conversationsJson);
  }
  /**
   * Validate that the forced provider matches the actual content structure
   */
  validateProviderMatch(rawConversations, forcedProvider) {
    if (rawConversations.length === 0)
      return;
    const firstConversation = rawConversations[0];
    const isChatGPT = firstConversation.mapping !== void 0;
    const isClaude = firstConversation.chat_messages !== void 0 || firstConversation.name !== void 0 || firstConversation.summary !== void 0;
    if (forcedProvider === "chatgpt" && !isChatGPT) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected ChatGPT but this archive appears to be from Claude. The structure doesn't match ChatGPT exports."
      );
    }
    if (forcedProvider === "claude" && !isClaude) {
      throw new NexusAiChatImporterError(
        "Provider Mismatch",
        "You selected Claude but this archive appears to be from ChatGPT. The structure doesn't match Claude exports."
      );
    }
  }
  async writeImportReport(zipFileName) {
    const reportWriter = new ReportWriter(this.plugin, this.providerRegistry);
    const currentProvider = this.conversationProcessor.getCurrentProvider();
    await reportWriter.writeReport(this.importReport, zipFileName, currentProvider);
  }
};
var ReportWriter = class {
  constructor(plugin, providerRegistry) {
    this.plugin = plugin;
    this.providerRegistry = providerRegistry;
  }
  async writeReport(report, zipFileName, provider) {
    const { ensureFolderExists: ensureFolderExists2, formatTimestamp: formatTimestamp2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const reportInfo = this.getReportGenerationInfo(zipFileName, provider);
    const adapter = this.providerRegistry.getAdapter(provider);
    if (adapter) {
      const strategy = adapter.getReportNamingStrategy();
      const columnInfo = strategy.getProviderSpecificColumn();
      report.setProviderSpecificColumnHeader(columnInfo.header);
    }
    const folderResult = await ensureFolderExists2(reportInfo.folderPath, this.plugin.app.vault);
    if (!folderResult.success) {
      this.plugin.logger.error(`Failed to create or access log folder: ${reportInfo.folderPath}`, folderResult.error);
      new import_obsidian12.Notice("Failed to create log file. Check console for details.");
      return;
    }
    let logFilePath = `${reportInfo.folderPath}/${reportInfo.baseFileName}`;
    let counter = 2;
    while (await this.plugin.app.vault.adapter.exists(logFilePath)) {
      const baseName = reportInfo.baseFileName.replace(" - import report.md", "");
      logFilePath = `${reportInfo.folderPath}/${baseName}-${counter} - import report.md`;
      counter++;
    }
    const currentDate = `${formatTimestamp2(Date.now() / 1e3, "date")} ${formatTimestamp2(Date.now() / 1e3, "time")}`;
    const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
    const logContent = `---
importdate: ${currentDate}
archivedate: ${archiveDate}
zipFile: ${zipFileName}
provider: ${provider}
totalSuccessfulImports: ${report.getCreatedCount()}
totalUpdatedImports: ${report.getUpdatedCount()}
totalSkippedImports: ${report.getSkippedCount()}
---

${report.generateReportContent()}
`;
    try {
      await this.plugin.app.vault.create(logFilePath, logContent);
    } catch (error) {
      this.plugin.logger.error(`Failed to write import log`, error.message);
      new import_obsidian12.Notice("Failed to create log file. Check console for details.");
    }
  }
  getReportGenerationInfo(zipFileName, provider) {
    const reportFolder = this.plugin.settings.reportFolder;
    const adapter = this.providerRegistry.getAdapter(provider);
    if (adapter) {
      const strategy = adapter.getReportNamingStrategy();
      const reportPrefix = strategy.extractReportPrefix(zipFileName);
      return {
        folderPath: `${reportFolder}/${strategy.getProviderName()}`,
        baseFileName: `${reportPrefix} - import report.md`
      };
    }
    const now = new Date();
    const importDate = `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, "0")}.${String(now.getDate()).padStart(2, "0")}`;
    const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
    const fallbackPrefix = `imported-${importDate}-archive-${archiveDate}`;
    return {
      folderPath: `${reportFolder}`,
      baseFileName: `${fallbackPrefix} - import report.md`
    };
  }
  extractArchiveDateFromFilename(zipFileName) {
    const dateRegex = /(\d{4})-(\d{2})-(\d{2})/;
    const match = zipFileName.match(dateRegex);
    if (match) {
      const [, year, month, day] = match;
      return `${year}.${month}.${day}`;
    }
    const now = new Date();
    return `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, "0")}.${String(now.getDate()).padStart(2, "0")}`;
  }
};

// src/services/storage-service.ts
var StorageService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.importedArchives = {};
    this.isDirty = false;
    this.saveTimeout = null;
  }
  async loadData() {
    try {
      const data = await this.plugin.loadData();
      this.importedArchives = (data == null ? void 0 : data.importedArchives) || {};
      this.isDirty = false;
      if (data == null ? void 0 : data.conversationCatalog) {
        const catalogSize = Object.keys(data.conversationCatalog).length;
        this.plugin.logger.info("Legacy conversation catalog detected - will be migrated in upgrade process");
      }
      this.plugin.logger.info("Storage data loaded successfully");
    } catch (error) {
      this.plugin.logger.error("loadData failed:", error);
      throw error;
    }
  }
  async saveData(data) {
    try {
      await this.plugin.saveData(data);
      this.isDirty = false;
    } catch (error) {
      this.plugin.logger.error("saveData failed:", error);
    }
  }
  debouncedSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    this.saveTimeout = window.setTimeout(async () => {
      if (this.isDirty) {
        await this.plugin.saveSettings();
      }
    }, 1e3);
  }
  // ========================================
  // ARCHIVE TRACKING - HYBRID DETECTION (1.0.x + 1.1.0)
  // ========================================
  getImportedArchives() {
    return this.importedArchives;
  }
  /**
   * HYBRID detection: Works with both 1.0.x (filename as key) and 1.1.0 (hash as key)
   * FIXED: Handle both old format (string values) and new format (object values)
   */
  isArchiveImported(key) {
    if (this.importedArchives[key]) {
      return true;
    }
    return Object.values(this.importedArchives).some((archive) => {
      if (typeof archive === "object" && archive !== null && archive.fileName) {
        return archive.fileName === key;
      }
      return false;
    });
  }
  addImportedArchive(fileHash, fileName) {
    this.importedArchives[fileHash] = {
      fileName,
      date: new Date().toISOString()
    };
    this.isDirty = true;
    this.debouncedSave();
  }
  // ========================================
  // NEW: VAULT-BASED CONVERSATION DISCOVERY (HYBRID)
  // ========================================
  /**
   * Scan vault for existing Nexus conversations using HYBRID approach:
   * 1. Wait for cache to be clean (fast)
   * 2. Use metadataCache (optimal performance)  
   * 3. Fallback to manual parsing for problematic files
   */
  async scanExistingConversations() {
    const startTime = Date.now();
    await this.waitForCacheClean(1e3);
    const conversations = /* @__PURE__ */ new Map();
    const archiveFolder = this.plugin.settings.archiveFolder;
    const allFiles = this.plugin.app.vault.getMarkdownFiles();
    const conversationFiles = allFiles.filter((file) => {
      if (!file.path.startsWith(archiveFolder))
        return false;
      const relativePath = file.path.substring(archiveFolder.length + 1);
      if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
        return false;
      }
      return true;
    });
    let processed = 0;
    let foundViaCache = 0;
    let foundViaManual = 0;
    let errors = 0;
    const batchSize = 100;
    for (let i = 0; i < conversationFiles.length; i += batchSize) {
      const batch = conversationFiles.slice(i, i + batchSize);
      for (const file of batch) {
        processed++;
        try {
          let entry = await this.parseWithCache(file);
          if (entry) {
            conversations.set(entry.conversationId, entry);
            foundViaCache++;
            continue;
          }
          entry = await this.parseConversationFileManually(file);
          if (entry) {
            conversations.set(entry.conversationId, entry);
            foundViaManual++;
          }
        } catch (error) {
          errors++;
          console.warn(`Error parsing conversation file ${file.path}:`, error);
        }
      }
      if (i + batchSize < conversationFiles.length) {
        await new Promise((resolve) => setTimeout(resolve, 1));
      }
    }
    const duration = Date.now() - startTime;
    const total = foundViaCache + foundViaManual;
    this.plugin.logger.info(`Scanned vault: found ${total} conversations in ${duration}ms`);
    return conversations;
  }
  /**
   * Wait for metadata cache to be clean with timeout
   */
  async waitForCacheClean(maxWaitMs = 1e3) {
    const startTime = Date.now();
    const metadataCache = this.plugin.app.metadataCache;
    while (!metadataCache.isCacheClean()) {
      if (Date.now() - startTime > maxWaitMs) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
  }
  /**
   * Parse conversation using metadataCache (fast but potentially unreliable)
   */
  async parseWithCache(file) {
    var _a;
    try {
      const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!(frontmatter == null ? void 0 : frontmatter.nexus) || frontmatter.nexus !== this.plugin.manifest.id) {
        return null;
      }
      if (!frontmatter.conversation_id) {
        return null;
      }
      const createTime = this.parseTimeString(frontmatter.create_time);
      const updateTime = this.parseTimeString(frontmatter.update_time);
      return {
        conversationId: frontmatter.conversation_id,
        provider: frontmatter.provider || "unknown",
        path: file.path,
        updateTime,
        create_time: createTime,
        update_time: updateTime
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Parse single conversation file manually (robust fallback)
   */
  async parseConversationFileManually(file) {
    try {
      const content = await this.plugin.app.vault.read(file);
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontmatterMatch) {
        return null;
      }
      const frontmatterContent = frontmatterMatch[1];
      const frontmatterData = {};
      const lines = frontmatterContent.split("\n");
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          let value = line.substring(colonIndex + 1).trim();
          if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
            value = value.slice(1, -1);
          }
          frontmatterData[key] = value;
        }
      }
      const nexusId = this.plugin.manifest.id;
      if (frontmatterData.nexus !== nexusId) {
        return null;
      }
      if (!frontmatterData.conversation_id) {
        return null;
      }
      const createTime = this.parseTimeString(frontmatterData.create_time);
      const updateTime = this.parseTimeString(frontmatterData.update_time);
      return {
        conversationId: frontmatterData.conversation_id,
        provider: frontmatterData.provider || "unknown",
        path: file.path,
        updateTime,
        create_time: createTime,
        update_time: updateTime
      };
    } catch (error) {
      console.error(`Error manually parsing ${file.path}:`, error);
      return null;
    }
  }
  /**
   * Parse time string from frontmatter (handle multiple formats)
   */
  parseTimeString(timeStr) {
    if (!timeStr)
      return 0;
    try {
      let dateStr = timeStr.replace(" at ", " ");
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) {
        console.warn(`Could not parse date: ${timeStr}`);
        return 0;
      }
      return Math.floor(date.getTime() / 1e3);
    } catch (error) {
      console.warn(`Date parsing error for "${timeStr}":`, error);
      return 0;
    }
  }
  /**
   * Fast check if a specific conversation exists
   */
  async conversationExists(conversationId) {
    const conversations = await this.scanExistingConversations();
    return conversations.has(conversationId);
  }
  /**
   * Get conversation entry by ID (single lookup)
   */
  async getConversationById(conversationId) {
    const conversations = await this.scanExistingConversations();
    return conversations.get(conversationId) || null;
  }
  /**
   * Get conversations by provider (for reporting/stats)
   */
  async getConversationsByProvider(provider) {
    const allConversations = await this.scanExistingConversations();
    return Array.from(allConversations.values()).filter((entry) => entry.provider === provider);
  }
  // ========================================
  // LEGACY SUPPORT & CLEANUP
  // ========================================
  async resetCatalogs() {
    try {
      this.importedArchives = {};
      this.isDirty = false;
      if (this.saveTimeout) {
        clearTimeout(this.saveTimeout);
        this.saveTimeout = null;
      }
      await this.plugin.saveData({
        settings: this.plugin.settings
        // Note: No conversation catalog to reset - it's now vault-based
      });
      this.plugin.logger.info("Reset archive catalog (conversation tracking is now vault-based)");
    } catch (error) {
      this.plugin.logger.error("resetCatalogs failed:", error);
    }
  }
  // Statistics for debugging
  getStats() {
    return {
      totalArchives: Object.keys(this.importedArchives).length,
      isDirty: this.isDirty,
      hasPendingSave: this.saveTimeout !== null,
      catalogMethod: "vault-based-hybrid",
      trackingMethod: "hybrid-hash-filename"
    };
  }
  async forceSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
    if (this.isDirty) {
      await this.plugin.saveSettings();
    }
  }
  // ========================================
  // DEPRECATED METHODS (For Compatibility)
  // ========================================
  /**
   * @deprecated Use scanExistingConversations() instead
   */
  getConversationCatalog() {
    this.plugin.logger.warn("getConversationCatalog() is deprecated - use scanExistingConversations()");
    return {};
  }
  /**
   * @deprecated Conversations are now tracked via vault frontmatter
   */
  updateConversationCatalog(id, entry) {
    this.plugin.logger.warn("updateConversationCatalog() is deprecated - conversations tracked via frontmatter");
  }
  /**
   * @deprecated Conversations are now tracked via vault frontmatter  
   */
  deleteFromConversationCatalog(id) {
    this.plugin.logger.warn("deleteFromConversationCatalog() is deprecated - files tracked via vault");
  }
};

// src/upgrade/incremental-upgrade-manager.ts
var import_obsidian15 = require("obsidian");
init_version_utils();
init_dialogs();
init_logger();

// src/upgrade/utils/multi-operation-progress-modal.ts
var import_obsidian13 = require("obsidian");
var MultiOperationProgressModal = class extends import_obsidian13.Modal {
  constructor(app, title, operations) {
    super(app);
    this.canClose = false;
    this.title = title;
    this.operations = [...operations];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nexus-ai-chat-importer-modal");
    contentEl.addClass("multi-operation-progress-modal");
    this.modalTitleEl = contentEl.createEl("h2", {
      text: this.title,
      cls: "modal-title"
    });
    const contentContainer = contentEl.createDiv({ cls: "modal-content" });
    this.operationsContainer = contentContainer.createDiv({ cls: "operations-container" });
    this.operationsContainer.style.cssText = `
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        `;
    this.overallProgressEl = contentContainer.createDiv({ cls: "overall-progress" });
    this.overallProgressEl.style.cssText = `
            margin-top: 20px;
            padding: 15px;
            background: var(--background-secondary);
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            text-align: center;
            font-weight: 500;
        `;
    this.renderOperations();
    this.updateOverallProgress();
    this.modalEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !this.canClose) {
        e.preventDefault();
        e.stopPropagation();
      }
    });
  }
  /**
   * Update operation status
   */
  updateOperation(operationId, updates) {
    const operation = this.operations.find((op) => op.id === operationId);
    if (operation) {
      Object.assign(operation, updates);
      this.renderOperations();
      this.updateOverallProgress();
    }
  }
  /**
   * Mark all operations as complete and allow closing
   */
  markComplete(message = "All operations completed successfully") {
    this.canClose = true;
    this.overallProgressEl.textContent = message;
    this.overallProgressEl.style.color = "var(--text-success)";
    if (!this.closeButtonEl) {
      const buttonContainer = this.contentEl.createDiv({ cls: "modal-button-container" });
      this.closeButtonEl = buttonContainer.createEl("button", {
        text: "Complete",
        cls: "mod-cta"
      });
      this.closeButtonEl.addEventListener("click", () => this.close());
    }
  }
  /**
   * Show error state
   */
  showError(message) {
    this.canClose = true;
    this.overallProgressEl.textContent = message;
    this.overallProgressEl.style.color = "var(--text-error)";
    if (!this.closeButtonEl) {
      const buttonContainer = this.contentEl.createDiv({ cls: "modal-button-container" });
      this.closeButtonEl = buttonContainer.createEl("button", {
        text: "Close",
        cls: "mod-warning"
      });
      this.closeButtonEl.addEventListener("click", () => this.close());
    }
  }
  /**
   * Render all operations
   */
  renderOperations() {
    this.operationsContainer.empty();
    for (const operation of this.operations) {
      const operationEl = this.operationsContainer.createDiv({ cls: "operation-item" });
      operationEl.style.cssText = `
                display: flex;
                align-items: center;
                margin: 10px 0;
                padding: 10px;
                background: var(--background-primary);
                border-radius: 6px;
                border: 1px solid var(--background-modifier-border);
            `;
      const iconEl = operationEl.createDiv({ cls: "operation-icon" });
      iconEl.style.cssText = `
                width: 20px;
                height: 20px;
                margin-right: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
            `;
      switch (operation.status) {
        case "pending":
          iconEl.textContent = "\u25CB";
          iconEl.style.color = "var(--text-muted)";
          break;
        case "running":
          iconEl.textContent = "\u26A0";
          iconEl.style.color = "var(--text-accent)";
          break;
        case "completed":
          iconEl.textContent = "\u2713";
          iconEl.style.color = "var(--text-success)";
          break;
        case "failed":
          iconEl.textContent = "\u2717";
          iconEl.style.color = "var(--text-error)";
          break;
      }
      const contentEl = operationEl.createDiv({ cls: "operation-content" });
      contentEl.style.cssText = `flex: 1; min-width: 0;`;
      const nameEl = contentEl.createDiv({ cls: "operation-name" });
      nameEl.textContent = operation.name;
      nameEl.style.cssText = `
                font-weight: 500;
                margin-bottom: 5px;
                color: var(--text-normal);
            `;
      if (operation.status === "running" || operation.progress !== void 0 && operation.progress > 0) {
        const progressContainer = contentEl.createDiv({ cls: "progress-container" });
        progressContainer.style.cssText = `
                    background: var(--background-secondary);
                    border-radius: 4px;
                    height: 8px;
                    margin: 5px 0;
                    overflow: hidden;
                `;
        const progressBar = progressContainer.createDiv({ cls: "progress-bar" });
        const progress = operation.progress || 0;
        progressBar.style.cssText = `
                    background: var(--interactive-accent);
                    height: 100%;
                    width: ${progress}%;
                    transition: width 0.3s ease;
                `;
      }
      if (operation.currentDetail) {
        const detailEl = contentEl.createDiv({ cls: "operation-detail" });
        detailEl.textContent = this.truncateDetail(operation.currentDetail);
        detailEl.style.cssText = `
                    font-size: 0.9em;
                    color: var(--text-muted);
                    font-style: italic;
                    margin-top: 3px;
                `;
      }
      if (operation.status === "failed" && operation.error) {
        const errorEl = contentEl.createDiv({ cls: "operation-error" });
        errorEl.textContent = operation.error;
        errorEl.style.cssText = `
                    font-size: 0.9em;
                    color: var(--text-error);
                    margin-top: 3px;
                `;
      }
    }
  }
  /**
   * Update overall progress display
   */
  updateOverallProgress() {
    const completed = this.operations.filter((op) => op.status === "completed").length;
    const failed = this.operations.filter((op) => op.status === "failed").length;
    const total = this.operations.length;
    if (failed > 0) {
      this.overallProgressEl.textContent = `Progress: ${completed}/${total} operations (${failed} failed)`;
      this.overallProgressEl.style.color = "var(--text-error)";
    } else if (completed === total) {
      this.overallProgressEl.textContent = `All ${total} operations completed successfully`;
      this.overallProgressEl.style.color = "var(--text-success)";
    } else {
      this.overallProgressEl.textContent = `Progress: ${completed}/${total} operations`;
      this.overallProgressEl.style.color = "var(--text-normal)";
    }
  }
  /**
   * Truncate detail text to fit in modal
   */
  truncateDetail(detail) {
    const maxLength = 50;
    if (detail.length <= maxLength)
      return detail;
    return "..." + detail.slice(-maxLength + 3);
  }
  /**
   * Override close to respect canClose flag
   */
  close() {
    if (this.canClose) {
      super.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/upgrade/incremental-upgrade-manager.ts
var logger3 = new Logger();
var IncrementalUpgradeManager = class {
  constructor(plugin) {
    this.availableUpgrades = [];
    this.plugin = plugin;
    this.registerUpgrades();
  }
  /**
   * Register all available version upgrades
   */
  registerUpgrades() {
    const { Upgrade110: Upgrade1102 } = (init_upgrade_1_1_0(), __toCommonJS(upgrade_1_1_0_exports));
    const { Upgrade120: Upgrade1202 } = (init_upgrade_1_2_0(), __toCommonJS(upgrade_1_2_0_exports));
    this.availableUpgrades = [
      new Upgrade1102(),
      new Upgrade1202()
      // Future: new Upgrade121(), new Upgrade130(), etc.
    ];
    this.availableUpgrades.sort((a, b) => {
      return VersionUtils.compareVersions(a.version, b.version);
    });
    logger3.info(`Registered ${this.availableUpgrades.length} version upgrades`);
  }
  /**
   * Main incremental upgrade check and execution
   */
  async checkAndPerformUpgrade() {
    var _a, _b, _c;
    try {
      const currentVersion = this.plugin.manifest.version;
      const previousVersion = this.plugin.settings.previousVersion;
      console.debug(`[NEXUS-DEBUG] Incremental upgrade check: ${previousVersion} \u2192 ${currentVersion}`);
      if (previousVersion === currentVersion) {
        console.debug(`[NEXUS-DEBUG] No version change - SKIPPING ALL`);
        logger3.info(`No version change (${currentVersion}), skipping upgrade checks`);
        return null;
      }
      const data = await this.plugin.loadData();
      const versionKey = currentVersion.replace(/\./g, "_");
      const hasCompletedThisUpgrade = (_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedUpgrades) == null ? void 0 : _b[versionKey]) == null ? void 0 : _c.completed;
      console.debug(`[NEXUS-DEBUG] Upgrade history check for '${versionKey}': ${hasCompletedThisUpgrade}`);
      if (hasCompletedThisUpgrade) {
        console.debug(`[NEXUS-DEBUG] Upgrade already completed - SKIPPING ALL`);
        logger3.info(`Already completed upgrade to ${currentVersion}, skipping`);
        return null;
      }
      const isFreshInstall = await this.detectFreshInstall();
      console.debug(`[NEXUS-DEBUG] Fresh install detection: ${isFreshInstall}`);
      if (isFreshInstall) {
        console.debug(`[NEXUS-DEBUG] Fresh install detected - marking as complete without upgrades`);
        await this.markUpgradeComplete(currentVersion);
        logger3.info(`Fresh installation detected - marked as up-to-date v${currentVersion}`);
        return {
          success: true,
          upgradesExecuted: 0,
          upgradesSkipped: 0,
          upgradesFailed: 0,
          results: []
        };
      }
      const upgradeChain = this.getUpgradeChain(previousVersion, currentVersion);
      console.debug(`[NEXUS-DEBUG] Upgrade chain:`, upgradeChain.map((u) => u.version));
      if (upgradeChain.length === 0) {
        console.debug(`[NEXUS-DEBUG] No upgrades needed - marking complete`);
        await this.markUpgradeComplete(currentVersion);
        await this.showUpgradeDialog(currentVersion, previousVersion, []);
        return {
          success: true,
          upgradesExecuted: 0,
          upgradesSkipped: 0,
          upgradesFailed: 0,
          results: []
        };
      }
      console.debug(`[NEXUS-DEBUG] Need to execute ${upgradeChain.length} upgrades - showing dialog first`);
      await this.showUpgradeDialog(currentVersion, previousVersion, upgradeChain);
      console.debug(`[NEXUS-DEBUG] Executing upgrades with modal...`);
      const result = await this.executeUpgradeChainWithModal(upgradeChain, previousVersion, currentVersion);
      console.debug(`[NEXUS-DEBUG] Upgrade process completed - marking overall upgrade complete`);
      await this.markUpgradeComplete(currentVersion);
      return result;
    } catch (error) {
      console.error(`[NEXUS-DEBUG] Incremental upgrade FAILED:`, error);
      logger3.error("Error during incremental upgrade:", error);
      new import_obsidian15.Notice("Upgrade failed - see console for details");
      return {
        success: false,
        upgradesExecuted: 0,
        upgradesSkipped: 0,
        upgradesFailed: 1,
        results: []
      };
    }
  }
  /**
   * Detect if this is a fresh installation with no existing data
   */
  async detectFreshInstall() {
    try {
      const data = await this.plugin.loadData();
      const hasLegacyData = !!((data == null ? void 0 : data.conversationCatalog) && Object.keys(data.conversationCatalog).length > 0);
      const hasImportedArchives = !!((data == null ? void 0 : data.importedArchives) && Object.keys(data.importedArchives).length > 0);
      const archiveFolder = this.plugin.settings.archiveFolder;
      const allFiles = this.plugin.app.vault.getMarkdownFiles();
      const existingConversations = allFiles.filter((file) => {
        var _a;
        if (!file.path.startsWith(archiveFolder))
          return false;
        const relativePath = file.path.substring(archiveFolder.length + 1);
        if (relativePath.startsWith("Reports/") || relativePath.startsWith("Attachments/") || relativePath.startsWith("reports/") || relativePath.startsWith("attachments/")) {
          return false;
        }
        const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return (frontmatter == null ? void 0 : frontmatter.nexus) === this.plugin.manifest.id;
      });
      const hasExistingConversations = existingConversations.length > 0;
      const isFreshInstall = !hasLegacyData && !hasImportedArchives && !hasExistingConversations;
      console.debug(`[NEXUS-DEBUG] Fresh install detection:`, {
        hasLegacyData,
        hasImportedArchives,
        hasExistingConversations,
        isFreshInstall
      });
      return isFreshInstall;
    } catch (error) {
      console.error(`[NEXUS-DEBUG] Error detecting fresh install:`, error);
      return false;
    }
  }
  /**
   * Get chain of upgrades to execute incrementally
   */
  getUpgradeChain(fromVersion, toVersion) {
    return this.availableUpgrades.filter(
      (upgrade) => upgrade.shouldRun(fromVersion, toVersion)
    );
  }
  /**
   * Execute upgrade chain with modal progress tracking
   */
  async executeUpgradeChainWithModal(upgradeChain, fromVersion, toVersion) {
    const allOperations = [];
    for (const upgrade of upgradeChain) {
      for (const operation of upgrade.automaticOperations) {
        allOperations.push({
          id: `${upgrade.version}_${operation.id}`,
          name: operation.name,
          status: "pending"
        });
      }
    }
    const progressModal = new MultiOperationProgressModal(
      this.plugin.app,
      `Upgrading to v${toVersion}`,
      allOperations
    );
    progressModal.open();
    const results = [];
    let upgradesExecuted = 0;
    let upgradesSkipped = 0;
    let upgradesFailed = 0;
    try {
      for (const upgrade of upgradeChain) {
        console.debug(`[NEXUS-DEBUG] Executing upgrade ${upgrade.version}...`);
        const context = await this.createUpgradeContext(upgrade, fromVersion, toVersion);
        const automaticResults = await this.executeOperationsWithProgress(
          upgrade.automaticOperations,
          context,
          upgrade.version,
          progressModal
        );
        console.debug(`[NEXUS-DEBUG] Automatic operations for ${upgrade.version}:`, automaticResults);
        const manualResults = { success: true, results: [] };
        results.push({
          version: upgrade.version,
          automaticResults,
          manualResults
        });
        upgradesExecuted++;
      }
      const overallSuccess = true;
      progressModal.markComplete(`All operations completed successfully!`);
      new import_obsidian15.Notice(`Upgrade completed: ${upgradesExecuted} versions processed successfully`);
      return {
        success: overallSuccess,
        upgradesExecuted,
        upgradesSkipped,
        upgradesFailed,
        results
      };
    } catch (error) {
      console.error(`[NEXUS-DEBUG] Modal upgrade execution failed:`, error);
      progressModal.showError(`Upgrade failed: ${error}`);
      throw error;
    }
  }
  /**
   * Execute operations with progress updates to modal
   */
  async executeOperationsWithProgress(operations, context, version, progressModal) {
    const results = [];
    let criticalFailures = 0;
    for (const operation of operations) {
      const modalOperationId = `${version}_${operation.id}`;
      try {
        if (await this.isOperationCompleted(operation.id, version)) {
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100
          });
          results.push({
            operationId: operation.id,
            result: { success: true, message: "Already completed" }
          });
          continue;
        }
        progressModal.updateOperation(modalOperationId, {
          status: "running",
          progress: 0
        });
        if (!await operation.canRun(context)) {
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100,
            currentDetail: "Nothing to process"
          });
          results.push({
            operationId: operation.id,
            result: { success: true, message: "Prerequisites not met - nothing to process" }
          });
          continue;
        }
        const result = await this.executeOperationWithProgress(
          operation,
          context,
          modalOperationId,
          progressModal
        );
        results.push({ operationId: operation.id, result });
        if (result.success) {
          await this.markOperationCompleted(operation.id, version);
          progressModal.updateOperation(modalOperationId, {
            status: "completed",
            progress: 100
          });
        } else {
          const isCritical = this.isCriticalFailure(result);
          if (isCritical) {
            criticalFailures++;
            progressModal.updateOperation(modalOperationId, {
              status: "failed",
              error: result.message
            });
          } else {
            progressModal.updateOperation(modalOperationId, {
              status: "completed",
              progress: 100,
              currentDetail: "Completed with warnings"
            });
          }
        }
      } catch (error) {
        const errorResult = {
          success: false,
          message: `Operation failed: ${error}`,
          details: { error: String(error) }
        };
        results.push({ operationId: operation.id, result: errorResult });
        progressModal.updateOperation(modalOperationId, {
          status: "failed",
          error: String(error)
        });
        criticalFailures++;
      }
    }
    return { success: criticalFailures === 0, results };
  }
  /**
   * Determine if an operation failure is critical
   */
  isCriticalFailure(result) {
    return false;
  }
  /**
   * Execute single operation with progress callbacks
   */
  async executeOperationWithProgress(operation, context, modalOperationId, progressModal) {
    var _a;
    const result = await operation.execute(context);
    const steps = 5;
    for (let i = 1; i <= steps; i++) {
      progressModal.updateOperation(modalOperationId, {
        status: "running",
        progress: i / steps * 100,
        currentDetail: ((_a = result.details) == null ? void 0 : _a.processed) ? `Processing... ${i}/${steps}` : void 0
      });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    return result;
  }
  /**
   * Create upgrade context
   */
  async createUpgradeContext(upgrade, fromVersion, toVersion) {
    const pluginData = await this.plugin.loadData();
    return {
      plugin: this.plugin,
      fromVersion,
      toVersion,
      pluginData
    };
  }
  /**
   * Mark overall upgrade as complete
   */
  async markUpgradeComplete(version) {
    const data = await this.plugin.loadData() || {};
    if (!data.upgradeHistory) {
      data.upgradeHistory = {
        completedUpgrades: {},
        completedOperations: {}
      };
    }
    const versionKey = version.replace(/\./g, "_");
    data.upgradeHistory.completedUpgrades[versionKey] = {
      version,
      date: new Date().toISOString(),
      completed: true
    };
    data.lastVersion = version;
    data.hasCompletedUpgrade = true;
    data.upgradeDate = new Date().toISOString();
    if (VersionUtils.compareVersions(version, "1.1.0") >= 0) {
      data.versionTrackingEnabled = true;
    }
    await this.plugin.saveData(data);
    logger3.info(`Marked overall upgrade to ${version} as complete`);
  }
  /**
   * Show upgrade dialog - INFORMATION ONLY (no cancel)
   */
  async showUpgradeDialog(currentVersion, lastVersion, upgradeChain) {
    try {
      const overview = await this.fetchReleaseOverview(currentVersion);
      const baseMessage = overview || `Nexus AI Chat Importer has been upgraded to version ${currentVersion}.`;
      const paragraphs = [];
      paragraphs.push(baseMessage);
      paragraphs.push(this.getDocLinks(currentVersion));
      if (upgradeChain.length > 0) {
        paragraphs.push("");
        paragraphs.push("**Upgrade Operations Required**");
        paragraphs.push("The following operations will be performed automatically:");
        paragraphs.push("");
        const operationsList = [];
        for (const upgrade of upgradeChain) {
          for (const operation of upgrade.automaticOperations) {
            operationsList.push(`\u2022 **${operation.name}**: ${operation.description}`);
          }
        }
        paragraphs.push(operationsList.join("\n"));
      } else {
        paragraphs.push("");
        paragraphs.push("All systems are up to date. No operations required.");
      }
      if (upgradeChain.length > 0) {
        const isV120Upgrade = upgradeChain.some((upgrade) => upgrade.version === "1.2.0");
        if (isV120Upgrade) {
          const { NexusUpgradeModal: NexusUpgradeModal2 } = (init_upgrade_1_2_0(), __toCommonJS(upgrade_1_2_0_exports));
          await new Promise((resolve) => {
            new NexusUpgradeModal2(this.plugin.app, this.plugin, "1.2.0", resolve).open();
          });
        } else {
          await showDialog(
            this.plugin.app,
            "information",
            `Upgrade to ${VersionUtils.formatVersion(currentVersion)}`,
            paragraphs,
            this.shouldShowUpgradeWarning(lastVersion) ? this.getUpgradeWarning() : void 0,
            { button1: "Proceed with Upgrade" }
          );
        }
      } else {
        await showDialog(
          this.plugin.app,
          "information",
          `Upgrade to ${VersionUtils.formatVersion(currentVersion)}`,
          paragraphs,
          this.shouldShowUpgradeWarning(lastVersion) ? this.getUpgradeWarning() : void 0,
          { button1: "Got it!" }
          // ← Juste informatif
        );
      }
    } catch (error) {
      logger3.error("Error showing upgrade dialog:", error);
      new import_obsidian15.Notice(`Upgraded to Nexus AI Chat Importer v${currentVersion}`);
    }
  }
  /**
   * Check if operation was completed using new upgrade history structure
   */
  async isOperationCompleted(operationId, version) {
    var _a, _b, _c;
    const data = await this.plugin.loadData();
    const operationKey = `operation_${version.replace(/\./g, "_")}_${operationId}`;
    return ((_c = (_b = (_a = data == null ? void 0 : data.upgradeHistory) == null ? void 0 : _a.completedOperations) == null ? void 0 : _b[operationKey]) == null ? void 0 : _c.completed) || false;
  }
  /**
   * Mark operation as completed using structured upgrade history
   */
  async markOperationCompleted(operationId, version) {
    const data = await this.plugin.loadData() || {};
    if (!data.upgradeHistory) {
      data.upgradeHistory = {
        completedUpgrades: {},
        completedOperations: {}
      };
    }
    const operationKey = `operation_${version.replace(/\./g, "_")}_${operationId}`;
    data.upgradeHistory.completedOperations[operationKey] = {
      operationId,
      version,
      date: new Date().toISOString(),
      completed: true
    };
    await this.plugin.saveData(data);
    logger3.info(`Marked operation ${operationId} (v${version}) as completed`);
  }
  /**
   * Get documentation links
   */
  getDocLinks(version) {
    return `**Resources:**
\u2022 [Full Release Notes](${GITHUB.REPO_BASE}/blob/${version}/RELEASE_NOTES.md)
\u2022 [Documentation](${GITHUB.REPO_BASE}/blob/${version}/README.md)`;
  }
  /**
   * Check if should show upgrade warning for very old versions
   */
  shouldShowUpgradeWarning(lastVersion) {
    return VersionUtils.compareVersions(lastVersion, "1.0.2") < 0;
  }
  /**
   * Get upgrade warning for very old versions
   */
  getUpgradeWarning() {
    return `\u26A0\uFE0F **Important for users upgrading from versions prior to v1.0.2:**

Version 1.0.2 introduced new metadata parameters required for certain features. For optimal performance and feature compatibility, it's recommended to delete old data and re-import conversations with this new version.`;
  }
  /**
   * Fetch release overview from GitHub
   */
  async fetchReleaseOverview(version) {
    try {
      const { requestUrl: requestUrl2 } = require("obsidian");
      const response = await requestUrl2({
        url: `${GITHUB.RAW_BASE}/${version}/RELEASE_NOTES.md`,
        method: "GET"
      });
      const overviewRegex = /## Overview\s+(.*?)(?=##|$)/s;
      const match = response.text.match(overviewRegex);
      return match ? match[1].trim() : null;
    } catch (error) {
      logger3.warn("Could not fetch release overview:", error);
      return null;
    }
  }
  /**
   * Get manual operations status for settings UI
   */
  async getManualOperationsForSettings() {
    const results = [];
    for (const upgrade of this.availableUpgrades) {
      const context = await this.createUpgradeContext(upgrade, "0.0.0", this.plugin.manifest.version);
      const operationsStatus = await upgrade.getManualOperationsStatus(context);
      if (operationsStatus.length > 0) {
        results.push({
          version: upgrade.version,
          operations: operationsStatus.map((status) => ({
            id: status.operation.id,
            name: status.operation.name,
            description: status.operation.description,
            completed: status.completed,
            canRun: status.canRun
          }))
        });
      }
    }
    return results;
  }
  /**
   * Execute single manual operation from settings
   */
  async executeManualOperation(version, operationId) {
    const upgrade = this.availableUpgrades.find((u) => u.version === version);
    if (!upgrade) {
      return { success: false, message: "Upgrade version not found" };
    }
    const context = await this.createUpgradeContext(upgrade, "0.0.0", this.plugin.manifest.version);
    const result = await upgrade.executeManualOperation(operationId, context);
    return {
      success: result.success,
      message: result.message
    };
  }
};

// src/main.ts
init_logger();

// src/dialogs/provider-selection-dialog.ts
var import_obsidian16 = require("obsidian");
var ProviderSelectionDialog = class extends import_obsidian16.Modal {
  constructor(app, providerRegistry, onProviderSelected) {
    super(app);
    this.selectedProvider = null;
    this.onProviderSelected = onProviderSelected;
    this.providers = this.getAvailableProviders(providerRegistry);
  }
  getAvailableProviders(registry) {
    const providers = [];
    if (registry.getAdapter("chatgpt")) {
      providers.push({
        id: "chatgpt",
        name: "ChatGPT",
        description: "OpenAI ChatGPT conversation exports",
        fileFormats: ["conversations.json only"]
      });
    }
    if (registry.getAdapter("claude")) {
      providers.push({
        id: "claude",
        name: "Claude",
        description: "Anthropic Claude conversation exports",
        fileFormats: ["conversations.json + users.json", "projects.json (optional)"]
      });
    }
    return providers;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Archive Provider" });
    this.providers.forEach((provider) => {
      new import_obsidian16.Setting(contentEl).setName(provider.name).setDesc(this.createProviderDescription(provider)).addButton((button) => {
        button.setButtonText("Select").setCta().onClick(() => {
          this.selectedProvider = provider.id;
          this.close();
          this.onProviderSelected(provider.id);
        });
      });
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.textAlign = "center";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.marginRight = "10px";
    cancelButton.onclick = () => this.close();
  }
  createProviderDescription(provider) {
    return provider.description;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var NexusAiChatImporterPlugin = class extends import_obsidian17.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.logger = new Logger();
    this.storageService = new StorageService(this);
    this.importService = new ImportService(this);
    this.fileService = new FileService(this);
    this.commandRegistry = new CommandRegistry(this);
    this.eventHandlers = new EventHandlers(this);
    this.upgradeManager = new IncrementalUpgradeManager(this);
  }
  async onload() {
    try {
      await this.loadSettings();
      this.addSettingTab(new NexusAiChatImporterPluginSettingTab(this.app, this));
      this.commandRegistry.registerCommands();
      this.eventHandlers.registerEvents();
      const ribbonIconEl = this.addRibbonIcon(
        "message-square-plus",
        "Nexus AI Chat Importer - Import new file",
        () => this.showProviderSelectionDialog()
      );
      ribbonIconEl.addClass("nexus-ai-chat-ribbon");
      await this.upgradeManager.checkAndPerformUpgrade();
    } catch (error) {
      this.logger.error("Plugin loading failed:", error);
      throw error;
    }
  }
  async onunload() {
    try {
      this.eventHandlers.cleanup();
      await this.saveSettings();
    } catch (error) {
      this.logger.error("Plugin unloading failed:", error);
    }
  }
  async loadSettings() {
    try {
      const data = await this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, (data == null ? void 0 : data.settings) || {});
      const currentVersion = this.manifest.version;
      const storedCurrentVersion = this.settings.currentVersion;
      if (!storedCurrentVersion || storedCurrentVersion === "0.0.0") {
        const hasExistingConversations = await this.hasExistingNexusConversations();
        if (hasExistingConversations) {
          this.settings.previousVersion = "1.0.x";
          this.settings.currentVersion = currentVersion;
        } else {
          this.settings.previousVersion = currentVersion;
          this.settings.currentVersion = currentVersion;
        }
        await this.saveSettings();
      } else if (storedCurrentVersion !== currentVersion) {
        this.settings.previousVersion = storedCurrentVersion;
        this.settings.currentVersion = currentVersion;
        await this.saveSettings();
      }
      await this.storageService.loadData();
    } catch (error) {
      this.logger.error("loadSettings failed:", error);
      throw error;
    }
  }
  /**
   * Check if vault contains existing Nexus conversations
   */
  async hasExistingNexusConversations() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      return files.some((file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return (frontmatter == null ? void 0 : frontmatter.nexus) === this.manifest.id;
      });
    } catch (error) {
      this.logger.warn("Error checking for existing conversations:", error);
      return false;
    }
  }
  async saveSettings() {
    try {
      const existingData = await this.loadData() || {};
      let finalImportedArchives = this.storageService.getImportedArchives();
      if (existingData.importedArchives && Object.keys(existingData.importedArchives).length > 0) {
        const existingArchives = existingData.importedArchives;
        const storageArchives = this.storageService.getImportedArchives();
        finalImportedArchives = {
          ...existingArchives,
          ...storageArchives
        };
      }
      const mergedData = {
        ...existingData,
        settings: this.settings,
        importedArchives: finalImportedArchives,
        upgradeHistory: existingData.upgradeHistory || {
          completedUpgrades: {},
          completedOperations: {}
        }
      };
      await this.storageService.saveData(mergedData);
    } catch (error) {
      this.logger.error("saveSettings failed:", error);
    }
  }
  async resetCatalogs() {
    try {
      await this.storageService.resetCatalogs();
      await this.loadSettings();
    } catch (error) {
      this.logger.error("resetCatalogs failed:", error);
    }
  }
  getStorageService() {
    return this.storageService;
  }
  getImportService() {
    return this.importService;
  }
  getFileService() {
    return this.fileService;
  }
  getUpgradeManager() {
    return this.upgradeManager;
  }
  /**
   * Show provider selection dialog and then file selection
   */
  showProviderSelectionDialog() {
    const providerRegistry = createProviderRegistry(this);
    new ProviderSelectionDialog(
      this.app,
      providerRegistry,
      (selectedProvider) => {
        this.selectZipFilesForProvider(selectedProvider);
      }
    ).open();
  }
  /**
   * Select ZIP files for a specific provider
   */
  selectZipFilesForProvider(provider) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".zip";
    input.multiple = true;
    input.onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length > 0) {
        const sortedFiles = this.sortFilesByTimestamp(files);
        for (const file of sortedFiles) {
          await this.importService.handleZipFile(file, provider);
        }
      }
    };
    input.click();
  }
  /**
   * Sort files by timestamp (same logic as ImportService)
   */
  sortFilesByTimestamp(files) {
    return files.sort((a, b) => {
      const timestampRegex = /(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2})/;
      const getTimestamp = (filename) => {
        const match = filename.match(timestampRegex);
        if (!match) {
          this.logger.warn(`No timestamp found in filename: ${filename}`);
          return "0";
        }
        return match[1];
      };
      return getTimestamp(a.name).localeCompare(getTimestamp(b.name));
    });
  }
};
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/

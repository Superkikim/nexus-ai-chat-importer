/**
 * Nexus AI Chat Importer - Obsidian Plugin
 * Copyright (C) 2024 Akim Sissaoui
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


// src/services/import-service.ts
import { Notice } from "obsidian";
import JSZip from "jszip";
import { CustomError } from "../types/plugin";
import { getFileHash, ensureFolderExists, formatTimestamp } from "../utils";
import { showDialog } from "../dialogs";
import { ImportReport } from "../models/import-report";
import { ConversationProcessor } from "./conversation-processor";
import { NexusAiChatImporterError } from "../models/errors";
import { createProviderRegistry } from "../providers/provider-registry";
import { ProviderRegistry } from "../providers/provider-adapter";
import { logger } from "../logger";
import { ImportProgressModal, ImportProgressCallback } from "../ui/import-progress-modal";
import { AttachmentMapBuilder, AttachmentMap } from "./attachment-map-builder";
import { decideArchiveMode, ArchiveModeDecision } from "./archive-mode-decider";
import type NexusAiChatImporterPlugin from "../main";
import { loadZipSelective, enumerateZipEntries, enumerateZipEntriesRaw } from "../utils/zip-loader";
import { LazyZip } from "../utils/lazy-zip";
import { extractRawConversations, findGeminiActivityJsonFiles } from "../utils/zip-content-reader";
import { filterConversationsByIds as filterConversationsByIdsUsingAdapters } from "../utils/conversation-filter";
import type { GeminiIndex } from "../providers/gemini/gemini-types";

/** Audio/video extensions to skip on mobile to avoid OOM when no adapter filter is set. */
const MOBILE_SKIP_EXTS = new Set([
    "mp3", "m4a", "mp4", "webm", "ogg", "aac", "wav",
    "flac", "opus", "wma", "mov", "avi", "mkv", "dat"
]);
const DEFAULT_MOBILE_FILTER = (name: string, _size: number): boolean => {
    if (name.endsWith(".json")) return true;
    const ext = name.split(".").pop()?.toLowerCase() ?? "";
    return !MOBILE_SKIP_EXTS.has(ext);
};

export class ImportService {
    private importReport: ImportReport = new ImportReport();
    private conversationProcessor: ConversationProcessor;
    private providerRegistry: ProviderRegistry;
    private attachmentMapBuilder: AttachmentMapBuilder;
    private currentAttachmentMap: AttachmentMap | null = null;
    private currentZips: JSZip[] = [];

    constructor(private plugin: NexusAiChatImporterPlugin) {
        this.providerRegistry = createProviderRegistry(plugin);
        this.attachmentMapBuilder = new AttachmentMapBuilder(plugin.logger);
        this.conversationProcessor = new ConversationProcessor(plugin, this.providerRegistry);
    }

	    /**
	     * Set or clear the Gemini index on the Gemini adapter.
	     *
	     * When an index JSON generated by the browser extension is provided,
	     * this enables hash-based reconstruction of full Gemini conversations.
	     */
	    setGeminiIndex(index: GeminiIndex | null): void {
	        const adapter: any = this.providerRegistry.getAdapter("gemini");
	        if (adapter && typeof adapter.setIndex === "function") {
	            adapter.setIndex(index);
	            const status = index ? `loaded (conversations=${index.conversations?.length ?? 0})` : "cleared";
	            this.plugin.logger.info(`[Gemini] Index ${status} on ImportService adapter`);
	        } else {
	            this.plugin.logger.warn("[Gemini] Unable to set index: Gemini adapter not found or setIndex() missing");
	        }
	    }

    async selectZipFile() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".zip";
        input.multiple = true;
        input.onchange = async (e) => {
            const files = Array.from((e.target as HTMLInputElement).files || []);
            if (files.length > 0) {
                const sortedFiles = this.sortFilesByTimestamp(files);
                for (const file of sortedFiles) {
                    await this.handleZipFile(file);
                }
            }
        };
        input.click();
    }

    private sortFilesByTimestamp(files: File[]): File[] {
        return files.sort((a, b) => {
            const timestampRegex = /(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2})/;
            const getTimestamp = (filename: string) => {
                const match = filename.match(timestampRegex);
                if (!match) {
                    this.plugin.logger.warn(`No timestamp found in filename: ${filename}`);
                    return "0";
                }
                return match[1];
            };
            return getTimestamp(a.name).localeCompare(getTimestamp(b.name));
        });
    }

    async handleZipFile(file: File, forcedProvider?: string, selectedConversationIds?: string[], sharedReport?: ImportReport) {
        // Validate file extension before processing
        const fileName = file.name.toLowerCase();
        if (!fileName.endsWith('.zip')) {
            const errorMessage = `Invalid file format: "${file.name}"\n\n` +
                `Only ZIP files are supported. The file must have a .zip extension.\n\n` +
                `ðŸ“ Known Issue: When downloading Claude exports with Firefox on Mac, ` +
                `the file may have a .dat extension instead of .zip. ` +
                `Simply rename the file to change the extension from .dat to .zip, ` +
                `then try importing again.\n\n` +
                `Do NOT extract and re-compress the file - just rename it!`;

            new Notice(errorMessage, 10000); // Show for 10 seconds
            this.plugin.logger.error('Invalid file extension', {
                fileName: file.name,
                expectedExtension: '.zip'
            });
            throw new NexusAiChatImporterError(
                'Invalid file format',
                errorMessage
            );
        }

        // Use shared report if provided, otherwise create a new one
        const isSharedReport = !!sharedReport;
        this.importReport = sharedReport || new ImportReport();

        // Set custom timestamp format if enabled (only if creating new report)
        if (!isSharedReport && this.plugin.settings.useCustomMessageTimestampFormat) {
            this.importReport.setCustomTimestampFormat(this.plugin.settings.messageTimestampFormat);
        }

        // Start a new file section in the report
        this.importReport.startFileSection(file.name);

        // Reset counters for this file (prevents accumulation across multiple files)
        this.conversationProcessor.resetCounters();

        const storage = this.plugin.getStorageService();
        let processingStarted = false;

        // Create and show progress modal
        const progressModal = new ImportProgressModal(this.plugin.app, file.name);
        const progressCallback = progressModal.getProgressCallback();
        progressModal.open();

        // Set selective import mode if applicable
        if (selectedConversationIds && selectedConversationIds.length > 0) {
            // We'll set this after we know the total available count
            // This will be updated in processConversations
        }

        try {
            progressCallback({
                phase: 'validation',
                title: 'Validating ZIP structure...',
                detail: 'Checking file format and contents'
            });

            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [1/4 catalog] Reading ZIP Central Directory: ${file.name} (${file.size} bytes, mobile=${!(file as any).path})`);
            const fileNames = await this.validateZipFile(file, forcedProvider);
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [1/4 catalog] Done â€” ${fileNames.length} entries listed, 0 bytes decompressed, provider=${forcedProvider ?? 'auto-detect'}`);

            // Load ZIP content with mobile-safe filter (skip audio/video to avoid OOM).
            // On mobile, DEFAULT_MOBILE_FILTER runs as a hard gate BEFORE the adapter
            // filter. This is necessary because the ChatGPT adapter's Rule 1 allows all
            // small files regardless of type, meaning small WAV files (< 1 MB) would
            // still be decompressed and accumulate into hundreds of MB on iOS.
            const adapter = forcedProvider ? this.providerRegistry.getAdapter(forcedProvider) : undefined;
            const adapterFilter = adapter?.shouldIncludeZipEntry?.bind(adapter);
            const isMobile = !(file as any).path;

            // On mobile: use LazyZip â€” only the Central Directory is read upfront
            // (~KB of metadata). Each entry is decompressed on demand via File.slice
            // right before being written to disk, keeping peak RAM to ~1 entry at a time.
            // On desktop: yauzl streaming via loadZipSelective (unchanged).
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [2/4 decompress] Loading ZIP entries (mobile=${isMobile}, filter=${adapterFilter ? 'custom' : isMobile ? 'default-mobile' : 'all'})`);
            let zip: JSZip;
            if (isMobile) {
                const mobileFilter = (name: string, size: number): boolean => {
                    if (!DEFAULT_MOBILE_FILTER(name, size)) return false;
                    return adapterFilter ? adapterFilter(name, size) : true;
                };
                const lazyEntries = await enumerateZipEntriesRaw(file, mobileFilter);
                if (lazyEntries.length === 0) {
                    // ZIP64 or EOCD not found â€” fall back to full selective load
                    // eslint-disable-next-line no-console
                    console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [2/4 decompress] ZIP64/fallback â€” using loadZipSelective`);
                    zip = await loadZipSelective(file, mobileFilter);
                } else {
                    zip = new LazyZip(file, lazyEntries) as unknown as JSZip;
                    // eslint-disable-next-line no-console
                    console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [2/4 decompress] LazyZip ready â€” ${lazyEntries.length} entries indexed, 0 bytes decompressed`);
                }
            } else {
                zip = await loadZipSelective(file, adapterFilter);
                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [2/4 decompress] Done â€” ${Object.keys(zip.files).length} entries in memory`);
            }

            // When using shared report (new workflow), skip the "already imported" check
            // because the analysis already determined what needs to be imported
            let isReprocess = false;
            let fileHash = "";

            if (!isSharedReport) {
                // Legacy workflow: check if file was already imported
                progressCallback({
                    phase: 'validation',
                    title: 'Validating file...',
                    detail: 'Checking file hash and import history'
                });

                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [3/4 hash] Computing file hash (legacy mode, mobile=${!(file as any).path})`);
                fileHash = await getFileHash(file);
                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [3/4 hash] Done: ${fileHash.substring(0, 16)}...`);
                const foundByHash = storage.isArchiveImported(fileHash);
                const foundByName = storage.isArchiveImported(file.name);
                isReprocess = foundByHash || foundByName;

                if (isReprocess) {
                    progressModal.close(); // Close progress modal for user dialog

                    const shouldReimport = await showDialog(
                        this.plugin.app,
                        "confirmation",
                        "Already processed",
                        [
                            `File ${file.name} has already been imported.`,
                            `Do you want to reprocess it?`,
                            `**Note:** This will recreate notes from before v1.1.0 to add attachment support.`
                        ],
                        undefined,
                        { button1: "Let's do this", button2: "Skip this file" }
                    );

                    if (!shouldReimport) {
                        new Notice(`Skipping ${file.name} (already imported).`);
                        progressModal.close();
                        return; // Skip this file, but don't cancel the whole operation
                    }

                    // Reopen progress modal for continued processing
                    progressModal.open();
                }
            } else {
                // New workflow: always compute hash for tracking, but don't check/prompt
                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [3/4 hash] Computing file hash (shared mode, mobile=${!(file as any).path})`);
                fileHash = await getFileHash(file);
                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [3/4 hash] Done`);
            }

	            processingStarted = true;
	            // eslint-disable-next-line no-console
	            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [4/4 import] processConversations start`);
	            await this.processConversations(
	                zip,
	                file,
	                isReprocess,
	                forcedProvider,
	                progressCallback,
	                selectedConversationIds,
	                progressModal,
	                file.size
	            );
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [4/4 import] processConversations done`);

            // Track imported archive
            storage.addImportedArchive(fileHash, file.name);
            await this.plugin.saveSettings();

            progressCallback({
                phase: 'complete',
                title: 'Import completed successfully!',
                detail: `Processed ${this.conversationProcessor.getCounters().totalNewConversationsToImport + this.conversationProcessor.getCounters().totalExistingConversationsToUpdate} conversations`
            });

        } catch (error: unknown) {
            const message = error instanceof NexusAiChatImporterError
                ? error.message
                : error instanceof Error
                ? error.message
                : "An unknown error occurred";

            this.plugin.logger.error("Error handling zip file", { message });
            // eslint-disable-next-line no-console
            console.error(`[NexusAI][${new Date().toISOString().slice(11,23)}] [handleZipFile] FAILED ${file.name}: ${message}`);

            progressModal.close();
            if (isSharedReport) {
                // Multi-file mode: don't block with a dialog â€” record error and continue
                sharedReport!.addError(`Skipped: ${file.name}`, message);
                new Notice(`Skipped ${file.name}: ${message}`, 6000);
            } else {
                // Single-file mode: show blocking dialog as before
                await showDialog(
                    this.plugin.app,
                    "information",
                    "Import failed",
                    [message, "Please check the import report for more details."]
                );
            }
        } finally {
            // Only write report if processing actually started AND this is NOT a shared report
            // (shared reports are written by the caller after all files are processed)
            if (processingStarted && !isSharedReport) {
                await this.writeImportReport(file.name);

                // Only show notice if modal was closed due to error or completion
                if (!progressModal.isComplete) {
                    new Notice(
                        this.importReport.hasErrors()
                            ? "An error occurred during import. Please check the log file for details."
                            : "Import completed. Log file created in the archive folder."
                    );
                }
            }
        }
    }

    /**
     * Validate ZIP structure using enumerateZipEntries (zero decompression).
     * Returns file names on success; throws NexusAiChatImporterError on failure.
     *
     * Fix 1: Uses enumerateZipEntries instead of loadZipSelective so we never
     * decompress any entry just to check file names â€” critical for mobile OOM.
     * Fix 3: Structural provider validation from file names (ChatGPT vs Claude).
     */
    private async validateZipFile(file: File, forcedProvider?: string): Promise<string[]> {
        try {
            const entries = await enumerateZipEntries(file);
            const fileNames = entries.map(e => e.path);

            // Check if ZIP is empty
            if (fileNames.length === 0) {
                throw new NexusAiChatImporterError(
                    "Empty ZIP file",
                    "The ZIP file contains no files. Please check that you selected the correct export file."
                );
            }

            const geminiJsonFiles = findGeminiActivityJsonFiles(fileNames);
            const hasGeminiActivityJson = geminiJsonFiles.length > 0;

            // Structural signatures used for validation
            const hasUsersJson = fileNames.includes("users.json");       // Claude signature (plural)
            const hasUserJson = fileNames.includes("user.json");          // ChatGPT signature (singular)
            const hasMsgFeedback = fileNames.includes("message_feedback.json"); // ChatGPT signature

            if (forcedProvider) {
                if (forcedProvider === 'lechat') {
                    const hasLeChatFiles = fileNames.some(name => /^chat-[a-f0-9-]+\.json$/.test(name));
                    if (!hasLeChatFiles) {
                        throw new NexusAiChatImporterError(
                            "Wrong Provider Selected",
                            "No Le Chat conversation files (chat-<uuid>.json) found in this ZIP. " +
                            "Please select the correct provider for this export."
                        );
                    }
                } else if (forcedProvider === 'gemini') {
                    if (!hasGeminiActivityJson) {
                        throw new NexusAiChatImporterError(
                            "Wrong Provider Selected",
                            "No Gemini activity JSON found in this ZIP. " +
                            "Expected a Google Takeout export with a folder like:\n" +
                            "Takeout/<My Activity>/<*Gemini*>/My Activity.json"
                        );
                    }
                } else {
                    // ChatGPT or Claude
                    const hasConversations = fileNames.includes("conversations.json")
                        || fileNames.some(n => /^conversations-\d+\.json$/.test(n));
                    if (!hasConversations) {
                        throw new NexusAiChatImporterError(
                            "Invalid ZIP structure",
                            `Missing required file: conversations.json (or conversations-NNN.json) for ${forcedProvider} provider.`
                        );
                    }

                    // Fix 3: structural cross-provider validation
                    if (forcedProvider === 'chatgpt' && hasUsersJson && !hasUserJson) {
                        throw new NexusAiChatImporterError(
                            "Wrong Provider Selected",
                            "This ZIP appears to be a Claude export (contains users.json), not ChatGPT. " +
                            "Please select Claude as the provider and try again."
                        );
                    }
                    if (forcedProvider === 'claude' && hasUserJson && hasMsgFeedback && !hasUsersJson) {
                        throw new NexusAiChatImporterError(
                            "Wrong Provider Selected",
                            "This ZIP appears to be a ChatGPT export (contains user.json + message_feedback.json), not Claude. " +
                            "Please select ChatGPT as the provider and try again."
                        );
                    }
                }
            } else {
                // Auto-detection mode
                const hasConversationsJson = fileNames.includes("conversations.json")
                    || fileNames.some(n => /^conversations-\d+\.json$/.test(n));
                const hasProjectsJson = fileNames.includes("projects.json");
                const hasLeChatFiles = fileNames.some(name => /^chat-[a-f0-9-]+\.json$/.test(name));

                const isChatGPTFormat = hasConversationsJson && !hasUsersJson && !hasProjectsJson;
                const isClaudeFormat = hasConversationsJson && hasUsersJson;
                const isLeChatFormat = hasLeChatFiles && !hasConversationsJson;
                const isGeminiFormat = hasGeminiActivityJson && !hasConversationsJson && !hasLeChatFiles;

                if (!isChatGPTFormat && !isClaudeFormat && !isLeChatFormat && !isGeminiFormat) {
                    throw new NexusAiChatImporterError(
                        "Unrecognized Export Format",
                        "This ZIP file doesn't match any supported chat export format.\n\n" +
                        "Supported formats:\n" +
                        "â€¢ ChatGPT â€” contains conversations.json (without users.json)\n" +
                        "â€¢ Claude â€” contains conversations.json + users.json\n" +
                        "â€¢ Le Chat â€” contains chat-<uuid>.json files\n" +
                        "â€¢ Gemini â€” Google Takeout with Takeout/<Activity>/<*Gemini*>/My Activity.json"
                    );
                }
            }

            return fileNames;
        } catch (error: any) {
            if (error instanceof NexusAiChatImporterError) {
                throw error;
            }
            if (error.message && error.message.includes('corrupted')) {
                throw new NexusAiChatImporterError(
                    "Corrupted ZIP file",
                    "The file appears to be corrupted or is not a valid ZIP file. " +
                    "Please try downloading the export again from your AI provider."
                );
            }
            throw new NexusAiChatImporterError(
                "Error reading ZIP file",
                `Failed to read the ZIP file: ${error.message || 'Unknown error'}. ` +
                "Please ensure the file is a valid ZIP export from ChatGPT, Claude, Le Chat, or Gemini."
            );
        }
    }

	    private async processConversations(zip: JSZip, file: File, isReprocess: boolean, forcedProvider?: string, progressCallback?: ImportProgressCallback, selectedConversationIds?: string[], progressModal?: ImportProgressModal, zipSizeBytes?: number): Promise<void> {
        try {
            progressCallback?.({
                phase: 'scanning',
                title: 'Extracting conversations...',
                detail: 'Reading conversation data from ZIP file'
            });

            // Extract raw conversation data (provider agnostic)
	            const extractionResult = await this.extractRawConversationsFromZip(zip, zipSizeBytes);
	            let rawConversations = extractionResult.conversations;
	            const archiveModeDecision = extractionResult.archiveModeDecision;
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [4/4 extract] ${rawConversations.length} conversations found in ZIP`);

            // Filter conversations if specific IDs are selected
            if (selectedConversationIds && selectedConversationIds.length > 0) {
                const originalCount = rawConversations.length;
                rawConversations = this.filterConversationsByIds(rawConversations, selectedConversationIds, forcedProvider);
                // eslint-disable-next-line no-console
                console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [4/4 filter] ${rawConversations.length}/${originalCount} conversations selected for import`);

                // Set selective import mode in progress modal
                if (progressModal) {
                    progressModal.setSelectiveImportMode(rawConversations.length, originalCount);
                }

                progressCallback?.({
                    phase: 'scanning',
                    title: 'Filtering conversations...',
                    detail: `Selected ${rawConversations.length} of ${originalCount} conversations for import`,
                    total: rawConversations.length
                });
            }

            progressCallback?.({
                phase: 'scanning',
                title: 'Scanning existing conversations...',
                detail: 'Checking vault for existing conversations',
                total: rawConversations.length
            });

            // Validate provider if forced
            const detectedProvider = forcedProvider ?? this.providerRegistry.detectProvider(rawConversations);
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [4/4 detect] provider=${detectedProvider}${forcedProvider ? ' (forced)' : ' (auto-detected)'}`);
            if (forcedProvider) {
                this.validateProviderMatch(rawConversations, forcedProvider);
            }

	            const processingDetail = archiveModeDecision?.mode === "large-archive"
	                ? 'Processing a large archive using a streaming-safe pipeline'
	                : 'Converting and importing conversations';
	
	            progressCallback?.({
	                phase: 'processing',
	                title: 'Processing conversations...',
	                detail: processingDetail,
	                current: 0,
	                total: rawConversations.length
	            });

            // Process through conversation processor (handles provider detection/conversion)
            const report = await this.conversationProcessor.processRawConversations(
                rawConversations,
                this.importReport,
                zip,
                isReprocess,
                forcedProvider,
                progressCallback
            );

            this.importReport = report;
            this.importReport.setFileCounters(
                this.conversationProcessor.getCounters()
            );

            // Release the large array immediately after processing â€” the GC can then
            // collect the conversation objects (and any still-retained JSON strings)
            // before the caller allocates memory for the next ZIP file.
            rawConversations.length = 0;

            progressCallback?.({
                phase: 'writing',
                title: 'Finalizing import...',
                detail: 'Saving settings and generating report'
            });
        } catch (error: unknown) {
            if (error instanceof NexusAiChatImporterError) {
                this.plugin.logger.error("Error processing conversations", error.message);
                this.plugin.logger.error("Full NexusAiChatImporterError:", error);
            } else if (typeof error === 'object' && error instanceof Error) {
                this.plugin.logger.error("General error processing conversations", error.message);
                this.plugin.logger.error("Full Error:", error);
                this.plugin.logger.error("Stack trace:", error.stack);
            } else {
                this.plugin.logger.error("Unknown error processing conversations", "An unknown error occurred");
                this.plugin.logger.error("Unknown error:", error);
            }
            // Re-throw the error so it can be caught by the caller
            throw error;
        }
    }

    /**
     * Extract raw conversation data without knowing provider specifics
     * and decide archive mode based on ZIP and uncompressed sizes.
     *
     * Fix 2 (DRY): delegates format detection to the shared extractRawConversations()
     * in zip-content-reader.ts. Archive-mode decision remains here since it is
     * specific to the import pipeline (metadata extractor does not need it).
     */
    private async extractRawConversationsFromZip(
        zip: JSZip,
        zipSizeBytes?: number
    ): Promise<{ conversations: any[]; archiveModeDecision?: ArchiveModeDecision }> {
        const { conversations, uncompressedBytes } = await extractRawConversations(zip);

        let archiveModeDecision: ArchiveModeDecision | undefined;
        if (typeof zipSizeBytes === "number") {
            archiveModeDecision = decideArchiveMode({
                zipSizeBytes,
                conversationsUncompressedBytes: uncompressedBytes
            });
            if (archiveModeDecision.mode === "large-archive") {
                this.plugin.logger.info(
                    `Large archive detected (reason: ${archiveModeDecision.reason}, zipSizeBytes=${zipSizeBytes}, uncompressedBytes=${uncompressedBytes})`
                );
            }
        }

        return { conversations, archiveModeDecision };
    }

    /**
     * Filter conversations by selected IDs
     */
    private filterConversationsByIds(rawConversations: any[], selectedIds: string[], forcedProvider?: string): any[] {
	        return filterConversationsByIdsUsingAdapters(
	            rawConversations,
	            selectedIds,
	            this.providerRegistry,
	            forcedProvider
	        );
    }

    /**
     * Validate that the forced provider matches the actual content structure
     */
    private validateProviderMatch(rawConversations: any[], forcedProvider: string): void {
        if (rawConversations.length === 0) return;

        const firstConversation = rawConversations[0];

        // Check for ChatGPT structure
        const isChatGPT = firstConversation.mapping !== undefined;

        // Check for Claude structure
        const isClaude = firstConversation.chat_messages !== undefined ||
                        firstConversation.name !== undefined ||
                        firstConversation.summary !== undefined;

        // Check for Le Chat structure (array of messages)
        const isLeChat = Array.isArray(firstConversation) &&
                        firstConversation.length > 0 &&
                        firstConversation[0].chatId !== undefined &&
                        firstConversation[0].contentChunks !== undefined;

	        // Check for Gemini My Activity structure
	        const isGemini = !!firstConversation &&
	            typeof firstConversation.header === "string" &&
	            typeof firstConversation.title === "string" &&
	            typeof firstConversation.time === "string" &&
	            (Array.isArray(firstConversation.safeHtmlItem) ||
	             Array.isArray(firstConversation.activityControls) ||
	             Array.isArray(firstConversation.products));

        if (forcedProvider === 'chatgpt' && !isChatGPT) {
            throw new NexusAiChatImporterError(
                "Provider Mismatch",
                "You selected ChatGPT but this archive appears to be from another provider. The structure doesn't match ChatGPT exports."
            );
        }

        if (forcedProvider === 'claude' && !isClaude) {
            throw new NexusAiChatImporterError(
                "Provider Mismatch",
                "You selected Claude but this archive appears to be from another provider. The structure doesn't match Claude exports."
            );
        }

        if (forcedProvider === 'lechat' && !isLeChat) {
            throw new NexusAiChatImporterError(
                "Provider Mismatch",
                "You selected Le Chat but this archive appears to be from another provider. The structure doesn't match Le Chat exports."
            );
        }

	        if (forcedProvider === 'gemini' && !isGemini) {
	            throw new NexusAiChatImporterError(
	                "Provider Mismatch",
	                "You selected Gemini but this archive appears to be from another provider. The structure doesn't match Gemini My Activity exports."
	            );
	        }
    }

    private async writeImportReport(zipFileName: string): Promise<void> {
        const reportWriter = new ReportWriter(this.plugin, this.providerRegistry);
        const currentProvider = this.conversationProcessor.getCurrentProvider();
        await reportWriter.writeReport(this.importReport, zipFileName, currentProvider);
    }

    /**
     * Build attachment map for multi-ZIP import
     * Opens all ZIPs and scans for available attachments
     */
    async buildAttachmentMapForMultiZip(files: File[], provider?: string): Promise<void> {
        try {
            const adapter = provider ? this.providerRegistry.getAdapter(provider) : undefined;
            const entryFilter = adapter?.shouldIncludeZipEntry?.bind(adapter);

            // Build the attachment map
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] Building attachment map: ${files.length} files, provider=${provider ?? 'auto'}`);
            this.currentAttachmentMap = await this.attachmentMapBuilder.buildAttachmentMap(files);
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] Attachment map built: ${this.currentAttachmentMap?.size ?? 0} entries`);

            // Open all ZIPs for later access (mobile: use LazyZip to avoid OOM)
            this.currentZips = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const isMobile = !(file as any).path;
                try {
                    // eslint-disable-next-line no-console
                    console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] [${i + 1}/${files.length}] Opening ${file.name} (${(file.size / 1024 / 1024).toFixed(0)} MB, mobile=${isMobile})`);
                    let zipContent: JSZip;
                    if (isMobile) {
                        // On mobile: use LazyZip so all ZIPs can be open simultaneously
                        // without decompressing any content (only Central Directory metadata).
                        const mobileFilter = entryFilter
                            ? (name: string, size: number) => DEFAULT_MOBILE_FILTER(name, 0) && entryFilter(name, size)
                            : DEFAULT_MOBILE_FILTER;
                        const lazyEntries = await enumerateZipEntriesRaw(file, mobileFilter);
                        zipContent = lazyEntries.length > 0
                            ? new LazyZip(file, lazyEntries) as unknown as JSZip
                            : await loadZipSelective(file, mobileFilter); // ZIP64 fallback
                    } else {
                        zipContent = await loadZipSelective(file, entryFilter);
                    }
                    this.currentZips.push(zipContent);
                    // eslint-disable-next-line no-console
                    console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] [${i + 1}/${files.length}] ${file.name}: ${Object.keys(zipContent.files).length} entries indexed`);
                } catch (error) {
                    this.plugin.logger.error(`Failed to open ZIP for attachment map: ${file.name}`, error);
                    // eslint-disable-next-line no-console
                    console.error(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] [${i + 1}/${files.length}] FAILED: ${file.name}:`, error instanceof Error ? error.message : error);
                }
            }
            // eslint-disable-next-line no-console
            console.log(`[NexusAI][${new Date().toISOString().slice(11,23)}] [attachmap] Done â€” ${this.currentZips.length}/${files.length} ZIPs indexed`);

            // Pass the attachment map to the ChatGPT adapter
            const chatgptAdapter = this.providerRegistry.getAdapter('chatgpt') as any;
            if (chatgptAdapter && this.currentAttachmentMap) {
                chatgptAdapter.setAttachmentMap(this.currentAttachmentMap, this.currentZips);
            }
        } catch (error) {
            this.plugin.logger.error('Error building attachment map:', error);
            throw error;
        }
    }

    /**
     * Clear attachment map and close ZIPs after import completes
     */
    clearAttachmentMap(): void {
        this.currentAttachmentMap = null;
        this.currentZips = [];

        const chatgptAdapter = this.providerRegistry.getAdapter('chatgpt') as any;
        if (chatgptAdapter) {
            chatgptAdapter.clearAttachmentMap();
        }
    }
}

class ReportWriter {
    constructor(private plugin: NexusAiChatImporterPlugin, private providerRegistry: ProviderRegistry) {}

    async writeReport(report: ImportReport, zipFileName: string, provider: string): Promise<void> {
        // Static imports - no dynamic import needed

        // Get provider-specific naming strategy and set column header
        const reportInfo = this.getReportGenerationInfo(zipFileName, provider);
        const adapter = this.providerRegistry.getAdapter(provider);
        if (adapter) {
            const strategy = adapter.getReportNamingStrategy();
            const columnInfo = strategy.getProviderSpecificColumn();
            report.setProviderSpecificColumnHeader(columnInfo.header);
        }

        // Ensure provider subfolder exists
        const folderResult = await ensureFolderExists(reportInfo.folderPath, this.plugin.app.vault);
        if (!folderResult.success) {
            this.plugin.logger.error(`Failed to create or access log folder: ${reportInfo.folderPath}`, folderResult.error);
            new Notice("Failed to create log file. Check console for details.");
            return;
        }

        // Generate unique filename with counter if needed
        let logFilePath = `${reportInfo.folderPath}/${reportInfo.baseFileName}`;
        let counter = 2;
        while (await this.plugin.app.vault.adapter.exists(logFilePath)) {
            const baseName = reportInfo.baseFileName.replace(' - import report.md', '');
            logFilePath = `${reportInfo.folderPath}/${baseName}-${counter} - import report.md`;
            counter++;
        }

        // Enhanced frontmatter with both dates (ISO 8601 format for consistency)
        const currentDate = new Date().toISOString();
        const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
        
        const logContent = `---
importdate: ${currentDate}
archivedate: ${archiveDate}
zipFile: ${zipFileName}
provider: ${provider}
totalSuccessfulImports: ${report.getCreatedCount()}
totalUpdatedImports: ${report.getUpdatedCount()}
totalSkippedImports: ${report.getSkippedCount()}
---

${report.generateReportContent()}
`;

        try {
            await this.plugin.app.vault.create(logFilePath, logContent);
        } catch (error: any) {
            this.plugin.logger.error(`Failed to write import log`, error.message);
            new Notice("Failed to create log file. Check console for details.");
        }
    }

    private getReportGenerationInfo(zipFileName: string, provider: string): { folderPath: string, baseFileName: string } {
        const reportFolder = this.plugin.settings.reportFolder;

        // Try to get provider-specific naming strategy
        const adapter = this.providerRegistry.getAdapter(provider);
        if (adapter) {
            const strategy = adapter.getReportNamingStrategy();
            const reportPrefix = strategy.extractReportPrefix(zipFileName);
            return {
                folderPath: `${reportFolder}/${strategy.getProviderName()}`,
                baseFileName: `${reportPrefix} - import report.md`
            };
        }

        // Fallback for unknown providers
        const now = new Date();
        const importDate = `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, '0')}.${String(now.getDate()).padStart(2, '0')}`;
        const archiveDate = this.extractArchiveDateFromFilename(zipFileName);
        const fallbackPrefix = `imported-${importDate}-archive-${archiveDate}`;
        return {
            folderPath: `${reportFolder}`,
            baseFileName: `${fallbackPrefix} - import report.md`
        };
    }

    private extractArchiveDateFromFilename(zipFileName: string): string {
        const dateRegex = /(\d{4})-(\d{2})-(\d{2})/;
        const match = zipFileName.match(dateRegex);

        if (match) {
            const [, year, month, day] = match;
            return `${year}.${month}.${day}`;
        }

        // Fallback: use current date
        const now = new Date();
        return `${now.getFullYear()}.${String(now.getMonth() + 1).padStart(2, '0')}.${String(now.getDate()).padStart(2, '0')}`;
    }
}